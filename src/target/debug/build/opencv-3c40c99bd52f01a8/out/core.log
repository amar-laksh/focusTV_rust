parseName: class cv.Mat with set(['cv']) -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat (['class cv.Mat', '', ['/Ghost'], []])
parseName: class cv.Algorithm with set(['cv']) -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm (['class cv.Algorithm', '', ['/Ghost'], []])


===== Header: /usr/include/opencv2/core/types_c.h =====
Namespaces: set(['', 'cv'])

--- Incoming ---
[u'const CV_EXPORTS_W', u'CV_EXPORTS', [], [], '']
parseName: const CV_EXPORTS_W with ['', 'cv'] -> fullname:CV_EXPORTS_W namespace: classpath: classname: name:CV_EXPORTS_W
ignored: CONST CV_EXPORTS_W=CV_EXPORTS

--- Incoming ---
[u'const CV_EXPORTS_W_SIMPLE', u'CV_EXPORTS', [], [], '']
parseName: const CV_EXPORTS_W_SIMPLE with ['', 'cv'] -> fullname:CV_EXPORTS_W_SIMPLE namespace: classpath: classname: name:CV_EXPORTS_W_SIMPLE
ignored: CONST CV_EXPORTS_W_SIMPLE=CV_EXPORTS

--- Incoming ---
[u'const CV_EXPORTS_W_MAP', u'CV_EXPORTS', [], [], '']
parseName: const CV_EXPORTS_W_MAP with ['', 'cv'] -> fullname:CV_EXPORTS_W_MAP namespace: classpath: classname: name:CV_EXPORTS_W_MAP
ignored: CONST CV_EXPORTS_W_MAP=CV_EXPORTS

--- Incoming ---
[u'const CV_StsOk', u'0', [], []]
parseName: const CV_StsOk with ['', 'cv'] -> fullname:CV_StsOk namespace: classpath: classname: name:CV_StsOk

--- Incoming ---
[u'const CV_StsBackTrace', u'-1', [], []]
parseName: const CV_StsBackTrace with ['', 'cv'] -> fullname:CV_StsBackTrace namespace: classpath: classname: name:CV_StsBackTrace

--- Incoming ---
[u'const CV_StsError', u'-2', [], []]
parseName: const CV_StsError with ['', 'cv'] -> fullname:CV_StsError namespace: classpath: classname: name:CV_StsError

--- Incoming ---
[u'const CV_StsInternal', u'-3', [], []]
parseName: const CV_StsInternal with ['', 'cv'] -> fullname:CV_StsInternal namespace: classpath: classname: name:CV_StsInternal

--- Incoming ---
[u'const CV_StsNoMem', u'-4', [], []]
parseName: const CV_StsNoMem with ['', 'cv'] -> fullname:CV_StsNoMem namespace: classpath: classname: name:CV_StsNoMem

--- Incoming ---
[u'const CV_StsBadArg', u'-5', [], []]
parseName: const CV_StsBadArg with ['', 'cv'] -> fullname:CV_StsBadArg namespace: classpath: classname: name:CV_StsBadArg

--- Incoming ---
[u'const CV_StsBadFunc', u'-6', [], []]
parseName: const CV_StsBadFunc with ['', 'cv'] -> fullname:CV_StsBadFunc namespace: classpath: classname: name:CV_StsBadFunc

--- Incoming ---
[u'const CV_StsNoConv', u'-7', [], []]
parseName: const CV_StsNoConv with ['', 'cv'] -> fullname:CV_StsNoConv namespace: classpath: classname: name:CV_StsNoConv

--- Incoming ---
[u'const CV_StsAutoTrace', u'-8', [], []]
parseName: const CV_StsAutoTrace with ['', 'cv'] -> fullname:CV_StsAutoTrace namespace: classpath: classname: name:CV_StsAutoTrace

--- Incoming ---
[u'const CV_HeaderIsNull', u'-9', [], []]
parseName: const CV_HeaderIsNull with ['', 'cv'] -> fullname:CV_HeaderIsNull namespace: classpath: classname: name:CV_HeaderIsNull

--- Incoming ---
[u'const CV_BadImageSize', u'-10', [], []]
parseName: const CV_BadImageSize with ['', 'cv'] -> fullname:CV_BadImageSize namespace: classpath: classname: name:CV_BadImageSize

--- Incoming ---
[u'const CV_BadOffset', u'-11', [], []]
parseName: const CV_BadOffset with ['', 'cv'] -> fullname:CV_BadOffset namespace: classpath: classname: name:CV_BadOffset

--- Incoming ---
[u'const CV_BadDataPtr', u'-12', [], []]
parseName: const CV_BadDataPtr with ['', 'cv'] -> fullname:CV_BadDataPtr namespace: classpath: classname: name:CV_BadDataPtr

--- Incoming ---
[u'const CV_BadStep', u'-13', [], []]
parseName: const CV_BadStep with ['', 'cv'] -> fullname:CV_BadStep namespace: classpath: classname: name:CV_BadStep

--- Incoming ---
[u'const CV_BadModelOrChSeq', u'-14', [], []]
parseName: const CV_BadModelOrChSeq with ['', 'cv'] -> fullname:CV_BadModelOrChSeq namespace: classpath: classname: name:CV_BadModelOrChSeq

--- Incoming ---
[u'const CV_BadNumChannels', u'-15', [], []]
parseName: const CV_BadNumChannels with ['', 'cv'] -> fullname:CV_BadNumChannels namespace: classpath: classname: name:CV_BadNumChannels

--- Incoming ---
[u'const CV_BadNumChannel1U', u'-16', [], []]
parseName: const CV_BadNumChannel1U with ['', 'cv'] -> fullname:CV_BadNumChannel1U namespace: classpath: classname: name:CV_BadNumChannel1U

--- Incoming ---
[u'const CV_BadDepth', u'-17', [], []]
parseName: const CV_BadDepth with ['', 'cv'] -> fullname:CV_BadDepth namespace: classpath: classname: name:CV_BadDepth

--- Incoming ---
[u'const CV_BadAlphaChannel', u'-18', [], []]
parseName: const CV_BadAlphaChannel with ['', 'cv'] -> fullname:CV_BadAlphaChannel namespace: classpath: classname: name:CV_BadAlphaChannel

--- Incoming ---
[u'const CV_BadOrder', u'-19', [], []]
parseName: const CV_BadOrder with ['', 'cv'] -> fullname:CV_BadOrder namespace: classpath: classname: name:CV_BadOrder

--- Incoming ---
[u'const CV_BadOrigin', u'-20', [], []]
parseName: const CV_BadOrigin with ['', 'cv'] -> fullname:CV_BadOrigin namespace: classpath: classname: name:CV_BadOrigin

--- Incoming ---
[u'const CV_BadAlign', u'-21', [], []]
parseName: const CV_BadAlign with ['', 'cv'] -> fullname:CV_BadAlign namespace: classpath: classname: name:CV_BadAlign

--- Incoming ---
[u'const CV_BadCallBack', u'-22', [], []]
parseName: const CV_BadCallBack with ['', 'cv'] -> fullname:CV_BadCallBack namespace: classpath: classname: name:CV_BadCallBack

--- Incoming ---
[u'const CV_BadTileSize', u'-23', [], []]
parseName: const CV_BadTileSize with ['', 'cv'] -> fullname:CV_BadTileSize namespace: classpath: classname: name:CV_BadTileSize

--- Incoming ---
[u'const CV_BadCOI', u'-24', [], []]
parseName: const CV_BadCOI with ['', 'cv'] -> fullname:CV_BadCOI namespace: classpath: classname: name:CV_BadCOI

--- Incoming ---
[u'const CV_BadROISize', u'-25', [], []]
parseName: const CV_BadROISize with ['', 'cv'] -> fullname:CV_BadROISize namespace: classpath: classname: name:CV_BadROISize

--- Incoming ---
[u'const CV_MaskIsTiled', u'-26', [], []]
parseName: const CV_MaskIsTiled with ['', 'cv'] -> fullname:CV_MaskIsTiled namespace: classpath: classname: name:CV_MaskIsTiled

--- Incoming ---
[u'const CV_StsNullPtr', u'-27', [], []]
parseName: const CV_StsNullPtr with ['', 'cv'] -> fullname:CV_StsNullPtr namespace: classpath: classname: name:CV_StsNullPtr

--- Incoming ---
[u'const CV_StsVecLengthErr', u'-28', [], []]
parseName: const CV_StsVecLengthErr with ['', 'cv'] -> fullname:CV_StsVecLengthErr namespace: classpath: classname: name:CV_StsVecLengthErr

--- Incoming ---
[u'const CV_StsFilterStructContentErr', u'-29', [], []]
parseName: const CV_StsFilterStructContentErr with ['', 'cv'] -> fullname:CV_StsFilterStructContentErr namespace: classpath: classname: name:CV_StsFilterStructContentErr

--- Incoming ---
[u'const CV_StsKernelStructContentErr', u'-30', [], []]
parseName: const CV_StsKernelStructContentErr with ['', 'cv'] -> fullname:CV_StsKernelStructContentErr namespace: classpath: classname: name:CV_StsKernelStructContentErr

--- Incoming ---
[u'const CV_StsFilterOffsetErr', u'-31', [], []]
parseName: const CV_StsFilterOffsetErr with ['', 'cv'] -> fullname:CV_StsFilterOffsetErr namespace: classpath: classname: name:CV_StsFilterOffsetErr

--- Incoming ---
[u'const CV_StsBadSize', u'-201', [], []]
parseName: const CV_StsBadSize with ['', 'cv'] -> fullname:CV_StsBadSize namespace: classpath: classname: name:CV_StsBadSize

--- Incoming ---
[u'const CV_StsDivByZero', u'-202', [], []]
parseName: const CV_StsDivByZero with ['', 'cv'] -> fullname:CV_StsDivByZero namespace: classpath: classname: name:CV_StsDivByZero

--- Incoming ---
[u'const CV_StsInplaceNotSupported', u'-203', [], []]
parseName: const CV_StsInplaceNotSupported with ['', 'cv'] -> fullname:CV_StsInplaceNotSupported namespace: classpath: classname: name:CV_StsInplaceNotSupported

--- Incoming ---
[u'const CV_StsObjectNotFound', u'-204', [], []]
parseName: const CV_StsObjectNotFound with ['', 'cv'] -> fullname:CV_StsObjectNotFound namespace: classpath: classname: name:CV_StsObjectNotFound

--- Incoming ---
[u'const CV_StsUnmatchedFormats', u'-205', [], []]
parseName: const CV_StsUnmatchedFormats with ['', 'cv'] -> fullname:CV_StsUnmatchedFormats namespace: classpath: classname: name:CV_StsUnmatchedFormats

--- Incoming ---
[u'const CV_StsBadFlag', u'-206', [], []]
parseName: const CV_StsBadFlag with ['', 'cv'] -> fullname:CV_StsBadFlag namespace: classpath: classname: name:CV_StsBadFlag

--- Incoming ---
[u'const CV_StsBadPoint', u'-207', [], []]
parseName: const CV_StsBadPoint with ['', 'cv'] -> fullname:CV_StsBadPoint namespace: classpath: classname: name:CV_StsBadPoint

--- Incoming ---
[u'const CV_StsBadMask', u'-208', [], []]
parseName: const CV_StsBadMask with ['', 'cv'] -> fullname:CV_StsBadMask namespace: classpath: classname: name:CV_StsBadMask

--- Incoming ---
[u'const CV_StsUnmatchedSizes', u'-209', [], []]
parseName: const CV_StsUnmatchedSizes with ['', 'cv'] -> fullname:CV_StsUnmatchedSizes namespace: classpath: classname: name:CV_StsUnmatchedSizes

--- Incoming ---
[u'const CV_StsUnsupportedFormat', u'-210', [], []]
parseName: const CV_StsUnsupportedFormat with ['', 'cv'] -> fullname:CV_StsUnsupportedFormat namespace: classpath: classname: name:CV_StsUnsupportedFormat

--- Incoming ---
[u'const CV_StsOutOfRange', u'-211', [], []]
parseName: const CV_StsOutOfRange with ['', 'cv'] -> fullname:CV_StsOutOfRange namespace: classpath: classname: name:CV_StsOutOfRange

--- Incoming ---
[u'const CV_StsParseError', u'-212', [], []]
parseName: const CV_StsParseError with ['', 'cv'] -> fullname:CV_StsParseError namespace: classpath: classname: name:CV_StsParseError

--- Incoming ---
[u'const CV_StsNotImplemented', u'-213', [], []]
parseName: const CV_StsNotImplemented with ['', 'cv'] -> fullname:CV_StsNotImplemented namespace: classpath: classname: name:CV_StsNotImplemented

--- Incoming ---
[u'const CV_StsBadMemBlock', u'-214', [], []]
parseName: const CV_StsBadMemBlock with ['', 'cv'] -> fullname:CV_StsBadMemBlock namespace: classpath: classname: name:CV_StsBadMemBlock

--- Incoming ---
[u'const CV_StsAssert', u'-215', [], []]
parseName: const CV_StsAssert with ['', 'cv'] -> fullname:CV_StsAssert namespace: classpath: classname: name:CV_StsAssert

--- Incoming ---
[u'const CV_GpuNotSupported', u'-216', [], []]
parseName: const CV_GpuNotSupported with ['', 'cv'] -> fullname:CV_GpuNotSupported namespace: classpath: classname: name:CV_GpuNotSupported

--- Incoming ---
[u'const CV_GpuApiCallError', u'-217', [], []]
parseName: const CV_GpuApiCallError with ['', 'cv'] -> fullname:CV_GpuApiCallError namespace: classpath: classname: name:CV_GpuApiCallError

--- Incoming ---
[u'const CV_OpenGlNotSupported', u'-218', [], []]
parseName: const CV_OpenGlNotSupported with ['', 'cv'] -> fullname:CV_OpenGlNotSupported namespace: classpath: classname: name:CV_OpenGlNotSupported

--- Incoming ---
[u'const CV_OpenGlApiCallError', u'-219', [], []]
parseName: const CV_OpenGlApiCallError with ['', 'cv'] -> fullname:CV_OpenGlApiCallError namespace: classpath: classname: name:CV_OpenGlApiCallError

--- Incoming ---
[u'const CV_OpenCLDoubleNotSupported', u'-220', [], []]
parseName: const CV_OpenCLDoubleNotSupported with ['', 'cv'] -> fullname:CV_OpenCLDoubleNotSupported namespace: classpath: classname: name:CV_OpenCLDoubleNotSupported

--- Incoming ---
[u'const CV_OpenCLInitError', u'-221', [], []]
parseName: const CV_OpenCLInitError with ['', 'cv'] -> fullname:CV_OpenCLInitError namespace: classpath: classname: name:CV_OpenCLInitError

--- Incoming ---
[u'const CV_OpenCLNoAMDBlasFft', u'-222', [], []]
parseName: const CV_OpenCLNoAMDBlasFft with ['', 'cv'] -> fullname:CV_OpenCLNoAMDBlasFft namespace: classpath: classname: name:CV_OpenCLNoAMDBlasFft

--- Incoming ---
[u'const CV_PI', u'3.1415926535897932384626433832795', [], [], '']
parseName: const CV_PI with ['', 'cv'] -> fullname:CV_PI namespace: classpath: classname: name:CV_PI
ignored: CONST CV_PI=3.1415926535897932384626433832795

--- Incoming ---
[u'const CV_LOG2', u'0.69314718055994530941723212145818', [], [], '']
parseName: const CV_LOG2 with ['', 'cv'] -> fullname:CV_LOG2 namespace: classpath: classname: name:CV_LOG2
ignored: CONST CV_LOG2=0.69314718055994530941723212145818

--- Incoming ---
[u'cvRound', u'int', ['/NW'], [[u'double', u'value', '', []]], '']
parseName: cvRound with ['', 'cv'] -> fullname:cvRound namespace: classpath: classname: name:cvRound
register (function) cvRound

--- Incoming ---
[u'cvFloor', u'int', ['/NW'], [[u'double', u'value', '', []]], '']
parseName: cvFloor with ['', 'cv'] -> fullname:cvFloor namespace: classpath: classname: name:cvFloor
register (function) cvFloor

--- Incoming ---
[u'cvCeil', u'int', ['/NW'], [[u'double', u'value', '', []]], '']
parseName: cvCeil with ['', 'cv'] -> fullname:cvCeil namespace: classpath: classname: name:cvCeil
register (function) cvCeil

--- Incoming ---
[u'cvIsNaN', u'int', ['/NW'], [[u'double', u'value', '', []]], '']
parseName: cvIsNaN with ['', 'cv'] -> fullname:cvIsNaN namespace: classpath: classname: name:cvIsNaN
register (function) cvIsNaN

--- Incoming ---
[u'cvIsInf', u'int', ['/NW'], [[u'double', u'value', '', []]], '']
parseName: cvIsInf with ['', 'cv'] -> fullname:cvIsInf namespace: classpath: classname: name:cvIsInf
register (function) cvIsInf

--- Incoming ---
[u'const CV_RNG_COEFF', u'4164903690U', [], [], '']
parseName: const CV_RNG_COEFF with ['', 'cv'] -> fullname:CV_RNG_COEFF namespace: classpath: classname: name:CV_RNG_COEFF
ignored: CONST CV_RNG_COEFF=4164903690U

--- Incoming ---
[u'cvRNG', u'CvRNG', ['/NW'], [[u'int64', u'seed', u'-1', []]], '']
parseName: cvRNG with ['', 'cv'] -> fullname:cvRNG namespace: classpath: classname: name:cvRNG
register (function) cvRNG

--- Incoming ---
[u'cvRandInt', u'unsigned', ['/NW'], [[u'CvRNG*', u'rng', '', []]], '']
parseName: cvRandInt with ['', 'cv'] -> fullname:cvRandInt namespace: classpath: classname: name:cvRandInt
Registering an unknown type: unsigned
register (function) cvRandInt

--- Incoming ---
[u'cvRandReal', u'double', ['/NW'], [[u'CvRNG*', u'rng', '', []]], '']
parseName: cvRandReal with ['', 'cv'] -> fullname:cvRandReal namespace: classpath: classname: name:cvRandReal
register (function) cvRandReal

--- Incoming ---
[u'const IPL_DEPTH_SIGN', u'0x80000000', [], [], '']
parseName: const IPL_DEPTH_SIGN with ['', 'cv'] -> fullname:IPL_DEPTH_SIGN namespace: classpath: classname: name:IPL_DEPTH_SIGN

--- Incoming ---
[u'const IPL_DEPTH_1U', u'1', [], [], '']
parseName: const IPL_DEPTH_1U with ['', 'cv'] -> fullname:IPL_DEPTH_1U namespace: classpath: classname: name:IPL_DEPTH_1U

--- Incoming ---
[u'const IPL_DEPTH_8U', u'8', [], [], '']
parseName: const IPL_DEPTH_8U with ['', 'cv'] -> fullname:IPL_DEPTH_8U namespace: classpath: classname: name:IPL_DEPTH_8U

--- Incoming ---
[u'const IPL_DEPTH_16U', u'16', [], [], '']
parseName: const IPL_DEPTH_16U with ['', 'cv'] -> fullname:IPL_DEPTH_16U namespace: classpath: classname: name:IPL_DEPTH_16U

--- Incoming ---
[u'const IPL_DEPTH_32F', u'32', [], [], '']
parseName: const IPL_DEPTH_32F with ['', 'cv'] -> fullname:IPL_DEPTH_32F namespace: classpath: classname: name:IPL_DEPTH_32F

--- Incoming ---
[u'const IPL_DEPTH_8S', u'(IPL_DEPTH_SIGN| 8)', [], [], '']
parseName: const IPL_DEPTH_8S with ['', 'cv'] -> fullname:IPL_DEPTH_8S namespace: classpath: classname: name:IPL_DEPTH_8S

--- Incoming ---
[u'const IPL_DEPTH_16S', u'(IPL_DEPTH_SIGN|16)', [], [], '']
parseName: const IPL_DEPTH_16S with ['', 'cv'] -> fullname:IPL_DEPTH_16S namespace: classpath: classname: name:IPL_DEPTH_16S

--- Incoming ---
[u'const IPL_DEPTH_32S', u'(IPL_DEPTH_SIGN|32)', [], [], '']
parseName: const IPL_DEPTH_32S with ['', 'cv'] -> fullname:IPL_DEPTH_32S namespace: classpath: classname: name:IPL_DEPTH_32S

--- Incoming ---
[u'const IPL_DATA_ORDER_PIXEL', u'0', [], [], '']
parseName: const IPL_DATA_ORDER_PIXEL with ['', 'cv'] -> fullname:IPL_DATA_ORDER_PIXEL namespace: classpath: classname: name:IPL_DATA_ORDER_PIXEL

--- Incoming ---
[u'const IPL_DATA_ORDER_PLANE', u'1', [], [], '']
parseName: const IPL_DATA_ORDER_PLANE with ['', 'cv'] -> fullname:IPL_DATA_ORDER_PLANE namespace: classpath: classname: name:IPL_DATA_ORDER_PLANE

--- Incoming ---
[u'const IPL_ORIGIN_TL', u'0', [], [], '']
parseName: const IPL_ORIGIN_TL with ['', 'cv'] -> fullname:IPL_ORIGIN_TL namespace: classpath: classname: name:IPL_ORIGIN_TL

--- Incoming ---
[u'const IPL_ORIGIN_BL', u'1', [], [], '']
parseName: const IPL_ORIGIN_BL with ['', 'cv'] -> fullname:IPL_ORIGIN_BL namespace: classpath: classname: name:IPL_ORIGIN_BL

--- Incoming ---
[u'const IPL_ALIGN_4BYTES', u'4', [], [], '']
parseName: const IPL_ALIGN_4BYTES with ['', 'cv'] -> fullname:IPL_ALIGN_4BYTES namespace: classpath: classname: name:IPL_ALIGN_4BYTES

--- Incoming ---
[u'const IPL_ALIGN_8BYTES', u'8', [], [], '']
parseName: const IPL_ALIGN_8BYTES with ['', 'cv'] -> fullname:IPL_ALIGN_8BYTES namespace: classpath: classname: name:IPL_ALIGN_8BYTES

--- Incoming ---
[u'const IPL_ALIGN_16BYTES', u'16', [], [], '']
parseName: const IPL_ALIGN_16BYTES with ['', 'cv'] -> fullname:IPL_ALIGN_16BYTES namespace: classpath: classname: name:IPL_ALIGN_16BYTES

--- Incoming ---
[u'const IPL_ALIGN_32BYTES', u'32', [], [], '']
parseName: const IPL_ALIGN_32BYTES with ['', 'cv'] -> fullname:IPL_ALIGN_32BYTES namespace: classpath: classname: name:IPL_ALIGN_32BYTES

--- Incoming ---
[u'const IPL_ALIGN_DWORD', u'IPL_ALIGN_4BYTES', [], [], '']
parseName: const IPL_ALIGN_DWORD with ['', 'cv'] -> fullname:IPL_ALIGN_DWORD namespace: classpath: classname: name:IPL_ALIGN_DWORD

--- Incoming ---
[u'const IPL_ALIGN_QWORD', u'IPL_ALIGN_8BYTES', [], [], '']
parseName: const IPL_ALIGN_QWORD with ['', 'cv'] -> fullname:IPL_ALIGN_QWORD namespace: classpath: classname: name:IPL_ALIGN_QWORD

--- Incoming ---
[u'const IPL_BORDER_CONSTANT', u'0', [], [], '']
parseName: const IPL_BORDER_CONSTANT with ['', 'cv'] -> fullname:IPL_BORDER_CONSTANT namespace: classpath: classname: name:IPL_BORDER_CONSTANT

--- Incoming ---
[u'const IPL_BORDER_REPLICATE', u'1', [], [], '']
parseName: const IPL_BORDER_REPLICATE with ['', 'cv'] -> fullname:IPL_BORDER_REPLICATE namespace: classpath: classname: name:IPL_BORDER_REPLICATE

--- Incoming ---
[u'const IPL_BORDER_REFLECT', u'2', [], [], '']
parseName: const IPL_BORDER_REFLECT with ['', 'cv'] -> fullname:IPL_BORDER_REFLECT namespace: classpath: classname: name:IPL_BORDER_REFLECT

--- Incoming ---
[u'const IPL_BORDER_WRAP', u'3', [], [], '']
parseName: const IPL_BORDER_WRAP with ['', 'cv'] -> fullname:IPL_BORDER_WRAP namespace: classpath: classname: name:IPL_BORDER_WRAP

--- Incoming ---
[u'struct IplImage', '', [], [], '']
parseName: struct IplImage with ['', 'cv'] -> fullname:IplImage namespace: classpath: classname: name:IplImage
register class IplImage ([u'struct IplImage', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct IplROI', '', [], [], '']
parseName: struct IplROI with ['', 'cv'] -> fullname:IplROI namespace: classpath: classname: name:IplROI
register class IplROI ([u'struct IplROI', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct IplConvKernel', '', [], [], '']
parseName: struct IplConvKernel with ['', 'cv'] -> fullname:IplConvKernel namespace: classpath: classname: name:IplConvKernel
register class IplConvKernel ([u'struct IplConvKernel', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct IplConvKernelFP', '', [], [], '']
parseName: struct IplConvKernelFP with ['', 'cv'] -> fullname:IplConvKernelFP namespace: classpath: classname: name:IplConvKernelFP
register class IplConvKernelFP ([u'struct IplConvKernelFP', '', [], [], '']) [ignored]

--- Incoming ---
[u'const IPL_IMAGE_HEADER', u'1', [], [], '']
parseName: const IPL_IMAGE_HEADER with ['', 'cv'] -> fullname:IPL_IMAGE_HEADER namespace: classpath: classname: name:IPL_IMAGE_HEADER

--- Incoming ---
[u'const IPL_IMAGE_DATA', u'2', [], [], '']
parseName: const IPL_IMAGE_DATA with ['', 'cv'] -> fullname:IPL_IMAGE_DATA namespace: classpath: classname: name:IPL_IMAGE_DATA

--- Incoming ---
[u'const IPL_IMAGE_ROI', u'4', [], [], '']
parseName: const IPL_IMAGE_ROI with ['', 'cv'] -> fullname:IPL_IMAGE_ROI namespace: classpath: classname: name:IPL_IMAGE_ROI

--- Incoming ---
[u'const IPL_BORDER_REFLECT_101', u'4', [], [], '']
parseName: const IPL_BORDER_REFLECT_101 with ['', 'cv'] -> fullname:IPL_BORDER_REFLECT_101 namespace: classpath: classname: name:IPL_BORDER_REFLECT_101

--- Incoming ---
[u'const IPL_BORDER_TRANSPARENT', u'5', [], [], '']
parseName: const IPL_BORDER_TRANSPARENT with ['', 'cv'] -> fullname:IPL_BORDER_TRANSPARENT namespace: classpath: classname: name:IPL_BORDER_TRANSPARENT

--- Incoming ---
[u'const IPL_IMAGE_MAGIC_VAL', u'((int)sizeof(IplImage))', [], [], '']
parseName: const IPL_IMAGE_MAGIC_VAL with ['', 'cv'] -> fullname:IPL_IMAGE_MAGIC_VAL namespace: classpath: classname: name:IPL_IMAGE_MAGIC_VAL
ignored: CONST IPL_IMAGE_MAGIC_VAL=((int)sizeof(IplImage))

--- Incoming ---
[u'const CV_TYPE_NAME_IMAGE', u'"opencv-image"', [], [], '']
parseName: const CV_TYPE_NAME_IMAGE with ['', 'cv'] -> fullname:CV_TYPE_NAME_IMAGE namespace: classpath: classname: name:CV_TYPE_NAME_IMAGE
ignored: CONST CV_TYPE_NAME_IMAGE="opencv-image"

--- Incoming ---
[u'const IPL_DEPTH_64F', u'64', [], [], '']
parseName: const IPL_DEPTH_64F with ['', 'cv'] -> fullname:IPL_DEPTH_64F namespace: classpath: classname: name:IPL_DEPTH_64F

--- Incoming ---
[u'const CV_CN_MAX', u'512', [], [], '']
parseName: const CV_CN_MAX with ['', 'cv'] -> fullname:CV_CN_MAX namespace: classpath: classname: name:CV_CN_MAX

--- Incoming ---
[u'const CV_CN_SHIFT', u'3', [], [], '']
parseName: const CV_CN_SHIFT with ['', 'cv'] -> fullname:CV_CN_SHIFT namespace: classpath: classname: name:CV_CN_SHIFT

--- Incoming ---
[u'const CV_DEPTH_MAX', u'(1 << CV_CN_SHIFT)', [], [], '']
parseName: const CV_DEPTH_MAX with ['', 'cv'] -> fullname:CV_DEPTH_MAX namespace: classpath: classname: name:CV_DEPTH_MAX

--- Incoming ---
[u'const CV_8U', u'0', [], [], '']
parseName: const CV_8U with ['', 'cv'] -> fullname:CV_8U namespace: classpath: classname: name:CV_8U

--- Incoming ---
[u'const CV_8S', u'1', [], [], '']
parseName: const CV_8S with ['', 'cv'] -> fullname:CV_8S namespace: classpath: classname: name:CV_8S

--- Incoming ---
[u'const CV_16U', u'2', [], [], '']
parseName: const CV_16U with ['', 'cv'] -> fullname:CV_16U namespace: classpath: classname: name:CV_16U

--- Incoming ---
[u'const CV_16S', u'3', [], [], '']
parseName: const CV_16S with ['', 'cv'] -> fullname:CV_16S namespace: classpath: classname: name:CV_16S

--- Incoming ---
[u'const CV_32S', u'4', [], [], '']
parseName: const CV_32S with ['', 'cv'] -> fullname:CV_32S namespace: classpath: classname: name:CV_32S

--- Incoming ---
[u'const CV_32F', u'5', [], [], '']
parseName: const CV_32F with ['', 'cv'] -> fullname:CV_32F namespace: classpath: classname: name:CV_32F

--- Incoming ---
[u'const CV_64F', u'6', [], [], '']
parseName: const CV_64F with ['', 'cv'] -> fullname:CV_64F namespace: classpath: classname: name:CV_64F

--- Incoming ---
[u'const CV_USRTYPE1', u'7', [], [], '']
parseName: const CV_USRTYPE1 with ['', 'cv'] -> fullname:CV_USRTYPE1 namespace: classpath: classname: name:CV_USRTYPE1

--- Incoming ---
[u'const CV_MAT_DEPTH_MASK', u'(CV_DEPTH_MAX - 1)', [], [], '']
parseName: const CV_MAT_DEPTH_MASK with ['', 'cv'] -> fullname:CV_MAT_DEPTH_MASK namespace: classpath: classname: name:CV_MAT_DEPTH_MASK

--- Incoming ---
[u'const CV_MAKE_TYPE', u'CV_MAKETYPE', [], [], '']
parseName: const CV_MAKE_TYPE with ['', 'cv'] -> fullname:CV_MAKE_TYPE namespace: classpath: classname: name:CV_MAKE_TYPE
ignored: CONST CV_MAKE_TYPE=CV_MAKETYPE

--- Incoming ---
[u'const CV_8UC1', u'CV_MAKETYPE(CV_8U,1)', [], [], '']
parseName: const CV_8UC1 with ['', 'cv'] -> fullname:CV_8UC1 namespace: classpath: classname: name:CV_8UC1

--- Incoming ---
[u'const CV_8UC2', u'CV_MAKETYPE(CV_8U,2)', [], [], '']
parseName: const CV_8UC2 with ['', 'cv'] -> fullname:CV_8UC2 namespace: classpath: classname: name:CV_8UC2

--- Incoming ---
[u'const CV_8UC3', u'CV_MAKETYPE(CV_8U,3)', [], [], '']
parseName: const CV_8UC3 with ['', 'cv'] -> fullname:CV_8UC3 namespace: classpath: classname: name:CV_8UC3

--- Incoming ---
[u'const CV_8UC4', u'CV_MAKETYPE(CV_8U,4)', [], [], '']
parseName: const CV_8UC4 with ['', 'cv'] -> fullname:CV_8UC4 namespace: classpath: classname: name:CV_8UC4

--- Incoming ---
[u'const CV_8SC1', u'CV_MAKETYPE(CV_8S,1)', [], [], '']
parseName: const CV_8SC1 with ['', 'cv'] -> fullname:CV_8SC1 namespace: classpath: classname: name:CV_8SC1

--- Incoming ---
[u'const CV_8SC2', u'CV_MAKETYPE(CV_8S,2)', [], [], '']
parseName: const CV_8SC2 with ['', 'cv'] -> fullname:CV_8SC2 namespace: classpath: classname: name:CV_8SC2

--- Incoming ---
[u'const CV_8SC3', u'CV_MAKETYPE(CV_8S,3)', [], [], '']
parseName: const CV_8SC3 with ['', 'cv'] -> fullname:CV_8SC3 namespace: classpath: classname: name:CV_8SC3

--- Incoming ---
[u'const CV_8SC4', u'CV_MAKETYPE(CV_8S,4)', [], [], '']
parseName: const CV_8SC4 with ['', 'cv'] -> fullname:CV_8SC4 namespace: classpath: classname: name:CV_8SC4

--- Incoming ---
[u'const CV_16UC1', u'CV_MAKETYPE(CV_16U,1)', [], [], '']
parseName: const CV_16UC1 with ['', 'cv'] -> fullname:CV_16UC1 namespace: classpath: classname: name:CV_16UC1

--- Incoming ---
[u'const CV_16UC2', u'CV_MAKETYPE(CV_16U,2)', [], [], '']
parseName: const CV_16UC2 with ['', 'cv'] -> fullname:CV_16UC2 namespace: classpath: classname: name:CV_16UC2

--- Incoming ---
[u'const CV_16UC3', u'CV_MAKETYPE(CV_16U,3)', [], [], '']
parseName: const CV_16UC3 with ['', 'cv'] -> fullname:CV_16UC3 namespace: classpath: classname: name:CV_16UC3

--- Incoming ---
[u'const CV_16UC4', u'CV_MAKETYPE(CV_16U,4)', [], [], '']
parseName: const CV_16UC4 with ['', 'cv'] -> fullname:CV_16UC4 namespace: classpath: classname: name:CV_16UC4

--- Incoming ---
[u'const CV_16SC1', u'CV_MAKETYPE(CV_16S,1)', [], [], '']
parseName: const CV_16SC1 with ['', 'cv'] -> fullname:CV_16SC1 namespace: classpath: classname: name:CV_16SC1

--- Incoming ---
[u'const CV_16SC2', u'CV_MAKETYPE(CV_16S,2)', [], [], '']
parseName: const CV_16SC2 with ['', 'cv'] -> fullname:CV_16SC2 namespace: classpath: classname: name:CV_16SC2

--- Incoming ---
[u'const CV_16SC3', u'CV_MAKETYPE(CV_16S,3)', [], [], '']
parseName: const CV_16SC3 with ['', 'cv'] -> fullname:CV_16SC3 namespace: classpath: classname: name:CV_16SC3

--- Incoming ---
[u'const CV_16SC4', u'CV_MAKETYPE(CV_16S,4)', [], [], '']
parseName: const CV_16SC4 with ['', 'cv'] -> fullname:CV_16SC4 namespace: classpath: classname: name:CV_16SC4

--- Incoming ---
[u'const CV_32SC1', u'CV_MAKETYPE(CV_32S,1)', [], [], '']
parseName: const CV_32SC1 with ['', 'cv'] -> fullname:CV_32SC1 namespace: classpath: classname: name:CV_32SC1

--- Incoming ---
[u'const CV_32SC2', u'CV_MAKETYPE(CV_32S,2)', [], [], '']
parseName: const CV_32SC2 with ['', 'cv'] -> fullname:CV_32SC2 namespace: classpath: classname: name:CV_32SC2

--- Incoming ---
[u'const CV_32SC3', u'CV_MAKETYPE(CV_32S,3)', [], [], '']
parseName: const CV_32SC3 with ['', 'cv'] -> fullname:CV_32SC3 namespace: classpath: classname: name:CV_32SC3

--- Incoming ---
[u'const CV_32SC4', u'CV_MAKETYPE(CV_32S,4)', [], [], '']
parseName: const CV_32SC4 with ['', 'cv'] -> fullname:CV_32SC4 namespace: classpath: classname: name:CV_32SC4

--- Incoming ---
[u'const CV_32FC1', u'CV_MAKETYPE(CV_32F,1)', [], [], '']
parseName: const CV_32FC1 with ['', 'cv'] -> fullname:CV_32FC1 namespace: classpath: classname: name:CV_32FC1

--- Incoming ---
[u'const CV_32FC2', u'CV_MAKETYPE(CV_32F,2)', [], [], '']
parseName: const CV_32FC2 with ['', 'cv'] -> fullname:CV_32FC2 namespace: classpath: classname: name:CV_32FC2

--- Incoming ---
[u'const CV_32FC3', u'CV_MAKETYPE(CV_32F,3)', [], [], '']
parseName: const CV_32FC3 with ['', 'cv'] -> fullname:CV_32FC3 namespace: classpath: classname: name:CV_32FC3

--- Incoming ---
[u'const CV_32FC4', u'CV_MAKETYPE(CV_32F,4)', [], [], '']
parseName: const CV_32FC4 with ['', 'cv'] -> fullname:CV_32FC4 namespace: classpath: classname: name:CV_32FC4

--- Incoming ---
[u'const CV_64FC1', u'CV_MAKETYPE(CV_64F,1)', [], [], '']
parseName: const CV_64FC1 with ['', 'cv'] -> fullname:CV_64FC1 namespace: classpath: classname: name:CV_64FC1

--- Incoming ---
[u'const CV_64FC2', u'CV_MAKETYPE(CV_64F,2)', [], [], '']
parseName: const CV_64FC2 with ['', 'cv'] -> fullname:CV_64FC2 namespace: classpath: classname: name:CV_64FC2

--- Incoming ---
[u'const CV_64FC3', u'CV_MAKETYPE(CV_64F,3)', [], [], '']
parseName: const CV_64FC3 with ['', 'cv'] -> fullname:CV_64FC3 namespace: classpath: classname: name:CV_64FC3

--- Incoming ---
[u'const CV_64FC4', u'CV_MAKETYPE(CV_64F,4)', [], [], '']
parseName: const CV_64FC4 with ['', 'cv'] -> fullname:CV_64FC4 namespace: classpath: classname: name:CV_64FC4

--- Incoming ---
[u'const CV_AUTO_STEP', u'0x7fffffff', [], [], '']
parseName: const CV_AUTO_STEP with ['', 'cv'] -> fullname:CV_AUTO_STEP namespace: classpath: classname: name:CV_AUTO_STEP

--- Incoming ---
[u'const CV_WHOLE_ARR', u'cvSlice( 0, 0x3fffffff )', [], [], '']
parseName: const CV_WHOLE_ARR with ['', 'cv'] -> fullname:CV_WHOLE_ARR namespace: classpath: classname: name:CV_WHOLE_ARR
ignored: CONST CV_WHOLE_ARR=cvSlice( 0, 0x3fffffff )

--- Incoming ---
[u'const CV_MAT_CN_MASK', u'((CV_CN_MAX - 1) << CV_CN_SHIFT)', [], [], '']
parseName: const CV_MAT_CN_MASK with ['', 'cv'] -> fullname:CV_MAT_CN_MASK namespace: classpath: classname: name:CV_MAT_CN_MASK

--- Incoming ---
[u'const CV_MAT_TYPE_MASK', u'(CV_DEPTH_MAX*CV_CN_MAX - 1)', [], [], '']
parseName: const CV_MAT_TYPE_MASK with ['', 'cv'] -> fullname:CV_MAT_TYPE_MASK namespace: classpath: classname: name:CV_MAT_TYPE_MASK

--- Incoming ---
[u'const CV_MAT_CONT_FLAG_SHIFT', u'14', [], [], '']
parseName: const CV_MAT_CONT_FLAG_SHIFT with ['', 'cv'] -> fullname:CV_MAT_CONT_FLAG_SHIFT namespace: classpath: classname: name:CV_MAT_CONT_FLAG_SHIFT

--- Incoming ---
[u'const CV_MAT_CONT_FLAG', u'(1 << CV_MAT_CONT_FLAG_SHIFT)', [], [], '']
parseName: const CV_MAT_CONT_FLAG with ['', 'cv'] -> fullname:CV_MAT_CONT_FLAG namespace: classpath: classname: name:CV_MAT_CONT_FLAG

--- Incoming ---
[u'const CV_IS_CONT_MAT', u'CV_IS_MAT_CONT', [], [], '']
parseName: const CV_IS_CONT_MAT with ['', 'cv'] -> fullname:CV_IS_CONT_MAT namespace: classpath: classname: name:CV_IS_CONT_MAT
ignored: CONST CV_IS_CONT_MAT=CV_IS_MAT_CONT

--- Incoming ---
[u'const CV_SUBMAT_FLAG_SHIFT', u'15', [], [], '']
parseName: const CV_SUBMAT_FLAG_SHIFT with ['', 'cv'] -> fullname:CV_SUBMAT_FLAG_SHIFT namespace: classpath: classname: name:CV_SUBMAT_FLAG_SHIFT

--- Incoming ---
[u'const CV_SUBMAT_FLAG', u'(1 << CV_SUBMAT_FLAG_SHIFT)', [], [], '']
parseName: const CV_SUBMAT_FLAG with ['', 'cv'] -> fullname:CV_SUBMAT_FLAG namespace: classpath: classname: name:CV_SUBMAT_FLAG

--- Incoming ---
[u'const CV_MAGIC_MASK', u'0xFFFF0000', [], [], '']
parseName: const CV_MAGIC_MASK with ['', 'cv'] -> fullname:CV_MAGIC_MASK namespace: classpath: classname: name:CV_MAGIC_MASK

--- Incoming ---
[u'const CV_MAT_MAGIC_VAL', u'0x42420000', [], [], '']
parseName: const CV_MAT_MAGIC_VAL with ['', 'cv'] -> fullname:CV_MAT_MAGIC_VAL namespace: classpath: classname: name:CV_MAT_MAGIC_VAL

--- Incoming ---
[u'const CV_TYPE_NAME_MAT', u'"opencv-matrix"', [], [], '']
parseName: const CV_TYPE_NAME_MAT with ['', 'cv'] -> fullname:CV_TYPE_NAME_MAT namespace: classpath: classname: name:CV_TYPE_NAME_MAT

--- Incoming ---
[u'struct CvMat', '', [], [], '']
parseName: struct CvMat with ['', 'cv'] -> fullname:CvMat namespace: classpath: classname: name:CvMat
register class CvMat ([u'struct CvMat', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvMat',
    u'CvMat',
    ['/NW'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []],
        [u'void*', u'data', u'NULL', []]],
    '']
parseName: cvMat with ['', 'cv'] -> fullname:cvMat namespace: classpath: classname: name:cvMat
register (function) cvMat

--- Incoming ---
[   u'cvmGet',
    u'double',
    ['/NW'],
    [   [u'const CvMat*', u'mat', '', []],
        [u'int', u'row', '', []],
        [u'int', u'col', '', []]],
    '']
parseName: cvmGet with ['', 'cv'] -> fullname:cvmGet namespace: classpath: classname: name:cvmGet
register (function) cvmGet

--- Incoming ---
[   u'cvmSet',
    u'void',
    ['/NW'],
    [   [u'CvMat*', u'mat', '', []],
        [u'int', u'row', '', []],
        [u'int', u'col', '', []],
        [u'double', u'value', '', []]],
    '']
parseName: cvmSet with ['', 'cv'] -> fullname:cvmSet namespace: classpath: classname: name:cvmSet
register (function) cvmSet

--- Incoming ---
[u'cvIplDepth', u'int', ['/NW'], [[u'int', u'type', '', []]], '']
parseName: cvIplDepth with ['', 'cv'] -> fullname:cvIplDepth namespace: classpath: classname: name:cvIplDepth
register (function) cvIplDepth

--- Incoming ---
[u'const CV_MATND_MAGIC_VAL', u'0x42430000', [], [], '']
parseName: const CV_MATND_MAGIC_VAL with ['', 'cv'] -> fullname:CV_MATND_MAGIC_VAL namespace: classpath: classname: name:CV_MATND_MAGIC_VAL

--- Incoming ---
[u'const CV_TYPE_NAME_MATND', u'"opencv-nd-matrix"', [], [], '']
parseName: const CV_TYPE_NAME_MATND with ['', 'cv'] -> fullname:CV_TYPE_NAME_MATND namespace: classpath: classname: name:CV_TYPE_NAME_MATND

--- Incoming ---
[u'const CV_MAX_DIM', u'32', [], [], '']
parseName: const CV_MAX_DIM with ['', 'cv'] -> fullname:CV_MAX_DIM namespace: classpath: classname: name:CV_MAX_DIM

--- Incoming ---
[u'const CV_MAX_DIM_HEAP', u'1024', [], [], '']
parseName: const CV_MAX_DIM_HEAP with ['', 'cv'] -> fullname:CV_MAX_DIM_HEAP namespace: classpath: classname: name:CV_MAX_DIM_HEAP

--- Incoming ---
[u'struct CvMatND', '', [], [], '']
parseName: struct CvMatND with ['', 'cv'] -> fullname:CvMatND namespace: classpath: classname: name:CvMatND
register class CvMatND ([u'struct CvMatND', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_SPARSE_MAT_MAGIC_VAL', u'0x42440000', [], [], '']
parseName: const CV_SPARSE_MAT_MAGIC_VAL with ['', 'cv'] -> fullname:CV_SPARSE_MAT_MAGIC_VAL namespace: classpath: classname: name:CV_SPARSE_MAT_MAGIC_VAL

--- Incoming ---
[u'const CV_TYPE_NAME_SPARSE_MAT', u'"opencv-sparse-matrix"', [], [], '']
parseName: const CV_TYPE_NAME_SPARSE_MAT with ['', 'cv'] -> fullname:CV_TYPE_NAME_SPARSE_MAT namespace: classpath: classname: name:CV_TYPE_NAME_SPARSE_MAT

--- Incoming ---
[u'struct CvSparseMat', '', [], [], '']
parseName: struct CvSparseMat with ['', 'cv'] -> fullname:CvSparseMat namespace: classpath: classname: name:CvSparseMat
register class CvSparseMat ([u'struct CvSparseMat', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSparseNode', '', [], [], '']
parseName: struct CvSparseNode with ['', 'cv'] -> fullname:CvSparseNode namespace: classpath: classname: name:CvSparseNode
register class CvSparseNode ([u'struct CvSparseNode', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSparseMatIterator', '', [], [], '']
parseName: struct CvSparseMatIterator with ['', 'cv'] -> fullname:CvSparseMatIterator namespace: classpath: classname: name:CvSparseMatIterator
register class CvSparseMatIterator ([u'struct CvSparseMatIterator', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_HIST_MAGIC_VAL', u'0x42450000', [], [], '']
parseName: const CV_HIST_MAGIC_VAL with ['', 'cv'] -> fullname:CV_HIST_MAGIC_VAL namespace: classpath: classname: name:CV_HIST_MAGIC_VAL

--- Incoming ---
[u'const CV_HIST_UNIFORM_FLAG', u'(1 << 10)', [], [], '']
parseName: const CV_HIST_UNIFORM_FLAG with ['', 'cv'] -> fullname:CV_HIST_UNIFORM_FLAG namespace: classpath: classname: name:CV_HIST_UNIFORM_FLAG

--- Incoming ---
[u'const CV_HIST_RANGES_FLAG', u'(1 << 11)', [], [], '']
parseName: const CV_HIST_RANGES_FLAG with ['', 'cv'] -> fullname:CV_HIST_RANGES_FLAG namespace: classpath: classname: name:CV_HIST_RANGES_FLAG

--- Incoming ---
[u'const CV_HIST_ARRAY', u'0', [], [], '']
parseName: const CV_HIST_ARRAY with ['', 'cv'] -> fullname:CV_HIST_ARRAY namespace: classpath: classname: name:CV_HIST_ARRAY

--- Incoming ---
[u'const CV_HIST_SPARSE', u'1', [], [], '']
parseName: const CV_HIST_SPARSE with ['', 'cv'] -> fullname:CV_HIST_SPARSE namespace: classpath: classname: name:CV_HIST_SPARSE

--- Incoming ---
[u'const CV_HIST_TREE', u'CV_HIST_SPARSE', [], [], '']
parseName: const CV_HIST_TREE with ['', 'cv'] -> fullname:CV_HIST_TREE namespace: classpath: classname: name:CV_HIST_TREE

--- Incoming ---
[u'const CV_HIST_UNIFORM', u'1', [], [], '']
parseName: const CV_HIST_UNIFORM with ['', 'cv'] -> fullname:CV_HIST_UNIFORM namespace: classpath: classname: name:CV_HIST_UNIFORM

--- Incoming ---
[u'struct CvHistogram', '', [], [], '']
parseName: struct CvHistogram with ['', 'cv'] -> fullname:CvHistogram namespace: classpath: classname: name:CvHistogram
register class CvHistogram ([u'struct CvHistogram', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvRect', '', [], [], '']
parseName: struct CvRect with ['', 'cv'] -> fullname:CvRect namespace: classpath: classname: name:CvRect
register class CvRect ([u'struct CvRect', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvRect',
    u'CvRect',
    ['/NW'],
    [   [u'int', u'x', '', []],
        [u'int', u'y', '', []],
        [u'int', u'width', '', []],
        [u'int', u'height', '', []]],
    '']
parseName: cvRect with ['', 'cv'] -> fullname:cvRect namespace: classpath: classname: name:cvRect
register (function) cvRect

--- Incoming ---
[   u'cvRectToROI',
    u'IplROI',
    ['/NW'],
    [[u'CvRect', u'rect', '', []], [u'int', u'coi', '', []]],
    '']
parseName: cvRectToROI with ['', 'cv'] -> fullname:cvRectToROI namespace: classpath: classname: name:cvRectToROI
register (function) cvRectToROI

--- Incoming ---
[u'cvROIToRect', u'CvRect', ['/NW'], [[u'IplROI', u'roi', '', []]], '']
parseName: cvROIToRect with ['', 'cv'] -> fullname:cvROIToRect namespace: classpath: classname: name:cvROIToRect
register (function) cvROIToRect

--- Incoming ---
[u'const CV_TERMCRIT_ITER', u'1', [], [], '']
parseName: const CV_TERMCRIT_ITER with ['', 'cv'] -> fullname:CV_TERMCRIT_ITER namespace: classpath: classname: name:CV_TERMCRIT_ITER

--- Incoming ---
[u'const CV_TERMCRIT_NUMBER', u'CV_TERMCRIT_ITER', [], [], '']
parseName: const CV_TERMCRIT_NUMBER with ['', 'cv'] -> fullname:CV_TERMCRIT_NUMBER namespace: classpath: classname: name:CV_TERMCRIT_NUMBER

--- Incoming ---
[u'const CV_TERMCRIT_EPS', u'2', [], [], '']
parseName: const CV_TERMCRIT_EPS with ['', 'cv'] -> fullname:CV_TERMCRIT_EPS namespace: classpath: classname: name:CV_TERMCRIT_EPS

--- Incoming ---
[u'struct CvTermCriteria', '', [], [], '']
parseName: struct CvTermCriteria with ['', 'cv'] -> fullname:CvTermCriteria namespace: classpath: classname: name:CvTermCriteria
register class CvTermCriteria ([u'struct CvTermCriteria', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvTermCriteria',
    u'CvTermCriteria',
    ['/NW'],
    [   [u'int', u'type', '', []],
        [u'int', u'max_iter', '', []],
        [u'double', u'epsilon', '', []]],
    '']
parseName: cvTermCriteria with ['', 'cv'] -> fullname:cvTermCriteria namespace: classpath: classname: name:cvTermCriteria
register (function) cvTermCriteria

--- Incoming ---
[u'struct CvPoint', '', [], [], '']
parseName: struct CvPoint with ['', 'cv'] -> fullname:CvPoint namespace: classpath: classname: name:CvPoint
register class CvPoint ([u'struct CvPoint', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvPoint',
    u'CvPoint',
    ['/NW'],
    [[u'int', u'x', '', []], [u'int', u'y', '', []]],
    '']
parseName: cvPoint with ['', 'cv'] -> fullname:cvPoint namespace: classpath: classname: name:cvPoint
register (function) cvPoint

--- Incoming ---
[u'struct CvPoint2D32f', '', [], [], '']
parseName: struct CvPoint2D32f with ['', 'cv'] -> fullname:CvPoint2D32f namespace: classpath: classname: name:CvPoint2D32f
register class CvPoint2D32f ([u'struct CvPoint2D32f', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvPoint2D32f',
    u'CvPoint2D32f',
    ['/NW'],
    [[u'double', u'x', '', []], [u'double', u'y', '', []]],
    '']
parseName: cvPoint2D32f with ['', 'cv'] -> fullname:cvPoint2D32f namespace: classpath: classname: name:cvPoint2D32f
register (function) cvPoint2D32f

--- Incoming ---
[   u'cvPointTo32f',
    u'CvPoint2D32f',
    ['/NW'],
    [[u'CvPoint', u'point', '', []]],
    '']
parseName: cvPointTo32f with ['', 'cv'] -> fullname:cvPointTo32f namespace: classpath: classname: name:cvPointTo32f
register (function) cvPointTo32f

--- Incoming ---
[   u'cvPointFrom32f',
    u'CvPoint',
    ['/NW'],
    [[u'CvPoint2D32f', u'point', '', []]],
    '']
parseName: cvPointFrom32f with ['', 'cv'] -> fullname:cvPointFrom32f namespace: classpath: classname: name:cvPointFrom32f
register (function) cvPointFrom32f

--- Incoming ---
[u'struct CvPoint3D32f', '', [], [], '']
parseName: struct CvPoint3D32f with ['', 'cv'] -> fullname:CvPoint3D32f namespace: classpath: classname: name:CvPoint3D32f
register class CvPoint3D32f ([u'struct CvPoint3D32f', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvPoint3D32f',
    u'CvPoint3D32f',
    ['/NW'],
    [   [u'double', u'x', '', []],
        [u'double', u'y', '', []],
        [u'double', u'z', '', []]],
    '']
parseName: cvPoint3D32f with ['', 'cv'] -> fullname:cvPoint3D32f namespace: classpath: classname: name:cvPoint3D32f
register (function) cvPoint3D32f

--- Incoming ---
[u'struct CvPoint2D64f', '', [], [], '']
parseName: struct CvPoint2D64f with ['', 'cv'] -> fullname:CvPoint2D64f namespace: classpath: classname: name:CvPoint2D64f
register class CvPoint2D64f ([u'struct CvPoint2D64f', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvPoint2D64f',
    u'CvPoint2D64f',
    ['/NW'],
    [[u'double', u'x', '', []], [u'double', u'y', '', []]],
    '']
parseName: cvPoint2D64f with ['', 'cv'] -> fullname:cvPoint2D64f namespace: classpath: classname: name:cvPoint2D64f
register (function) cvPoint2D64f

--- Incoming ---
[u'struct CvPoint3D64f', '', [], [], '']
parseName: struct CvPoint3D64f with ['', 'cv'] -> fullname:CvPoint3D64f namespace: classpath: classname: name:CvPoint3D64f
register class CvPoint3D64f ([u'struct CvPoint3D64f', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvPoint3D64f',
    u'CvPoint3D64f',
    ['/NW'],
    [   [u'double', u'x', '', []],
        [u'double', u'y', '', []],
        [u'double', u'z', '', []]],
    '']
parseName: cvPoint3D64f with ['', 'cv'] -> fullname:cvPoint3D64f namespace: classpath: classname: name:cvPoint3D64f
register (function) cvPoint3D64f

--- Incoming ---
[u'struct CvSize', '', [], [], '']
parseName: struct CvSize with ['', 'cv'] -> fullname:CvSize namespace: classpath: classname: name:CvSize
register class CvSize ([u'struct CvSize', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvSize',
    u'CvSize',
    ['/NW'],
    [[u'int', u'width', '', []], [u'int', u'height', '', []]],
    '']
parseName: cvSize with ['', 'cv'] -> fullname:cvSize namespace: classpath: classname: name:cvSize
register (function) cvSize

--- Incoming ---
[u'struct CvSize2D32f', '', [], [], '']
parseName: struct CvSize2D32f with ['', 'cv'] -> fullname:CvSize2D32f namespace: classpath: classname: name:CvSize2D32f
register class CvSize2D32f ([u'struct CvSize2D32f', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvSize2D32f',
    u'CvSize2D32f',
    ['/NW'],
    [[u'double', u'width', '', []], [u'double', u'height', '', []]],
    '']
parseName: cvSize2D32f with ['', 'cv'] -> fullname:cvSize2D32f namespace: classpath: classname: name:cvSize2D32f
register (function) cvSize2D32f

--- Incoming ---
[u'struct CvBox2D', '', [], [], '']
parseName: struct CvBox2D with ['', 'cv'] -> fullname:CvBox2D namespace: classpath: classname: name:CvBox2D
register class CvBox2D ([u'struct CvBox2D', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvLineIterator', '', [], [], '']
parseName: struct CvLineIterator with ['', 'cv'] -> fullname:CvLineIterator namespace: classpath: classname: name:CvLineIterator
register class CvLineIterator ([u'struct CvLineIterator', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSlice', '', [], [], '']
parseName: struct CvSlice with ['', 'cv'] -> fullname:CvSlice namespace: classpath: classname: name:CvSlice
register class CvSlice ([u'struct CvSlice', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvSlice',
    u'CvSlice',
    ['/NW'],
    [[u'int', u'start', '', []], [u'int', u'end', '', []]],
    '']
parseName: cvSlice with ['', 'cv'] -> fullname:cvSlice namespace: classpath: classname: name:cvSlice
register (function) cvSlice

--- Incoming ---
[u'const CV_WHOLE_SEQ_END_INDEX', u'0x3fffffff', [], [], '']
parseName: const CV_WHOLE_SEQ_END_INDEX with ['', 'cv'] -> fullname:CV_WHOLE_SEQ_END_INDEX namespace: classpath: classname: name:CV_WHOLE_SEQ_END_INDEX
ignored: CONST CV_WHOLE_SEQ_END_INDEX=0x3fffffff

--- Incoming ---
[u'const CV_WHOLE_SEQ', u'cvSlice(0, CV_WHOLE_SEQ_END_INDEX)', [], [], '']
parseName: const CV_WHOLE_SEQ with ['', 'cv'] -> fullname:CV_WHOLE_SEQ namespace: classpath: classname: name:CV_WHOLE_SEQ
ignored: CONST CV_WHOLE_SEQ=cvSlice(0, CV_WHOLE_SEQ_END_INDEX)

--- Incoming ---
[u'struct CvScalar', '', [], [], '']
parseName: struct CvScalar with ['', 'cv'] -> fullname:CvScalar namespace: classpath: classname: name:CvScalar
register class CvScalar ([u'struct CvScalar', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvScalar',
    u'CvScalar',
    ['/NW'],
    [   [u'double', u'val0', '', []],
        [u'double', u'val1', u'0', []],
        [u'double', u'val2', u'0', []],
        [u'double', u'val3', u'0', []]],
    '']
parseName: cvScalar with ['', 'cv'] -> fullname:cvScalar namespace: classpath: classname: name:cvScalar
register (function) cvScalar

--- Incoming ---
[u'cvRealScalar', u'CvScalar', ['/NW'], [[u'double', u'val0', '', []]], '']
parseName: cvRealScalar with ['', 'cv'] -> fullname:cvRealScalar namespace: classpath: classname: name:cvRealScalar
register (function) cvRealScalar

--- Incoming ---
[u'cvScalarAll', u'CvScalar', ['/NW'], [[u'double', u'val0123', '', []]], '']
parseName: cvScalarAll with ['', 'cv'] -> fullname:cvScalarAll namespace: classpath: classname: name:cvScalarAll
register (function) cvScalarAll

--- Incoming ---
[u'struct CvMemBlock', '', [], [], '']
parseName: struct CvMemBlock with ['', 'cv'] -> fullname:CvMemBlock namespace: classpath: classname: name:CvMemBlock
register class CvMemBlock ([u'struct CvMemBlock', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_STORAGE_MAGIC_VAL', u'0x42890000', [], [], '']
parseName: const CV_STORAGE_MAGIC_VAL with ['', 'cv'] -> fullname:CV_STORAGE_MAGIC_VAL namespace: classpath: classname: name:CV_STORAGE_MAGIC_VAL

--- Incoming ---
[u'struct CvMemStorage', '', [], [], '']
parseName: struct CvMemStorage with ['', 'cv'] -> fullname:CvMemStorage namespace: classpath: classname: name:CvMemStorage
register class CvMemStorage ([u'struct CvMemStorage', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvMemStoragePos', '', [], [], '']
parseName: struct CvMemStoragePos with ['', 'cv'] -> fullname:CvMemStoragePos namespace: classpath: classname: name:CvMemStoragePos
register class CvMemStoragePos ([u'struct CvMemStoragePos', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSeqBlock', '', [], [], '']
parseName: struct CvSeqBlock with ['', 'cv'] -> fullname:CvSeqBlock namespace: classpath: classname: name:CvSeqBlock
register class CvSeqBlock ([u'struct CvSeqBlock', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSeq', '', [], [], '']
parseName: struct CvSeq with ['', 'cv'] -> fullname:CvSeq namespace: classpath: classname: name:CvSeq
register class CvSeq ([u'struct CvSeq', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_TYPE_NAME_SEQ', u'"opencv-sequence"', [], [], '']
parseName: const CV_TYPE_NAME_SEQ with ['', 'cv'] -> fullname:CV_TYPE_NAME_SEQ namespace: classpath: classname: name:CV_TYPE_NAME_SEQ

--- Incoming ---
[u'const CV_TYPE_NAME_SEQ_TREE', u'"opencv-sequence-tree"', [], [], '']
parseName: const CV_TYPE_NAME_SEQ_TREE with ['', 'cv'] -> fullname:CV_TYPE_NAME_SEQ_TREE namespace: classpath: classname: name:CV_TYPE_NAME_SEQ_TREE

--- Incoming ---
[u'struct CvSetElem', '', [], [], '']
parseName: struct CvSetElem with ['', 'cv'] -> fullname:CvSetElem namespace: classpath: classname: name:CvSetElem
register class CvSetElem ([u'struct CvSetElem', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSet', '', [], [], '']
parseName: struct CvSet with ['', 'cv'] -> fullname:CvSet namespace: classpath: classname: name:CvSet
register class CvSet ([u'struct CvSet', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_SET_ELEM_IDX_MASK', u'((1 << 26) - 1)', [], [], '']
parseName: const CV_SET_ELEM_IDX_MASK with ['', 'cv'] -> fullname:CV_SET_ELEM_IDX_MASK namespace: classpath: classname: name:CV_SET_ELEM_IDX_MASK

--- Incoming ---
[u'const CV_SET_ELEM_FREE_FLAG', u'(1 << (sizeof(int)*8-1))', [], [], '']
parseName: const CV_SET_ELEM_FREE_FLAG with ['', 'cv'] -> fullname:CV_SET_ELEM_FREE_FLAG namespace: classpath: classname: name:CV_SET_ELEM_FREE_FLAG
ignored: CONST CV_SET_ELEM_FREE_FLAG=(1 << (sizeof(int)*8-1))

--- Incoming ---
[u'struct CvGraphEdge', '', [], [], '']
parseName: struct CvGraphEdge with ['', 'cv'] -> fullname:CvGraphEdge namespace: classpath: classname: name:CvGraphEdge
register class CvGraphEdge ([u'struct CvGraphEdge', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvGraphVtx', '', [], [], '']
parseName: struct CvGraphVtx with ['', 'cv'] -> fullname:CvGraphVtx namespace: classpath: classname: name:CvGraphVtx
register class CvGraphVtx ([u'struct CvGraphVtx', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvGraphVtx2D', '', [], [], '']
parseName: struct CvGraphVtx2D with ['', 'cv'] -> fullname:CvGraphVtx2D namespace: classpath: classname: name:CvGraphVtx2D
register class CvGraphVtx2D ([u'struct CvGraphVtx2D', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvGraph', '', [], [], '']
parseName: struct CvGraph with ['', 'cv'] -> fullname:CvGraph namespace: classpath: classname: name:CvGraph
register class CvGraph ([u'struct CvGraph', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_TYPE_NAME_GRAPH', u'"opencv-graph"', [], [], '']
parseName: const CV_TYPE_NAME_GRAPH with ['', 'cv'] -> fullname:CV_TYPE_NAME_GRAPH namespace: classpath: classname: name:CV_TYPE_NAME_GRAPH

--- Incoming ---
[u'struct CvChain', '', [], [], '']
parseName: struct CvChain with ['', 'cv'] -> fullname:CvChain namespace: classpath: classname: name:CvChain
register class CvChain ([u'struct CvChain', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvContour', '', [], [], '']
parseName: struct CvContour with ['', 'cv'] -> fullname:CvContour namespace: classpath: classname: name:CvContour
register class CvContour ([u'struct CvContour', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_SEQ_MAGIC_VAL', u'0x42990000', [], [], '']
parseName: const CV_SEQ_MAGIC_VAL with ['', 'cv'] -> fullname:CV_SEQ_MAGIC_VAL namespace: classpath: classname: name:CV_SEQ_MAGIC_VAL

--- Incoming ---
[u'const CV_SET_MAGIC_VAL', u'0x42980000', [], [], '']
parseName: const CV_SET_MAGIC_VAL with ['', 'cv'] -> fullname:CV_SET_MAGIC_VAL namespace: classpath: classname: name:CV_SET_MAGIC_VAL

--- Incoming ---
[u'const CV_SEQ_ELTYPE_BITS', u'12', [], [], '']
parseName: const CV_SEQ_ELTYPE_BITS with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_BITS namespace: classpath: classname: name:CV_SEQ_ELTYPE_BITS

--- Incoming ---
[u'const CV_SEQ_ELTYPE_MASK', u'((1 << CV_SEQ_ELTYPE_BITS) - 1)', [], [], '']
parseName: const CV_SEQ_ELTYPE_MASK with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_MASK namespace: classpath: classname: name:CV_SEQ_ELTYPE_MASK

--- Incoming ---
[u'const CV_SEQ_ELTYPE_POINT', u'CV_32SC2  /* (x,y) */', [], [], '']
parseName: const CV_SEQ_ELTYPE_POINT with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_POINT namespace: classpath: classname: name:CV_SEQ_ELTYPE_POINT

--- Incoming ---
[   u'const CV_SEQ_ELTYPE_CODE',
    u'CV_8UC1   /* freeman code: 0..7 */',
    [],
    [],
    '']
parseName: const CV_SEQ_ELTYPE_CODE with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_CODE namespace: classpath: classname: name:CV_SEQ_ELTYPE_CODE

--- Incoming ---
[u'const CV_SEQ_ELTYPE_GENERIC', u'0', [], [], '']
parseName: const CV_SEQ_ELTYPE_GENERIC with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_GENERIC namespace: classpath: classname: name:CV_SEQ_ELTYPE_GENERIC

--- Incoming ---
[u'const CV_SEQ_ELTYPE_PTR', u'CV_USRTYPE1', [], [], '']
parseName: const CV_SEQ_ELTYPE_PTR with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_PTR namespace: classpath: classname: name:CV_SEQ_ELTYPE_PTR

--- Incoming ---
[u'const CV_SEQ_ELTYPE_PPOINT', u'CV_SEQ_ELTYPE_PTR  /* &(x,y) */', [], [], '']
parseName: const CV_SEQ_ELTYPE_PPOINT with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_PPOINT namespace: classpath: classname: name:CV_SEQ_ELTYPE_PPOINT

--- Incoming ---
[u'const CV_SEQ_ELTYPE_INDEX', u'CV_32SC1  /* #(x,y) */', [], [], '']
parseName: const CV_SEQ_ELTYPE_INDEX with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_INDEX namespace: classpath: classname: name:CV_SEQ_ELTYPE_INDEX

--- Incoming ---
[   u'const CV_SEQ_ELTYPE_GRAPH_EDGE',
    u'0  /* &next_o, &next_d, &vtx_o, &vtx_d */',
    [],
    [],
    '']
parseName: const CV_SEQ_ELTYPE_GRAPH_EDGE with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_GRAPH_EDGE namespace: classpath: classname: name:CV_SEQ_ELTYPE_GRAPH_EDGE

--- Incoming ---
[   u'const CV_SEQ_ELTYPE_GRAPH_VERTEX',
    u'0  /* first_edge, &(x,y) */',
    [],
    [],
    '']
parseName: const CV_SEQ_ELTYPE_GRAPH_VERTEX with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_GRAPH_VERTEX namespace: classpath: classname: name:CV_SEQ_ELTYPE_GRAPH_VERTEX

--- Incoming ---
[   u'const CV_SEQ_ELTYPE_TRIAN_ATR',
    u'0  /* vertex of the binary tree   */',
    [],
    [],
    '']
parseName: const CV_SEQ_ELTYPE_TRIAN_ATR with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_TRIAN_ATR namespace: classpath: classname: name:CV_SEQ_ELTYPE_TRIAN_ATR

--- Incoming ---
[   u'const CV_SEQ_ELTYPE_CONNECTED_COMP',
    u'0  /* connected component  */',
    [],
    [],
    '']
parseName: const CV_SEQ_ELTYPE_CONNECTED_COMP with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_CONNECTED_COMP namespace: classpath: classname: name:CV_SEQ_ELTYPE_CONNECTED_COMP

--- Incoming ---
[u'const CV_SEQ_ELTYPE_POINT3D', u'CV_32FC3  /* (x,y,z)  */', [], [], '']
parseName: const CV_SEQ_ELTYPE_POINT3D with ['', 'cv'] -> fullname:CV_SEQ_ELTYPE_POINT3D namespace: classpath: classname: name:CV_SEQ_ELTYPE_POINT3D

--- Incoming ---
[u'const CV_SEQ_KIND_BITS', u'2', [], [], '']
parseName: const CV_SEQ_KIND_BITS with ['', 'cv'] -> fullname:CV_SEQ_KIND_BITS namespace: classpath: classname: name:CV_SEQ_KIND_BITS

--- Incoming ---
[   u'const CV_SEQ_KIND_MASK',
    u'(((1 << CV_SEQ_KIND_BITS) - 1)<<CV_SEQ_ELTYPE_BITS)',
    [],
    [],
    '']
parseName: const CV_SEQ_KIND_MASK with ['', 'cv'] -> fullname:CV_SEQ_KIND_MASK namespace: classpath: classname: name:CV_SEQ_KIND_MASK

--- Incoming ---
[u'const CV_SEQ_KIND_GENERIC', u'(0 << CV_SEQ_ELTYPE_BITS)', [], [], '']
parseName: const CV_SEQ_KIND_GENERIC with ['', 'cv'] -> fullname:CV_SEQ_KIND_GENERIC namespace: classpath: classname: name:CV_SEQ_KIND_GENERIC

--- Incoming ---
[u'const CV_SEQ_KIND_CURVE', u'(1 << CV_SEQ_ELTYPE_BITS)', [], [], '']
parseName: const CV_SEQ_KIND_CURVE with ['', 'cv'] -> fullname:CV_SEQ_KIND_CURVE namespace: classpath: classname: name:CV_SEQ_KIND_CURVE

--- Incoming ---
[u'const CV_SEQ_KIND_BIN_TREE', u'(2 << CV_SEQ_ELTYPE_BITS)', [], [], '']
parseName: const CV_SEQ_KIND_BIN_TREE with ['', 'cv'] -> fullname:CV_SEQ_KIND_BIN_TREE namespace: classpath: classname: name:CV_SEQ_KIND_BIN_TREE

--- Incoming ---
[u'const CV_SEQ_KIND_GRAPH', u'(1 << CV_SEQ_ELTYPE_BITS)', [], [], '']
parseName: const CV_SEQ_KIND_GRAPH with ['', 'cv'] -> fullname:CV_SEQ_KIND_GRAPH namespace: classpath: classname: name:CV_SEQ_KIND_GRAPH

--- Incoming ---
[u'const CV_SEQ_KIND_SUBDIV2D', u'(2 << CV_SEQ_ELTYPE_BITS)', [], [], '']
parseName: const CV_SEQ_KIND_SUBDIV2D with ['', 'cv'] -> fullname:CV_SEQ_KIND_SUBDIV2D namespace: classpath: classname: name:CV_SEQ_KIND_SUBDIV2D

--- Incoming ---
[   u'const CV_SEQ_FLAG_SHIFT',
    u'(CV_SEQ_KIND_BITS + CV_SEQ_ELTYPE_BITS)',
    [],
    [],
    '']
parseName: const CV_SEQ_FLAG_SHIFT with ['', 'cv'] -> fullname:CV_SEQ_FLAG_SHIFT namespace: classpath: classname: name:CV_SEQ_FLAG_SHIFT

--- Incoming ---
[u'const CV_SEQ_FLAG_CLOSED', u'(1 << CV_SEQ_FLAG_SHIFT)', [], [], '']
parseName: const CV_SEQ_FLAG_CLOSED with ['', 'cv'] -> fullname:CV_SEQ_FLAG_CLOSED namespace: classpath: classname: name:CV_SEQ_FLAG_CLOSED

--- Incoming ---
[u'const CV_SEQ_FLAG_SIMPLE', u'(0 << CV_SEQ_FLAG_SHIFT)', [], [], '']
parseName: const CV_SEQ_FLAG_SIMPLE with ['', 'cv'] -> fullname:CV_SEQ_FLAG_SIMPLE namespace: classpath: classname: name:CV_SEQ_FLAG_SIMPLE

--- Incoming ---
[u'const CV_SEQ_FLAG_CONVEX', u'(0 << CV_SEQ_FLAG_SHIFT)', [], [], '']
parseName: const CV_SEQ_FLAG_CONVEX with ['', 'cv'] -> fullname:CV_SEQ_FLAG_CONVEX namespace: classpath: classname: name:CV_SEQ_FLAG_CONVEX

--- Incoming ---
[u'const CV_SEQ_FLAG_HOLE', u'(2 << CV_SEQ_FLAG_SHIFT)', [], [], '']
parseName: const CV_SEQ_FLAG_HOLE with ['', 'cv'] -> fullname:CV_SEQ_FLAG_HOLE namespace: classpath: classname: name:CV_SEQ_FLAG_HOLE

--- Incoming ---
[u'const CV_GRAPH_FLAG_ORIENTED', u'(1 << CV_SEQ_FLAG_SHIFT)', [], [], '']
parseName: const CV_GRAPH_FLAG_ORIENTED with ['', 'cv'] -> fullname:CV_GRAPH_FLAG_ORIENTED namespace: classpath: classname: name:CV_GRAPH_FLAG_ORIENTED

--- Incoming ---
[u'const CV_GRAPH', u'CV_SEQ_KIND_GRAPH', [], [], '']
parseName: const CV_GRAPH with ['', 'cv'] -> fullname:CV_GRAPH namespace: classpath: classname: name:CV_GRAPH

--- Incoming ---
[   u'const CV_ORIENTED_GRAPH',
    u'(CV_SEQ_KIND_GRAPH|CV_GRAPH_FLAG_ORIENTED)',
    [],
    [],
    '']
parseName: const CV_ORIENTED_GRAPH with ['', 'cv'] -> fullname:CV_ORIENTED_GRAPH namespace: classpath: classname: name:CV_ORIENTED_GRAPH

--- Incoming ---
[   u'const CV_SEQ_POINT_SET',
    u'(CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT)',
    [],
    [],
    '']
parseName: const CV_SEQ_POINT_SET with ['', 'cv'] -> fullname:CV_SEQ_POINT_SET namespace: classpath: classname: name:CV_SEQ_POINT_SET

--- Incoming ---
[   u'const CV_SEQ_POINT3D_SET',
    u'(CV_SEQ_KIND_GENERIC| CV_SEQ_ELTYPE_POINT3D)',
    [],
    [],
    '']
parseName: const CV_SEQ_POINT3D_SET with ['', 'cv'] -> fullname:CV_SEQ_POINT3D_SET namespace: classpath: classname: name:CV_SEQ_POINT3D_SET

--- Incoming ---
[   u'const CV_SEQ_POLYLINE',
    u'(CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_POINT)',
    [],
    [],
    '']
parseName: const CV_SEQ_POLYLINE with ['', 'cv'] -> fullname:CV_SEQ_POLYLINE namespace: classpath: classname: name:CV_SEQ_POLYLINE

--- Incoming ---
[   u'const CV_SEQ_POLYGON',
    u'(CV_SEQ_FLAG_CLOSED | CV_SEQ_POLYLINE )',
    [],
    [],
    '']
parseName: const CV_SEQ_POLYGON with ['', 'cv'] -> fullname:CV_SEQ_POLYGON namespace: classpath: classname: name:CV_SEQ_POLYGON

--- Incoming ---
[u'const CV_SEQ_CONTOUR', u'CV_SEQ_POLYGON', [], [], '']
parseName: const CV_SEQ_CONTOUR with ['', 'cv'] -> fullname:CV_SEQ_CONTOUR namespace: classpath: classname: name:CV_SEQ_CONTOUR

--- Incoming ---
[   u'const CV_SEQ_SIMPLE_POLYGON',
    u'(CV_SEQ_FLAG_SIMPLE | CV_SEQ_POLYGON  )',
    [],
    [],
    '']
parseName: const CV_SEQ_SIMPLE_POLYGON with ['', 'cv'] -> fullname:CV_SEQ_SIMPLE_POLYGON namespace: classpath: classname: name:CV_SEQ_SIMPLE_POLYGON

--- Incoming ---
[   u'const CV_SEQ_CHAIN',
    u'(CV_SEQ_KIND_CURVE  | CV_SEQ_ELTYPE_CODE)',
    [],
    [],
    '']
parseName: const CV_SEQ_CHAIN with ['', 'cv'] -> fullname:CV_SEQ_CHAIN namespace: classpath: classname: name:CV_SEQ_CHAIN

--- Incoming ---
[   u'const CV_SEQ_CHAIN_CONTOUR',
    u'(CV_SEQ_FLAG_CLOSED | CV_SEQ_CHAIN)',
    [],
    [],
    '']
parseName: const CV_SEQ_CHAIN_CONTOUR with ['', 'cv'] -> fullname:CV_SEQ_CHAIN_CONTOUR namespace: classpath: classname: name:CV_SEQ_CHAIN_CONTOUR

--- Incoming ---
[   u'const CV_SEQ_POLYGON_TREE',
    u'(CV_SEQ_KIND_BIN_TREE  | CV_SEQ_ELTYPE_TRIAN_ATR)',
    [],
    [],
    '']
parseName: const CV_SEQ_POLYGON_TREE with ['', 'cv'] -> fullname:CV_SEQ_POLYGON_TREE namespace: classpath: classname: name:CV_SEQ_POLYGON_TREE

--- Incoming ---
[   u'const CV_SEQ_CONNECTED_COMP',
    u'(CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_CONNECTED_COMP)',
    [],
    [],
    '']
parseName: const CV_SEQ_CONNECTED_COMP with ['', 'cv'] -> fullname:CV_SEQ_CONNECTED_COMP namespace: classpath: classname: name:CV_SEQ_CONNECTED_COMP

--- Incoming ---
[   u'const CV_SEQ_INDEX',
    u'(CV_SEQ_KIND_GENERIC  | CV_SEQ_ELTYPE_INDEX)',
    [],
    [],
    '']
parseName: const CV_SEQ_INDEX with ['', 'cv'] -> fullname:CV_SEQ_INDEX namespace: classpath: classname: name:CV_SEQ_INDEX

--- Incoming ---
[u'struct CvSeqWriter', '', [], [], '']
parseName: struct CvSeqWriter with ['', 'cv'] -> fullname:CvSeqWriter namespace: classpath: classname: name:CvSeqWriter
register class CvSeqWriter ([u'struct CvSeqWriter', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvSeqReader', '', [], [], '']
parseName: struct CvSeqReader with ['', 'cv'] -> fullname:CvSeqReader namespace: classpath: classname: name:CvSeqReader
register class CvSeqReader ([u'struct CvSeqReader', '', [], [], '']) [ignored]

--- Incoming ---
[u'const CV_STORAGE_READ', u'0', [], [], '']
parseName: const CV_STORAGE_READ with ['', 'cv'] -> fullname:CV_STORAGE_READ namespace: classpath: classname: name:CV_STORAGE_READ

--- Incoming ---
[u'const CV_STORAGE_WRITE', u'1', [], [], '']
parseName: const CV_STORAGE_WRITE with ['', 'cv'] -> fullname:CV_STORAGE_WRITE namespace: classpath: classname: name:CV_STORAGE_WRITE

--- Incoming ---
[u'const CV_STORAGE_WRITE_TEXT', u'CV_STORAGE_WRITE', [], [], '']
parseName: const CV_STORAGE_WRITE_TEXT with ['', 'cv'] -> fullname:CV_STORAGE_WRITE_TEXT namespace: classpath: classname: name:CV_STORAGE_WRITE_TEXT

--- Incoming ---
[u'const CV_STORAGE_WRITE_BINARY', u'CV_STORAGE_WRITE', [], [], '']
parseName: const CV_STORAGE_WRITE_BINARY with ['', 'cv'] -> fullname:CV_STORAGE_WRITE_BINARY namespace: classpath: classname: name:CV_STORAGE_WRITE_BINARY

--- Incoming ---
[u'const CV_STORAGE_APPEND', u'2', [], [], '']
parseName: const CV_STORAGE_APPEND with ['', 'cv'] -> fullname:CV_STORAGE_APPEND namespace: classpath: classname: name:CV_STORAGE_APPEND

--- Incoming ---
[u'const CV_STORAGE_MEMORY', u'4', [], [], '']
parseName: const CV_STORAGE_MEMORY with ['', 'cv'] -> fullname:CV_STORAGE_MEMORY namespace: classpath: classname: name:CV_STORAGE_MEMORY

--- Incoming ---
[u'const CV_STORAGE_FORMAT_MASK', u'(7<<3)', [], [], '']
parseName: const CV_STORAGE_FORMAT_MASK with ['', 'cv'] -> fullname:CV_STORAGE_FORMAT_MASK namespace: classpath: classname: name:CV_STORAGE_FORMAT_MASK

--- Incoming ---
[u'const CV_STORAGE_FORMAT_AUTO', u'0', [], [], '']
parseName: const CV_STORAGE_FORMAT_AUTO with ['', 'cv'] -> fullname:CV_STORAGE_FORMAT_AUTO namespace: classpath: classname: name:CV_STORAGE_FORMAT_AUTO

--- Incoming ---
[u'const CV_STORAGE_FORMAT_XML', u'8', [], [], '']
parseName: const CV_STORAGE_FORMAT_XML with ['', 'cv'] -> fullname:CV_STORAGE_FORMAT_XML namespace: classpath: classname: name:CV_STORAGE_FORMAT_XML

--- Incoming ---
[u'const CV_STORAGE_FORMAT_YAML', u'16', [], [], '']
parseName: const CV_STORAGE_FORMAT_YAML with ['', 'cv'] -> fullname:CV_STORAGE_FORMAT_YAML namespace: classpath: classname: name:CV_STORAGE_FORMAT_YAML

--- Incoming ---
[u'struct CvAttrList', '', [], [], '']
parseName: struct CvAttrList with ['', 'cv'] -> fullname:CvAttrList namespace: classpath: classname: name:CvAttrList
register class CvAttrList ([u'struct CvAttrList', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cvAttrList',
    u'CvAttrList',
    ['/NW'],
    [   [u'const char**', u'attr', u'NULL', []],
        [u'CvAttrList*', u'next', u'NULL', []]],
    '']
parseName: cvAttrList with ['', 'cv'] -> fullname:cvAttrList namespace: classpath: classname: name:cvAttrList
register (function) cvAttrList

--- Incoming ---
[u'const CV_NODE_NONE', u'0', [], [], '']
parseName: const CV_NODE_NONE with ['', 'cv'] -> fullname:CV_NODE_NONE namespace: classpath: classname: name:CV_NODE_NONE

--- Incoming ---
[u'const CV_NODE_INT', u'1', [], [], '']
parseName: const CV_NODE_INT with ['', 'cv'] -> fullname:CV_NODE_INT namespace: classpath: classname: name:CV_NODE_INT

--- Incoming ---
[u'const CV_NODE_INTEGER', u'CV_NODE_INT', [], [], '']
parseName: const CV_NODE_INTEGER with ['', 'cv'] -> fullname:CV_NODE_INTEGER namespace: classpath: classname: name:CV_NODE_INTEGER

--- Incoming ---
[u'const CV_NODE_REAL', u'2', [], [], '']
parseName: const CV_NODE_REAL with ['', 'cv'] -> fullname:CV_NODE_REAL namespace: classpath: classname: name:CV_NODE_REAL

--- Incoming ---
[u'const CV_NODE_FLOAT', u'CV_NODE_REAL', [], [], '']
parseName: const CV_NODE_FLOAT with ['', 'cv'] -> fullname:CV_NODE_FLOAT namespace: classpath: classname: name:CV_NODE_FLOAT

--- Incoming ---
[u'const CV_NODE_STR', u'3', [], [], '']
parseName: const CV_NODE_STR with ['', 'cv'] -> fullname:CV_NODE_STR namespace: classpath: classname: name:CV_NODE_STR

--- Incoming ---
[u'const CV_NODE_STRING', u'CV_NODE_STR', [], [], '']
parseName: const CV_NODE_STRING with ['', 'cv'] -> fullname:CV_NODE_STRING namespace: classpath: classname: name:CV_NODE_STRING

--- Incoming ---
[u'const CV_NODE_REF', u'4 /* not used */', [], [], '']
parseName: const CV_NODE_REF with ['', 'cv'] -> fullname:CV_NODE_REF namespace: classpath: classname: name:CV_NODE_REF

--- Incoming ---
[u'const CV_NODE_SEQ', u'5', [], [], '']
parseName: const CV_NODE_SEQ with ['', 'cv'] -> fullname:CV_NODE_SEQ namespace: classpath: classname: name:CV_NODE_SEQ

--- Incoming ---
[u'const CV_NODE_MAP', u'6', [], [], '']
parseName: const CV_NODE_MAP with ['', 'cv'] -> fullname:CV_NODE_MAP namespace: classpath: classname: name:CV_NODE_MAP

--- Incoming ---
[u'const CV_NODE_TYPE_MASK', u'7', [], [], '']
parseName: const CV_NODE_TYPE_MASK with ['', 'cv'] -> fullname:CV_NODE_TYPE_MASK namespace: classpath: classname: name:CV_NODE_TYPE_MASK

--- Incoming ---
[   u'const CV_NODE_FLOW',
    u'8 /* Used only for writing structures in YAML format. */',
    [],
    [],
    '']
parseName: const CV_NODE_FLOW with ['', 'cv'] -> fullname:CV_NODE_FLOW namespace: classpath: classname: name:CV_NODE_FLOW

--- Incoming ---
[u'const CV_NODE_USER', u'16', [], [], '']
parseName: const CV_NODE_USER with ['', 'cv'] -> fullname:CV_NODE_USER namespace: classpath: classname: name:CV_NODE_USER

--- Incoming ---
[u'const CV_NODE_EMPTY', u'32', [], [], '']
parseName: const CV_NODE_EMPTY with ['', 'cv'] -> fullname:CV_NODE_EMPTY namespace: classpath: classname: name:CV_NODE_EMPTY

--- Incoming ---
[u'const CV_NODE_NAMED', u'64', [], [], '']
parseName: const CV_NODE_NAMED with ['', 'cv'] -> fullname:CV_NODE_NAMED namespace: classpath: classname: name:CV_NODE_NAMED

--- Incoming ---
[u'const CV_NODE_SEQ_SIMPLE', u'256', [], [], '']
parseName: const CV_NODE_SEQ_SIMPLE with ['', 'cv'] -> fullname:CV_NODE_SEQ_SIMPLE namespace: classpath: classname: name:CV_NODE_SEQ_SIMPLE

--- Incoming ---
[u'struct CvString', '', [], [], '']
parseName: struct CvString with ['', 'cv'] -> fullname:CvString namespace: classpath: classname: name:CvString
register class CvString ([u'struct CvString', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvStringHashNode', '', [], [], '']
parseName: struct CvStringHashNode with ['', 'cv'] -> fullname:CvStringHashNode namespace: classpath: classname: name:CvStringHashNode
register class CvStringHashNode ([u'struct CvStringHashNode', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvFileNode', '', [], [], '']
parseName: struct CvFileNode with ['', 'cv'] -> fullname:CvFileNode namespace: classpath: classname: name:CvFileNode
register class CvFileNode ([u'struct CvFileNode', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvTypeInfo', '', [], [], '']
parseName: struct CvTypeInfo with ['', 'cv'] -> fullname:CvTypeInfo namespace: classpath: classname: name:CvTypeInfo
register class CvTypeInfo ([u'struct CvTypeInfo', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvPluginFuncInfo', '', [], [], '']
parseName: struct CvPluginFuncInfo with ['', 'cv'] -> fullname:CvPluginFuncInfo namespace: classpath: classname: name:CvPluginFuncInfo
register class CvPluginFuncInfo ([u'struct CvPluginFuncInfo', '', [], [], '']) [ignored]

--- Incoming ---
[u'struct CvModuleInfo', '', [], [], '']
parseName: struct CvModuleInfo with ['', 'cv'] -> fullname:CvModuleInfo namespace: classpath: classname: name:CvModuleInfo
register class CvModuleInfo ([u'struct CvModuleInfo', '', [], [], '']) [ignored]


===== Header: /usr/include/opencv2/core/core.hpp =====
Namespaces: set(['', u'cv.gpu', 'cv', u'cv.ogl'])

--- Incoming ---
[   u'cv.fromUtf16',
    u'string',
    ['/NW'],
    [[u'const WString&', u'str', '', []]],
    '']
parseName: cv.fromUtf16 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fromUtf16 namespace:cv classpath: classname: name:fromUtf16
Registering an unknown type: WString
register (function) fromUtf16

--- Incoming ---
[u'cv.toUtf16', u'WString', ['/NW'], [[u'const string&', u'str', '', []]], '']
parseName: cv.toUtf16 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::toUtf16 namespace:cv classpath: classname: name:toUtf16
Registering an unknown type: WString
register (function) toUtf16

--- Incoming ---
[   u'cv.format',
    u'string',
    ['/NW'],
    [[u'const char*', u'fmt', '', []], [u'...', u'', '', []]],
    '']
parseName: cv.format with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::format namespace:cv classpath: classname: name:format
Registering an unknown type: ..
register (function) format

--- Incoming ---
[   u'cv.tempfile',
    u'string',
    ['/NW'],
    [[u'const char*', u'suffix', u'0', []]],
    '']
parseName: cv.tempfile with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::tempfile namespace:cv classpath: classname: name:tempfile
register (function) tempfile

--- Incoming ---
[u'const cv.DECOMP_LU', u'0', [], []]
parseName: const cv.DECOMP_LU with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_LU namespace:cv classpath: classname: name:DECOMP_LU

--- Incoming ---
[u'const cv.DECOMP_SVD', u'1', [], []]
parseName: const cv.DECOMP_SVD with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_SVD namespace:cv classpath: classname: name:DECOMP_SVD

--- Incoming ---
[u'const cv.DECOMP_EIG', u'2', [], []]
parseName: const cv.DECOMP_EIG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_EIG namespace:cv classpath: classname: name:DECOMP_EIG

--- Incoming ---
[u'const cv.DECOMP_CHOLESKY', u'3', [], []]
parseName: const cv.DECOMP_CHOLESKY with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_CHOLESKY namespace:cv classpath: classname: name:DECOMP_CHOLESKY

--- Incoming ---
[u'const cv.DECOMP_QR', u'4', [], []]
parseName: const cv.DECOMP_QR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_QR namespace:cv classpath: classname: name:DECOMP_QR

--- Incoming ---
[u'const cv.DECOMP_NORMAL', u'16', [], []]
parseName: const cv.DECOMP_NORMAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DECOMP_NORMAL namespace:cv classpath: classname: name:DECOMP_NORMAL

--- Incoming ---
[u'const cv.NORM_INF', u'1', [], []]
parseName: const cv.NORM_INF with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_INF namespace:cv classpath: classname: name:NORM_INF

--- Incoming ---
[u'const cv.NORM_L1', u'2', [], []]
parseName: const cv.NORM_L1 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_L1 namespace:cv classpath: classname: name:NORM_L1

--- Incoming ---
[u'const cv.NORM_L2', u'4', [], []]
parseName: const cv.NORM_L2 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_L2 namespace:cv classpath: classname: name:NORM_L2

--- Incoming ---
[u'const cv.NORM_L2SQR', u'5', [], []]
parseName: const cv.NORM_L2SQR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_L2SQR namespace:cv classpath: classname: name:NORM_L2SQR

--- Incoming ---
[u'const cv.NORM_HAMMING', u'6', [], []]
parseName: const cv.NORM_HAMMING with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_HAMMING namespace:cv classpath: classname: name:NORM_HAMMING

--- Incoming ---
[u'const cv.NORM_HAMMING2', u'7', [], []]
parseName: const cv.NORM_HAMMING2 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_HAMMING2 namespace:cv classpath: classname: name:NORM_HAMMING2

--- Incoming ---
[u'const cv.NORM_TYPE_MASK', u'7', [], []]
parseName: const cv.NORM_TYPE_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_TYPE_MASK namespace:cv classpath: classname: name:NORM_TYPE_MASK

--- Incoming ---
[u'const cv.NORM_RELATIVE', u'8', [], []]
parseName: const cv.NORM_RELATIVE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_RELATIVE namespace:cv classpath: classname: name:NORM_RELATIVE

--- Incoming ---
[u'const cv.NORM_MINMAX', u'32', [], []]
parseName: const cv.NORM_MINMAX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NORM_MINMAX namespace:cv classpath: classname: name:NORM_MINMAX

--- Incoming ---
[u'const cv.CMP_EQ', u'0', [], []]
parseName: const cv.CMP_EQ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_EQ namespace:cv classpath: classname: name:CMP_EQ

--- Incoming ---
[u'const cv.CMP_GT', u'1', [], []]
parseName: const cv.CMP_GT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_GT namespace:cv classpath: classname: name:CMP_GT

--- Incoming ---
[u'const cv.CMP_GE', u'2', [], []]
parseName: const cv.CMP_GE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_GE namespace:cv classpath: classname: name:CMP_GE

--- Incoming ---
[u'const cv.CMP_LT', u'3', [], []]
parseName: const cv.CMP_LT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_LT namespace:cv classpath: classname: name:CMP_LT

--- Incoming ---
[u'const cv.CMP_LE', u'4', [], []]
parseName: const cv.CMP_LE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_LE namespace:cv classpath: classname: name:CMP_LE

--- Incoming ---
[u'const cv.CMP_NE', u'5', [], []]
parseName: const cv.CMP_NE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CMP_NE namespace:cv classpath: classname: name:CMP_NE

--- Incoming ---
[u'const cv.GEMM_1_T', u'1', [], []]
parseName: const cv.GEMM_1_T with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::GEMM_1_T namespace:cv classpath: classname: name:GEMM_1_T

--- Incoming ---
[u'const cv.GEMM_2_T', u'2', [], []]
parseName: const cv.GEMM_2_T with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::GEMM_2_T namespace:cv classpath: classname: name:GEMM_2_T

--- Incoming ---
[u'const cv.GEMM_3_T', u'4', [], []]
parseName: const cv.GEMM_3_T with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::GEMM_3_T namespace:cv classpath: classname: name:GEMM_3_T

--- Incoming ---
[u'const cv.DFT_INVERSE', u'1', [], []]
parseName: const cv.DFT_INVERSE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DFT_INVERSE namespace:cv classpath: classname: name:DFT_INVERSE

--- Incoming ---
[u'const cv.DFT_SCALE', u'2', [], []]
parseName: const cv.DFT_SCALE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DFT_SCALE namespace:cv classpath: classname: name:DFT_SCALE

--- Incoming ---
[u'const cv.DFT_ROWS', u'4', [], []]
parseName: const cv.DFT_ROWS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DFT_ROWS namespace:cv classpath: classname: name:DFT_ROWS

--- Incoming ---
[u'const cv.DFT_COMPLEX_OUTPUT', u'16', [], []]
parseName: const cv.DFT_COMPLEX_OUTPUT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DFT_COMPLEX_OUTPUT namespace:cv classpath: classname: name:DFT_COMPLEX_OUTPUT

--- Incoming ---
[u'const cv.DFT_REAL_OUTPUT', u'32', [], []]
parseName: const cv.DFT_REAL_OUTPUT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DFT_REAL_OUTPUT namespace:cv classpath: classname: name:DFT_REAL_OUTPUT

--- Incoming ---
[u'const cv.DCT_INVERSE', u'DFT_INVERSE', [], []]
parseName: const cv.DCT_INVERSE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DCT_INVERSE namespace:cv classpath: classname: name:DCT_INVERSE

--- Incoming ---
[u'const cv.DCT_ROWS', u'DFT_ROWS', [], []]
parseName: const cv.DCT_ROWS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DCT_ROWS namespace:cv classpath: classname: name:DCT_ROWS

--- Incoming ---
[   u'class cv.Exception',
    u': cv::std::exception',
    [],
    [],
    u'The standard OpenCV exception class.\nInstances of the class are thrown by various functions and methods in the case of critical errors.\n']
parseName: class cv.Exception with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception namespace:cv classpath: classname: name:Exception
register class cv::Exception ([u'class cv.Exception', u': cv::std::exception', [], [], u'The standard OpenCV exception class.\nInstances of the class are thrown by various functions and methods in the case of critical errors.\n']) [ignored] impl:cv::std::exception

--- Incoming ---
[u'cv.Exception.Exception', u'', ['/NW'], [], u'Default constructor\n']
parseName: cv.Exception.Exception with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception::Exception namespace:cv classpath:Exception classname:Exception name:Exception
register (constructor) new in cv::Exception

--- Incoming ---
[   u'cv.Exception.Exception',
    u'',
    ['/NW'],
    [   [u'int', u'_code', '', []],
        [u'const string&', u'_err', '', []],
        [u'const string&', u'_func', '', []],
        [u'const string&', u'_file', '', []],
        [u'int', u'_line', '', []]],
    u'Full constructor. Normally the constuctor is not called explicitly.\nInstead, the macros CV_Error(), CV_Error_() and CV_Assert() are used.\n']
parseName: cv.Exception.Exception with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception::Exception namespace:cv classpath:Exception classname:Exception name:Exception
register (constructor) new in cv::Exception

--- Incoming ---
[u'cv.Exception.~Exception', u'', ['/NW'], [[u') throw(', u'', '', []]], '']
parseName: cv.Exception.~Exception with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception::~Exception namespace:cv classpath:Exception classname:Exception name:~Exception
Registering an unknown type: ) throw(
ignore destructor (method) ~Exception in cv::Exception

--- Incoming ---
[   u'cv.Exception.what',
    u'const char',
    ['/NW', '/C'],
    [[u') const throw(', u'', '', []]],
    u'\\return the error description and the context as a text string.\n']
parseName: cv.Exception.what with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception::what namespace:cv classpath:Exception classname:Exception name:what
Registering an unknown type: ) throw(
register (method) what in cv::Exception

--- Incoming ---
[u'cv.Exception.formatMessage', u'void', ['/NW'], [], '']
parseName: cv.Exception.formatMessage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Exception::formatMessage namespace:cv classpath:Exception classname:Exception name:formatMessage
register (method) formatMessage in cv::Exception

--- Incoming ---
[   u'cv.error',
    u'void',
    ['/NW'],
    [[u'const Exception&', u'exc', '', []]],
    u'By default the function prints information about the error to stderr,\nthen it either stops if setBreakOnError() had been called before or raises the exception.\nIt is possible to alternate error processing by using redirectError().\n\n\\param exc the exception raisen.\n']
parseName: cv.error with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::error namespace:cv classpath: classname: name:error
register (function) error

--- Incoming ---
[   u'cv.setBreakOnError',
    u'bool',
    ['/NW'],
    [[u'bool', u'flag', '', []]],
    u'When the break-on-error mode is set, the default error handler\nissues a hardware exception, which can make debugging more convenient.\n\n\\return the previous state\n']
parseName: cv.setBreakOnError with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::setBreakOnError namespace:cv classpath: classname: name:setBreakOnError
register (function) setBreakOnError

--- Incoming ---
[   u'cv.redirectError',
    u'ErrorCallback',
    ['/NW'],
    [   [u'ErrorCallback', u'errCallback', '', []],
        [u'void*', u'userdata', u'0', []],
        [u'void**', u'prevUserdata', u'0', []]],
    u'The function sets the new error handler, called from cv::error().\n\n\\param errCallback the new error handler. If NULL, the default error handler is used.\n\\param userdata the optional user data pointer, passed to the callback.\n\\param prevUserdata the optional output parameter where the previous user data pointer is stored\n\n\\return the previous error handler\n']
parseName: cv.redirectError with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::redirectError namespace:cv classpath: classname: name:redirectError
Registering an unknown type: ErrorCallback
register (function) redirectError

--- Incoming ---
[   u'cv.glob',
    u'void',
    ['/NW'],
    [   [u'String', u'pattern', '', []],
        [u'std::vector<String>&', u'result', '', []],
        [u'bool', u'recursive', u'false', []]],
    '']
parseName: cv.glob with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::glob namespace:cv classpath: classname: name:glob
Registering an unknown type: String
Registering an unknown type: std::vector<String>
register (function) glob

--- Incoming ---
[u'cv.setNumThreads', u'void', ['/NW'], [[u'int', u'nthreads', '', []]], '']
parseName: cv.setNumThreads with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::setNumThreads namespace:cv classpath: classname: name:setNumThreads
register (function) setNumThreads

--- Incoming ---
[u'cv.getNumThreads', u'int', ['/NW'], [], '']
parseName: cv.getNumThreads with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getNumThreads namespace:cv classpath: classname: name:getNumThreads
register (function) getNumThreads

--- Incoming ---
[u'cv.getThreadNum', u'int', ['/NW'], [], '']
parseName: cv.getThreadNum with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getThreadNum namespace:cv classpath: classname: name:getThreadNum
register (function) getThreadNum

--- Incoming ---
[u'cv.getBuildInformation', u'const string&', ['/NW'], [], '']
parseName: cv.getBuildInformation with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getBuildInformation namespace:cv classpath: classname: name:getBuildInformation
register (function) getBuildInformation

--- Incoming ---
[   u'cv.getTickCount',
    u'int64',
    ['/NW'],
    [],
    u'The function returns the number of ticks since the certain event (e.g. when the machine was turned on).\nIt can be used to initialize cv::RNG or to measure a function execution time by reading the tick count\nbefore and after the function call. The granularity of ticks depends on the hardware and OS used. Use\ncv::getTickFrequency() to convert ticks to seconds.\n']
parseName: cv.getTickCount with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getTickCount namespace:cv classpath: classname: name:getTickCount
register (function) getTickCount

--- Incoming ---
[   u'cv.getTickFrequency',
    u'double',
    ['/NW'],
    [],
    u'Returns the number of ticks per seconds.\n\nThe function returns the number of ticks (as returned by cv::getTickCount()) per second.\nThe following code computes the execution time in milliseconds:\n\n\\code\ndouble exec_time = (double)getTickCount();\n// do something ...\nexec_time = ((double)getTickCount() - exec_time)*1000./getTickFrequency();\n\\endcode\n']
parseName: cv.getTickFrequency with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getTickFrequency namespace:cv classpath: classname: name:getTickFrequency
register (function) getTickFrequency

--- Incoming ---
[   u'cv.getCPUTickCount',
    u'int64',
    ['/NW'],
    [],
    u'Returns the number of CPU ticks.\n\nOn platforms where the feature is available, the function returns the number of CPU ticks\nsince the certain event (normally, the system power-on moment). Using this function\none can accurately measure the execution time of very small code fragments,\nfor which cv::getTickCount() granularity is not enough.\n']
parseName: cv.getCPUTickCount with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getCPUTickCount namespace:cv classpath: classname: name:getCPUTickCount
register (function) getCPUTickCount

--- Incoming ---
[   u'cv.checkHardwareSupport',
    u'bool',
    ['/NW'],
    [[u'int', u'feature', '', []]],
    u'Returns SSE etc. support status\n\nThe function returns true if certain hardware features are available.\nCurrently, the following features are recognized:\n- CV_CPU_MMX - MMX\n- CV_CPU_SSE - SSE\n- CV_CPU_SSE2 - SSE 2\n- CV_CPU_SSE3 - SSE 3\n- CV_CPU_SSSE3 - SSSE 3\n- CV_CPU_SSE4_1 - SSE 4.1\n- CV_CPU_SSE4_2 - SSE 4.2\n- CV_CPU_POPCNT - POPCOUNT\n- CV_CPU_AVX - AVX\n- CV_CPU_AVX2 - AVX2\n\n\\note {Note that the function output is not static. Once you called cv::useOptimized(false),\nmost of the hardware acceleration is disabled and thus the function will returns false,\nuntil you call cv::useOptimized(true)}\n']
parseName: cv.checkHardwareSupport with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::checkHardwareSupport namespace:cv classpath: classname: name:checkHardwareSupport
register (function) checkHardwareSupport

--- Incoming ---
[   u'cv.getNumberOfCPUs',
    u'int',
    ['/NW'],
    [],
    u'returns the number of CPUs (including hyper-threading)\n']
parseName: cv.getNumberOfCPUs with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getNumberOfCPUs namespace:cv classpath: classname: name:getNumberOfCPUs
register (function) getNumberOfCPUs

--- Incoming ---
[   u'cv.fastMalloc',
    u'void*',
    ['/NW'],
    [[u'size_t', u'bufSize', '', []]],
    u'Allocates memory buffer\n\nThis is specialized OpenCV memory allocation function that returns properly aligned memory buffers.\nThe usage is identical to malloc(). The allocated buffers must be freed with cv::fastFree().\nIf there is not enough memory, the function calls cv::error(), which raises an exception.\n\n\\param bufSize buffer size in bytes\n\\return the allocated memory buffer.\n']
parseName: cv.fastMalloc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fastMalloc namespace:cv classpath: classname: name:fastMalloc
register (function) fastMalloc

--- Incoming ---
[   u'cv.fastFree',
    u'void',
    ['/NW'],
    [[u'void*', u'ptr', '', []]],
    u'Frees the memory allocated with cv::fastMalloc\n\nThis is the corresponding deallocation function for cv::fastMalloc().\nWhen ptr==NULL, the function has no effect.\n']
parseName: cv.fastFree with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fastFree namespace:cv classpath: classname: name:fastFree
register (function) fastFree

--- Incoming ---
[   u'cv.alignSize',
    u'size_t',
    ['/NW'],
    [[u'size_t', u'sz', '', []], [u'int', u'n', '', []]],
    u'Aligns buffer size by the certain number of bytes\n\nThis small inline function aligns a buffer size by the certian number of bytes by enlarging it.\n']
parseName: cv.alignSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::alignSize namespace:cv classpath: classname: name:alignSize
register (function) alignSize

--- Incoming ---
[   u'cv.setUseOptimized',
    u'void',
    ['/NW'],
    [[u'bool', u'onoff', '', []]],
    u'Turns on/off available optimization\n\nThe function turns on or off the optimized code in OpenCV. Some optimization can not be enabled\nor disabled, but, for example, most of SSE code in OpenCV can be temporarily turned on or off this way.\n\n\\note{Since optimization may imply using special data structures, it may be unsafe\nto call this function anywhere in the code. Instead, call it somewhere at the top level.}\n']
parseName: cv.setUseOptimized with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::setUseOptimized namespace:cv classpath: classname: name:setUseOptimized
register (function) setUseOptimized

--- Incoming ---
[   u'cv.useOptimized',
    u'bool',
    ['/NW'],
    [],
    u'Returns the current optimization status\n\nThe function returns the current optimization status, which is controlled by cv::setUseOptimized().\n']
parseName: cv.useOptimized with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::useOptimized namespace:cv classpath: classname: name:useOptimized
register (function) useOptimized

--- Incoming ---
[   u'struct cv.Matx_AddOp',
    '',
    [],
    [],
    u'A short numerical vector.\n\nThis template class represents short numerical vectors (of 1, 2, 3, 4 ... elements)\non which you can perform basic arithmetical operations, access individual elements using [] operator etc.\nThe vectors are allocated on stack, as opposite to std::valarray, std::vector, cv::Mat etc.,\nwhich elements are dynamically allocated in the heap.\n\nThe template takes 2 parameters:\n-# _Tp element type\n-# cn the number of elements\n\nIn addition to the universal notation like Vec<float, 3>, you can use shorter aliases\nfor the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.\n']
parseName: struct cv.Matx_AddOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_AddOp namespace:cv classpath: classname: name:Matx_AddOp
register class cv::Matx_AddOp ([u'struct cv.Matx_AddOp', '', [], [], u'A short numerical vector.\n\nThis template class represents short numerical vectors (of 1, 2, 3, 4 ... elements)\non which you can perform basic arithmetical operations, access individual elements using [] operator etc.\nThe vectors are allocated on stack, as opposite to std::valarray, std::vector, cv::Mat etc.,\nwhich elements are dynamically allocated in the heap.\n\nThe template takes 2 parameters:\n-# _Tp element type\n-# cn the number of elements\n\nIn addition to the universal notation like Vec<float, 3>, you can use shorter aliases\nfor the most popular specialized variants of Vec, e.g. Vec3f ~ Vec<float, 3>.\n'])

--- Incoming ---
[u'struct cv.Matx_SubOp', '', [], [], '']
parseName: struct cv.Matx_SubOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_SubOp namespace:cv classpath: classname: name:Matx_SubOp
register class cv::Matx_SubOp ([u'struct cv.Matx_SubOp', '', [], [], ''])

--- Incoming ---
[u'struct cv.Matx_ScaleOp', '', [], [], '']
parseName: struct cv.Matx_ScaleOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_ScaleOp namespace:cv classpath: classname: name:Matx_ScaleOp
register class cv::Matx_ScaleOp ([u'struct cv.Matx_ScaleOp', '', [], [], ''])

--- Incoming ---
[u'struct cv.Matx_MulOp', '', [], [], '']
parseName: struct cv.Matx_MulOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_MulOp namespace:cv classpath: classname: name:Matx_MulOp
register class cv::Matx_MulOp ([u'struct cv.Matx_MulOp', '', [], [], ''])

--- Incoming ---
[u'struct cv.Matx_MatMulOp', '', [], [], '']
parseName: struct cv.Matx_MatMulOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_MatMulOp namespace:cv classpath: classname: name:Matx_MatMulOp
register class cv::Matx_MatMulOp ([u'struct cv.Matx_MatMulOp', '', [], [], ''])

--- Incoming ---
[u'struct cv.Matx_TOp', '', [], [], '']
parseName: struct cv.Matx_TOp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Matx_TOp namespace:cv classpath: classname: name:Matx_TOp
register class cv::Matx_TOp ([u'struct cv.Matx_TOp', '', [], [], ''])

--- Incoming ---
[   u'class cv.RotatedRect',
    '',
    [],
    [],
    u'The rotated 2D rectangle.\n\nThe class represents rotated (i.e. not up-right) rectangles on a plane.\nEach rectangle is described by the center point (mass center), length of each side\n(represented by cv::Size2f structure) and the rotation angle in degrees.\n']
parseName: class cv.RotatedRect with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect namespace:cv classpath: classname: name:RotatedRect
register class cv::RotatedRect ([u'class cv.RotatedRect', '', [], [], u'The rotated 2D rectangle.\n\nThe class represents rotated (i.e. not up-right) rectangles on a plane.\nEach rectangle is described by the center point (mass center), length of each side\n(represented by cv::Size2f structure) and the rotation angle in degrees.\n'])

--- Incoming ---
[u'cv.RotatedRect.RotatedRect', u'', ['/NW'], [], u'various constructors\n']
parseName: cv.RotatedRect.RotatedRect with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::RotatedRect namespace:cv classpath:RotatedRect classname:RotatedRect name:RotatedRect
register (constructor) new in cv::RotatedRect

--- Incoming ---
[   u'cv.RotatedRect.RotatedRect',
    u'',
    ['/NW'],
    [   [u'const Point2f&', u'center', '', []],
        [u'const Size2f&', u'size', '', []],
        [u'float', u'angle', '', []]],
    '']
parseName: cv.RotatedRect.RotatedRect with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::RotatedRect namespace:cv classpath:RotatedRect classname:RotatedRect name:RotatedRect
register (constructor) new in cv::RotatedRect

--- Incoming ---
[   u'cv.RotatedRect.RotatedRect',
    u'',
    ['/NW'],
    [[u'const CvBox2D&', u'box', '', []]],
    '']
parseName: cv.RotatedRect.RotatedRect with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::RotatedRect namespace:cv classpath:RotatedRect classname:RotatedRect name:RotatedRect
register (constructor) new in cv::RotatedRect

--- Incoming ---
[   u'cv.RotatedRect.points',
    u'void',
    ['/NW', '/C'],
    [[u'Point2f[]', u'pts', '', []]],
    u'returns 4 vertices of the rectangle\n']
parseName: cv.RotatedRect.points with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::points namespace:cv classpath:RotatedRect classname:RotatedRect name:points
Registering an unknown type: Point2f[]
register (method) points in cv::RotatedRect

--- Incoming ---
[   u'cv.RotatedRect.boundingRect',
    u'Rect',
    ['/NW', '/C'],
    [],
    u'returns the minimal up-right rectangle containing the rotated rectangle\n']
parseName: cv.RotatedRect.boundingRect with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::boundingRect namespace:cv classpath:RotatedRect classname:RotatedRect name:boundingRect
register (method) boundingRect in cv::RotatedRect

--- Incoming ---
[   u'cv.RotatedRect.operator CvBox2D',
    u'',
    ['/NW', '/C'],
    [],
    u'conversion to the old-style CvBox2D structure\n']
parseName: cv.RotatedRect.operator CvBox2D with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RotatedRect::operator CvBox2D namespace:cv classpath:RotatedRect classname:RotatedRect name:operator CvBox2D
ignore (method) operator CvBox2D in cv::RotatedRect

--- Incoming ---
[   u'cv.scalarToRawData',
    u'void',
    ['/NW'],
    [   [u'const Scalar&', u's', '', []],
        [u'void*', u'buf', '', []],
        [u'int', u'type', '', []],
        [u'int', u'unroll_to', u'0', []]],
    '']
parseName: cv.scalarToRawData with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::scalarToRawData namespace:cv classpath: classname: name:scalarToRawData
register (function) scalarToRawData

--- Incoming ---
[   u'class cv.Range',
    '',
    [],
    [],
    u'The 2D range class\n\nThis is the class used to specify a continuous subsequence, i.e. part of a contour, or a column span in a matrix.\n']
parseName: class cv.Range with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range namespace:cv classpath: classname: name:Range
register class cv::Range ([u'class cv.Range', '', [], [], u'The 2D range class\n\nThis is the class used to specify a continuous subsequence, i.e. part of a contour, or a column span in a matrix.\n'])

--- Incoming ---
[u'cv.Range.Range', u'', ['/NW'], [], '']
parseName: cv.Range.Range with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::Range namespace:cv classpath:Range classname:Range name:Range
register (constructor) new in cv::Range

--- Incoming ---
[   u'cv.Range.Range',
    u'',
    ['/NW'],
    [[u'int', u'_start', '', []], [u'int', u'_end', '', []]],
    '']
parseName: cv.Range.Range with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::Range namespace:cv classpath:Range classname:Range name:Range
register (constructor) new in cv::Range

--- Incoming ---
[u'cv.Range.Range', u'', ['/NW'], [[u'const CvSlice&', u'slice', '', []]], '']
parseName: cv.Range.Range with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::Range namespace:cv classpath:Range classname:Range name:Range
register (constructor) new in cv::Range

--- Incoming ---
[u'cv.Range.size', u'int', ['/NW', '/C'], [], '']
parseName: cv.Range.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::size namespace:cv classpath:Range classname:Range name:size
register (method) size in cv::Range

--- Incoming ---
[u'cv.Range.empty', u'bool', ['/NW', '/C'], [], '']
parseName: cv.Range.empty with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::empty namespace:cv classpath:Range classname:Range name:empty
register (method) empty in cv::Range

--- Incoming ---
[u'cv.Range.all', u'Range', ['/NW', '/S'], [], '']
parseName: cv.Range.all with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::all namespace:cv classpath:Range classname:Range name:all
register (method) all in cv::Range

--- Incoming ---
[u'cv.Range.operator CvSlice', u'', ['/NW', '/C'], [], '']
parseName: cv.Range.operator CvSlice with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Range::operator CvSlice namespace:cv classpath:Range classname:Range name:operator CvSlice
ignore (method) operator CvSlice in cv::Range

--- Incoming ---
[   u'class cv._InputArray',
    '',
    [],
    [],
    u"Proxy datatype for passing Mat's and vector<>'s as input parameters\n"]
parseName: class cv._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray namespace:cv classpath: classname: name:_InputArray
register class cv::_InputArray ([u'class cv._InputArray', '', [], [], u"Proxy datatype for passing Mat's and vector<>'s as input parameters\n"]) [ignored]

--- Incoming ---
[u'const cv._InputArray.KIND_SHIFT', u'16', [], []]
parseName: const cv._InputArray.KIND_SHIFT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::KIND_SHIFT namespace:cv classpath:_InputArray classname:_InputArray name:KIND_SHIFT

--- Incoming ---
[u'const cv._InputArray.FIXED_TYPE', u'0x8000 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.FIXED_TYPE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::FIXED_TYPE namespace:cv classpath:_InputArray classname:_InputArray name:FIXED_TYPE

--- Incoming ---
[u'const cv._InputArray.FIXED_SIZE', u'0x4000 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.FIXED_SIZE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::FIXED_SIZE namespace:cv classpath:_InputArray classname:_InputArray name:FIXED_SIZE

--- Incoming ---
[   u'const cv._InputArray.KIND_MASK',
    u'~(FIXED_TYPE|FIXED_SIZE) - (1 << KIND_SHIFT) + 1',
    [],
    []]
parseName: const cv._InputArray.KIND_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::KIND_MASK namespace:cv classpath:_InputArray classname:_InputArray name:KIND_MASK

--- Incoming ---
[u'const cv._InputArray.NONE', u'0 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.NONE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::NONE namespace:cv classpath:_InputArray classname:_InputArray name:NONE

--- Incoming ---
[u'const cv._InputArray.MAT', u'1 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.MAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::MAT namespace:cv classpath:_InputArray classname:_InputArray name:MAT

--- Incoming ---
[u'const cv._InputArray.MATX', u'2 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.MATX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::MATX namespace:cv classpath:_InputArray classname:_InputArray name:MATX

--- Incoming ---
[u'const cv._InputArray.STD_VECTOR', u'3 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.STD_VECTOR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::STD_VECTOR namespace:cv classpath:_InputArray classname:_InputArray name:STD_VECTOR

--- Incoming ---
[u'const cv._InputArray.STD_VECTOR_VECTOR', u'4 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.STD_VECTOR_VECTOR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::STD_VECTOR_VECTOR namespace:cv classpath:_InputArray classname:_InputArray name:STD_VECTOR_VECTOR

--- Incoming ---
[u'const cv._InputArray.STD_VECTOR_MAT', u'5 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.STD_VECTOR_MAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::STD_VECTOR_MAT namespace:cv classpath:_InputArray classname:_InputArray name:STD_VECTOR_MAT

--- Incoming ---
[u'const cv._InputArray.EXPR', u'6 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.EXPR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::EXPR namespace:cv classpath:_InputArray classname:_InputArray name:EXPR

--- Incoming ---
[u'const cv._InputArray.OPENGL_BUFFER', u'7 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.OPENGL_BUFFER with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::OPENGL_BUFFER namespace:cv classpath:_InputArray classname:_InputArray name:OPENGL_BUFFER

--- Incoming ---
[u'const cv._InputArray.OPENGL_TEXTURE', u'8 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.OPENGL_TEXTURE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::OPENGL_TEXTURE namespace:cv classpath:_InputArray classname:_InputArray name:OPENGL_TEXTURE

--- Incoming ---
[u'const cv._InputArray.GPU_MAT', u'9 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.GPU_MAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::GPU_MAT namespace:cv classpath:_InputArray classname:_InputArray name:GPU_MAT

--- Incoming ---
[u'const cv._InputArray.OCL_MAT', u'10 << KIND_SHIFT', [], []]
parseName: const cv._InputArray.OCL_MAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::OCL_MAT namespace:cv classpath:_InputArray classname:_InputArray name:OCL_MAT

--- Incoming ---
[u'cv._InputArray._InputArray', u'', ['/NW'], [], '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const MatExpr&', u'expr', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: MatExpr
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const vector<Mat>&', u'vec', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const Scalar&', u's', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const double&', u'val', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const GlBuffer&', u'buf', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: GlBuffer
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const GlTexture&', u'tex', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: GlTexture
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const gpu::GpuMat&', u'd_mat', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: gpu::GpuMat
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const ogl::Buffer&', u'buf', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: ogl::Buffer
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray._InputArray',
    u'',
    ['/NW'],
    [[u'const ogl::Texture2D&', u'tex', '', []]],
    '']
parseName: cv._InputArray._InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:_InputArray
Registering an unknown type: ogl::Texture2D
register (constructor) new in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.getMat',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.getMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getMat namespace:cv classpath:_InputArray classname:_InputArray name:getMat
register (method) getMat in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.getMatVector',
    u'void',
    ['/NW', '/C'],
    [[u'vector<Mat>&', u'mv', '', []]],
    '']
parseName: cv._InputArray.getMatVector with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getMatVector namespace:cv classpath:_InputArray classname:_InputArray name:getMatVector
register (method) getMatVector in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.getGlBuffer', u'GlBuffer', ['/NW', '/C'], [], '']
parseName: cv._InputArray.getGlBuffer with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getGlBuffer namespace:cv classpath:_InputArray classname:_InputArray name:getGlBuffer
Registering an unknown type: GlBuffer
register (method) getGlBuffer in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.getGlTexture', u'GlTexture', ['/NW', '/C'], [], '']
parseName: cv._InputArray.getGlTexture with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getGlTexture namespace:cv classpath:_InputArray classname:_InputArray name:getGlTexture
Registering an unknown type: GlTexture
register (method) getGlTexture in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.getGpuMat', u'gpu::GpuMat', ['/NW', '/C'], [], '']
parseName: cv._InputArray.getGpuMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getGpuMat namespace:cv classpath:_InputArray classname:_InputArray name:getGpuMat
Registering an unknown type: gpu::GpuMat
register (method) getGpuMat in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.getOGlBuffer', u'ogl::Buffer', ['/NW', '/C'], [], '']
parseName: cv._InputArray.getOGlBuffer with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getOGlBuffer namespace:cv classpath:_InputArray classname:_InputArray name:getOGlBuffer
Registering an unknown type: ogl::Buffer
register (method) getOGlBuffer in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.getOGlTexture2D', u'ogl::Texture2D', ['/NW', '/C'], [], '']
parseName: cv._InputArray.getOGlTexture2D with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::getOGlTexture2D namespace:cv classpath:_InputArray classname:_InputArray name:getOGlTexture2D
Registering an unknown type: ogl::Texture2D
register (method) getOGlTexture2D in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.kind', u'int', ['/NW', '/C'], [], '']
parseName: cv._InputArray.kind with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::kind namespace:cv classpath:_InputArray classname:_InputArray name:kind
register (method) kind in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.size',
    u'Size',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::size namespace:cv classpath:_InputArray classname:_InputArray name:size
register (method) size in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.total',
    u'size_t',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.total with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::total namespace:cv classpath:_InputArray classname:_InputArray name:total
register (method) total in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.type',
    u'int',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.type with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::type namespace:cv classpath:_InputArray classname:_InputArray name:type
register (method) type in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.depth',
    u'int',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.depth with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::depth namespace:cv classpath:_InputArray classname:_InputArray name:depth
register (method) depth in cv::_InputArray

--- Incoming ---
[   u'cv._InputArray.channels',
    u'int',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._InputArray.channels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::channels namespace:cv classpath:_InputArray classname:_InputArray name:channels
register (method) channels in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.empty', u'bool', ['/NW', '/C'], [], '']
parseName: cv._InputArray.empty with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::empty namespace:cv classpath:_InputArray classname:_InputArray name:empty
register (method) empty in cv::_InputArray

--- Incoming ---
[u'cv._InputArray.~_InputArray', u'', ['/NW'], [], '']
parseName: cv._InputArray.~_InputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_InputArray::~_InputArray namespace:cv classpath:_InputArray classname:_InputArray name:~_InputArray
ignore destructor (method) ~_InputArray in cv::_InputArray

--- Incoming ---
[u'const cv.DEPTH_MASK_8U', u'1 << CV_8U', [], []]
parseName: const cv.DEPTH_MASK_8U with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_8U namespace:cv classpath: classname: name:DEPTH_MASK_8U

--- Incoming ---
[u'const cv.DEPTH_MASK_8S', u'1 << CV_8S', [], []]
parseName: const cv.DEPTH_MASK_8S with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_8S namespace:cv classpath: classname: name:DEPTH_MASK_8S

--- Incoming ---
[u'const cv.DEPTH_MASK_16U', u'1 << CV_16U', [], []]
parseName: const cv.DEPTH_MASK_16U with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_16U namespace:cv classpath: classname: name:DEPTH_MASK_16U

--- Incoming ---
[u'const cv.DEPTH_MASK_16S', u'1 << CV_16S', [], []]
parseName: const cv.DEPTH_MASK_16S with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_16S namespace:cv classpath: classname: name:DEPTH_MASK_16S

--- Incoming ---
[u'const cv.DEPTH_MASK_32S', u'1 << CV_32S', [], []]
parseName: const cv.DEPTH_MASK_32S with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_32S namespace:cv classpath: classname: name:DEPTH_MASK_32S

--- Incoming ---
[u'const cv.DEPTH_MASK_32F', u'1 << CV_32F', [], []]
parseName: const cv.DEPTH_MASK_32F with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_32F namespace:cv classpath: classname: name:DEPTH_MASK_32F

--- Incoming ---
[u'const cv.DEPTH_MASK_64F', u'1 << CV_64F', [], []]
parseName: const cv.DEPTH_MASK_64F with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_64F namespace:cv classpath: classname: name:DEPTH_MASK_64F

--- Incoming ---
[u'const cv.DEPTH_MASK_ALL', u'(DEPTH_MASK_64F<<1)-1', [], []]
parseName: const cv.DEPTH_MASK_ALL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_ALL namespace:cv classpath: classname: name:DEPTH_MASK_ALL

--- Incoming ---
[u'const cv.DEPTH_MASK_ALL_BUT_8S', u'DEPTH_MASK_ALL & ~DEPTH_MASK_8S', [], []]
parseName: const cv.DEPTH_MASK_ALL_BUT_8S with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_ALL_BUT_8S namespace:cv classpath: classname: name:DEPTH_MASK_ALL_BUT_8S

--- Incoming ---
[u'const cv.DEPTH_MASK_FLT', u'DEPTH_MASK_32F + DEPTH_MASK_64F', [], []]
parseName: const cv.DEPTH_MASK_FLT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK_FLT namespace:cv classpath: classname: name:DEPTH_MASK_FLT

--- Incoming ---
[   u'class cv._OutputArray',
    u': cv::_InputArray',
    [],
    [],
    u"Proxy datatype for passing Mat's and vector<>'s as input parameters\n"]
parseName: class cv._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray namespace:cv classpath: classname: name:_OutputArray
register class cv::_OutputArray ([u'class cv._OutputArray', u': cv::_InputArray', [], [], u"Proxy datatype for passing Mat's and vector<>'s as input parameters\n"]) [ignored] impl:cv::_InputArray

--- Incoming ---
[u'cv._OutputArray._OutputArray', u'', ['/NW'], [], '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray._OutputArray', u'', ['/NW'], [[u'Mat&', u'm', '', []]], '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'vector<Mat>&', u'vec', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'gpu::GpuMat&', u'd_mat', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
Registering an unknown type: gpu::GpuMat
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'ogl::Buffer&', u'buf', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
Registering an unknown type: ogl::Buffer
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'ogl::Texture2D&', u'tex', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
Registering an unknown type: ogl::Texture2D
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'const vector<Mat>&', u'vec', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'const gpu::GpuMat&', u'd_mat', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'const ogl::Buffer&', u'buf', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray._OutputArray',
    u'',
    ['/NW'],
    [[u'const ogl::Texture2D&', u'tex', '', []]],
    '']
parseName: cv._OutputArray._OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:_OutputArray
register (constructor) new in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.fixedSize', u'bool', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.fixedSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::fixedSize namespace:cv classpath:_OutputArray classname:_OutputArray name:fixedSize
register (method) fixedSize in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.fixedType', u'bool', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.fixedType with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::fixedType namespace:cv classpath:_OutputArray classname:_OutputArray name:fixedType
register (method) fixedType in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.needed', u'bool', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.needed with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::needed namespace:cv classpath:_OutputArray classname:_OutputArray name:needed
register (method) needed in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray.getMatRef',
    u'Mat&',
    ['/NW', '/C'],
    [[u'int', u'i', u'-1', []]],
    '']
parseName: cv._OutputArray.getMatRef with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::getMatRef namespace:cv classpath:_OutputArray classname:_OutputArray name:getMatRef
register (method) getMatRef in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.getGpuMatRef', u'gpu::GpuMat&', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.getGpuMatRef with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::getGpuMatRef namespace:cv classpath:_OutputArray classname:_OutputArray name:getGpuMatRef
register (method) getGpuMatRef in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.getOGlBufferRef', u'ogl::Buffer&', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.getOGlBufferRef with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::getOGlBufferRef namespace:cv classpath:_OutputArray classname:_OutputArray name:getOGlBufferRef
register (method) getOGlBufferRef in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray.getOGlTexture2DRef',
    u'ogl::Texture2D&',
    ['/NW', '/C'],
    [],
    '']
parseName: cv._OutputArray.getOGlTexture2DRef with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::getOGlTexture2DRef namespace:cv classpath:_OutputArray classname:_OutputArray name:getOGlTexture2DRef
register (method) getOGlTexture2DRef in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray.create',
    u'void',
    ['/NW', '/C'],
    [   [u'Size', u'sz', '', []],
        [u'int', u'type', '', []],
        [u'int', u'i', u'-1', []],
        [u'bool', u'allowTransposed', u'false', []],
        [u'int', u'fixedDepthMask', u'0', []]],
    '']
parseName: cv._OutputArray.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::create namespace:cv classpath:_OutputArray classname:_OutputArray name:create
register (method) create in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray.create',
    u'void',
    ['/NW', '/C'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []],
        [u'int', u'i', u'-1', []],
        [u'bool', u'allowTransposed', u'false', []],
        [u'int', u'fixedDepthMask', u'0', []]],
    '']
parseName: cv._OutputArray.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::create namespace:cv classpath:_OutputArray classname:_OutputArray name:create
register (method) create in cv::_OutputArray

--- Incoming ---
[   u'cv._OutputArray.create',
    u'void',
    ['/NW', '/C'],
    [   [u'int', u'dims', '', []],
        [u'const int*', u'size', '', []],
        [u'int', u'type', '', []],
        [u'int', u'i', u'-1', []],
        [u'bool', u'allowTransposed', u'false', []],
        [u'int', u'fixedDepthMask', u'0', []]],
    '']
parseName: cv._OutputArray.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::create namespace:cv classpath:_OutputArray classname:_OutputArray name:create
register (method) create in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.release', u'void', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.release with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::release namespace:cv classpath:_OutputArray classname:_OutputArray name:release
register (method) release in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.clear', u'void', ['/NW', '/C'], [], '']
parseName: cv._OutputArray.clear with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::clear namespace:cv classpath:_OutputArray classname:_OutputArray name:clear
register (method) clear in cv::_OutputArray

--- Incoming ---
[u'cv._OutputArray.~_OutputArray', u'', ['/NW'], [], '']
parseName: cv._OutputArray.~_OutputArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::_OutputArray::~_OutputArray namespace:cv classpath:_OutputArray classname:_OutputArray name:~_OutputArray
ignore destructor (method) ~_OutputArray in cv::_OutputArray

--- Incoming ---
[u'cv.noArray', u'OutputArray', ['/NW'], [], '']
parseName: cv.noArray with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::noArray namespace:cv classpath: classname: name:noArray
register (function) noArray

--- Incoming ---
[u'const cv.MAGIC_MASK', u'0xFFFF0000', [], []]
parseName: const cv.MAGIC_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MAGIC_MASK namespace:cv classpath: classname: name:MAGIC_MASK

--- Incoming ---
[u'const cv.TYPE_MASK', u'0x00000FFF', [], []]
parseName: const cv.TYPE_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TYPE_MASK namespace:cv classpath: classname: name:TYPE_MASK

--- Incoming ---
[u'const cv.DEPTH_MASK', u'7', [], []]
parseName: const cv.DEPTH_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::DEPTH_MASK namespace:cv classpath: classname: name:DEPTH_MASK

--- Incoming ---
[u'cv.getElemSize', u'size_t', ['/NW'], [[u'int', u'type', '', []]], '']
parseName: cv.getElemSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getElemSize namespace:cv classpath: classname: name:getElemSize
register (function) getElemSize

--- Incoming ---
[u'class cv.MatAllocator', '', [], [], u'Custom array allocator\n\n']
parseName: class cv.MatAllocator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatAllocator namespace:cv classpath: classname: name:MatAllocator
register class cv::MatAllocator ([u'class cv.MatAllocator', '', [], [], u'Custom array allocator\n\n']) [ignored]

--- Incoming ---
[u'cv.MatAllocator.MatAllocator', u'', ['/NW'], [], '']
parseName: cv.MatAllocator.MatAllocator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatAllocator::MatAllocator namespace:cv classpath:MatAllocator classname:MatAllocator name:MatAllocator
register (constructor) new in cv::MatAllocator

--- Incoming ---
[u'cv.MatAllocator.~MatAllocator', u'', ['/NW'], [], '']
parseName: cv.MatAllocator.~MatAllocator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatAllocator::~MatAllocator namespace:cv classpath:MatAllocator classname:MatAllocator name:~MatAllocator
ignore destructor (method) ~MatAllocator in cv::MatAllocator

--- Incoming ---
[   u'cv.MatAllocator.allocate',
    u'void',
    ['/NW', '/A'],
    [   [u'int', u'dims', '', []],
        [u'const int*', u'sizes', '', []],
        [u'int', u'type', '', []],
        [u'int*&', u'refcount', '', []],
        [u'uchar*&', u'datastart', '', []],
        [u'uchar*&', u'data', '', []],
        [u'size_t*', u'step', '', []]],
    '']
parseName: cv.MatAllocator.allocate with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatAllocator::allocate namespace:cv classpath:MatAllocator classname:MatAllocator name:allocate

--- Incoming ---
[   u'cv.MatAllocator.deallocate',
    u'void',
    ['/NW', '/A'],
    [   [u'int*', u'refcount', '', []],
        [u'uchar*', u'datastart', '', []],
        [u'uchar*', u'data', '', []]],
    '']
parseName: cv.MatAllocator.deallocate with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatAllocator::deallocate namespace:cv classpath:MatAllocator classname:MatAllocator name:deallocate

--- Incoming ---
[   u'class cv.Mat',
    '',
    [],
    [],
    u'The n-dimensional matrix class.\n\nThe class represents an n-dimensional dense numerical array that can act as\na matrix, image, optical flow map, 3-focal tensor etc.\nIt is very similar to CvMat and CvMatND types from earlier versions of OpenCV,\nand similarly to those types, the matrix can be multi-channel. It also fully supports ROI mechanism.\n\nThere are many different ways to create cv::Mat object. Here are the some popular ones:\n<ul>\n<li> using cv::Mat::create(nrows, ncols, type) method or\nthe similar constructor cv::Mat::Mat(nrows, ncols, type[, fill_value]) constructor.\nA new matrix of the specified size and specifed type will be allocated.\n"type" has the same meaning as in cvCreateMat function,\ne.g. CV_8UC1 means 8-bit single-channel matrix, CV_32FC2 means 2-channel (i.e. complex)\nfloating-point matrix etc:\n\n\\code\n// make 7x7 complex matrix filled with 1+3j.\ncv::Mat M(7,7,CV_32FC2,Scalar(1,3));\n// and now turn M to 100x60 15-channel 8-bit matrix.\n// The old content will be deallocated\nM.create(100,60,CV_8UC(15));\n\\endcode\n\nAs noted in the introduction of this chapter, Mat::create()\nwill only allocate a new matrix when the current matrix dimensionality\nor type are different from the specified.\n\n<li> by using a copy constructor or assignment operator, where on the right side it can\nbe a matrix or expression, see below. Again, as noted in the introduction,\nmatrix assignment is O(1) operation because it only copies the header\nand increases the reference counter. cv::Mat::clone() method can be used to get a full\n(a.k.a. deep) copy of the matrix when you need it.\n\n<li> by constructing a header for a part of another matrix. It can be a single row, single column,\nseveral rows, several columns, rectangular region in the matrix (called a minor in algebra) or\na diagonal. Such operations are also O(1), because the new header will reference the same data.\nYou can actually modify a part of the matrix using this feature, e.g.\n\n\\code\n// add 5-th row, multiplied by 3 to the 3rd row\nM.row(3) = M.row(3) + M.row(5)*3;\n\n// now copy 7-th column to the 1-st column\n// M.col(1) = M.col(7); // this will not work\nMat M1 = M.col(1);\nM.col(7).copyTo(M1);\n\n// create new 320x240 image\ncv::Mat img(Size(320,240),CV_8UC3);\n// select a roi\ncv::Mat roi(img, Rect(10,10,100,100));\n// fill the ROI with (0,255,0) (which is green in RGB space);\n// the original 320x240 image will be modified\nroi = Scalar(0,255,0);\n\\endcode\n\nThanks to the additional cv::Mat::datastart and cv::Mat::dataend members, it is possible to\ncompute the relative sub-matrix position in the main "container" matrix using cv::Mat::locateROI():\n\n\\code\nMat A = Mat::eye(10, 10, CV_32S);\n// extracts A columns, 1 (inclusive) to 3 (exclusive).\nMat B = A(Range::all(), Range(1, 3));\n// extracts B rows, 5 (inclusive) to 9 (exclusive).\n// that is, C ~ A(Range(5, 9), Range(1, 3))\nMat C = B(Range(5, 9), Range::all());\nSize size; Point ofs;\nC.locateROI(size, ofs);\n// size will be (width=10,height=10) and the ofs will be (x=1, y=5)\n\\endcode\n\nAs in the case of whole matrices, if you need a deep copy, use cv::Mat::clone() method\nof the extracted sub-matrices.\n\n<li> by making a header for user-allocated-data. It can be useful for\n<ol>\n<li> processing "foreign" data using OpenCV (e.g. when you implement\na DirectShow filter or a processing module for gstreamer etc.), e.g.\n\n\\code\nvoid process_video_frame(const unsigned char* pixels,\nint width, int height, int step)\n{\ncv::Mat img(height, width, CV_8UC3, pixels, step);\ncv::GaussianBlur(img, img, cv::Size(7,7), 1.5, 1.5);\n}\n\\endcode\n\n<li> for quick initialization of small matrices and/or super-fast element access\n\n\\code\ndouble m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};\ncv::Mat M = cv::Mat(3, 3, CV_64F, m).inv();\n\\endcode\n</ol>\n\npartial yet very common cases of this "user-allocated data" case are conversions\nfrom CvMat and IplImage to cv::Mat. For this purpose there are special constructors\ntaking pointers to CvMat or IplImage and the optional\nflag indicating whether to copy the data or not.\n\nBackward conversion from cv::Mat to CvMat or IplImage is provided via cast operators\ncv::Mat::operator CvMat() an cv::Mat::operator IplImage().\nThe operators do not copy the data.\n\n\n\\code\nIplImage* img = cvLoadImage("greatwave.jpg", 1);\nMat mtx(img); // convert IplImage* -> cv::Mat\nCvMat oldmat = mtx; // convert cv::Mat -> CvMat\nCV_Assert(oldmat.cols == img->width && oldmat.rows == img->height &&\noldmat.data.ptr == (uchar*)img->imageData && oldmat.step == img->widthStep);\n\\endcode\n\n<li> by using MATLAB-style matrix initializers, cv::Mat::zeros(), cv::Mat::ones(), cv::Mat::eye(), e.g.:\n\n\\code\n// create a double-precision identity martix and add it to M.\nM += Mat::eye(M.rows, M.cols, CV_64F);\n\\endcode\n\n<li> by using comma-separated initializer:\n\n\\code\n// create 3x3 double-precision identity matrix\nMat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);\n\\endcode\n\nhere we first call constructor of cv::Mat_ class (that we describe further) with the proper matrix,\nand then we just put "<<" operator followed by comma-separated values that can be constants,\nvariables, expressions etc. Also, note the extra parentheses that are needed to avoid compiler errors.\n\n</ul>\n\nOnce matrix is created, it will be automatically managed by using reference-counting mechanism\n(unless the matrix header is built on top of user-allocated data,\nin which case you should handle the data by yourself).\nThe matrix data will be deallocated when no one points to it;\nif you want to release the data pointed by a matrix header before the matrix destructor is called,\nuse cv::Mat::release().\n\nThe next important thing to learn about the matrix class is element access. Here is how the matrix is stored.\nThe elements are stored in row-major order (row by row). The cv::Mat::data member points to the first element of the first row,\ncv::Mat::rows contains the number of matrix rows and cv::Mat::cols - the number of matrix columns. There is yet another member,\ncv::Mat::step that is used to actually compute address of a matrix element. cv::Mat::step is needed because the matrix can be\na part of another matrix or because there can some padding space in the end of each row for a proper alignment.\n\nGiven these parameters, address of the matrix element M_{ij} is computed as following:\n\naddr(M_{ij})=M.data + M.step*i + j*M.elemSize()\n\nif you know the matrix element type, e.g. it is float, then you can use cv::Mat::at() method:\n\naddr(M_{ij})=&M.at<float>(i,j)\n\n(where & is used to convert the reference returned by cv::Mat::at() to a pointer).\nif you need to process a whole row of matrix, the most efficient way is to get\nthe pointer to the row first, and then just use plain C operator []:\n\n\\code\n// compute sum of positive matrix elements\n// (assuming that M is double-precision matrix)\ndouble sum=0;\nfor(int i = 0; i < M.rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < M.cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n\\endcode\n\nSome operations, like the above one, do not actually depend on the matrix shape,\nthey just process elements of a matrix one by one (or elements from multiple matrices\nthat are sitting in the same place, e.g. matrix addition). Such operations are called\nelement-wise and it makes sense to check whether all the input/output matrices are continuous,\ni.e. have no gaps in the end of each row, and if yes, process them as a single long row:\n\n\\code\n// compute sum of positive matrix elements, optimized variant\ndouble sum=0;\nint cols = M.cols, rows = M.rows;\nif(M.isContinuous())\n{\ncols *= rows;\nrows = 1;\n}\nfor(int i = 0; i < rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n\\endcode\nin the case of continuous matrix the outer loop body will be executed just once,\nso the overhead will be smaller, which will be especially noticeable in the case of small matrices.\n\nFinally, there are STL-style iterators that are smart enough to skip gaps between successive rows:\n\\code\n// compute sum of positive matrix elements, iterator-based variant\ndouble sum=0;\nMatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();\nfor(; it != it_end; ++it)\nsum += std::max(*it, 0.);\n\\endcode\n\nThe matrix iterators are random-access iterators, so they can be passed\nto any STL algorithm, including std::sort().\n']
parseName: class cv.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat namespace:cv classpath: classname: name:Mat
register class cv::Mat ([u'class cv.Mat', '', [], [], u'The n-dimensional matrix class.\n\nThe class represents an n-dimensional dense numerical array that can act as\na matrix, image, optical flow map, 3-focal tensor etc.\nIt is very similar to CvMat and CvMatND types from earlier versions of OpenCV,\nand similarly to those types, the matrix can be multi-channel. It also fully supports ROI mechanism.\n\nThere are many different ways to create cv::Mat object. Here are the some popular ones:\n<ul>\n<li> using cv::Mat::create(nrows, ncols, type) method or\nthe similar constructor cv::Mat::Mat(nrows, ncols, type[, fill_value]) constructor.\nA new matrix of the specified size and specifed type will be allocated.\n"type" has the same meaning as in cvCreateMat function,\ne.g. CV_8UC1 means 8-bit single-channel matrix, CV_32FC2 means 2-channel (i.e. complex)\nfloating-point matrix etc:\n\n\\code\n// make 7x7 complex matrix filled with 1+3j.\ncv::Mat M(7,7,CV_32FC2,Scalar(1,3));\n// and now turn M to 100x60 15-channel 8-bit matrix.\n// The old content will be deallocated\nM.create(100,60,CV_8UC(15));\n\\endcode\n\nAs noted in the introduction of this chapter, Mat::create()\nwill only allocate a new matrix when the current matrix dimensionality\nor type are different from the specified.\n\n<li> by using a copy constructor or assignment operator, where on the right side it can\nbe a matrix or expression, see below. Again, as noted in the introduction,\nmatrix assignment is O(1) operation because it only copies the header\nand increases the reference counter. cv::Mat::clone() method can be used to get a full\n(a.k.a. deep) copy of the matrix when you need it.\n\n<li> by constructing a header for a part of another matrix. It can be a single row, single column,\nseveral rows, several columns, rectangular region in the matrix (called a minor in algebra) or\na diagonal. Such operations are also O(1), because the new header will reference the same data.\nYou can actually modify a part of the matrix using this feature, e.g.\n\n\\code\n// add 5-th row, multiplied by 3 to the 3rd row\nM.row(3) = M.row(3) + M.row(5)*3;\n\n// now copy 7-th column to the 1-st column\n// M.col(1) = M.col(7); // this will not work\nMat M1 = M.col(1);\nM.col(7).copyTo(M1);\n\n// create new 320x240 image\ncv::Mat img(Size(320,240),CV_8UC3);\n// select a roi\ncv::Mat roi(img, Rect(10,10,100,100));\n// fill the ROI with (0,255,0) (which is green in RGB space);\n// the original 320x240 image will be modified\nroi = Scalar(0,255,0);\n\\endcode\n\nThanks to the additional cv::Mat::datastart and cv::Mat::dataend members, it is possible to\ncompute the relative sub-matrix position in the main "container" matrix using cv::Mat::locateROI():\n\n\\code\nMat A = Mat::eye(10, 10, CV_32S);\n// extracts A columns, 1 (inclusive) to 3 (exclusive).\nMat B = A(Range::all(), Range(1, 3));\n// extracts B rows, 5 (inclusive) to 9 (exclusive).\n// that is, C ~ A(Range(5, 9), Range(1, 3))\nMat C = B(Range(5, 9), Range::all());\nSize size; Point ofs;\nC.locateROI(size, ofs);\n// size will be (width=10,height=10) and the ofs will be (x=1, y=5)\n\\endcode\n\nAs in the case of whole matrices, if you need a deep copy, use cv::Mat::clone() method\nof the extracted sub-matrices.\n\n<li> by making a header for user-allocated-data. It can be useful for\n<ol>\n<li> processing "foreign" data using OpenCV (e.g. when you implement\na DirectShow filter or a processing module for gstreamer etc.), e.g.\n\n\\code\nvoid process_video_frame(const unsigned char* pixels,\nint width, int height, int step)\n{\ncv::Mat img(height, width, CV_8UC3, pixels, step);\ncv::GaussianBlur(img, img, cv::Size(7,7), 1.5, 1.5);\n}\n\\endcode\n\n<li> for quick initialization of small matrices and/or super-fast element access\n\n\\code\ndouble m[3][3] = {{a, b, c}, {d, e, f}, {g, h, i}};\ncv::Mat M = cv::Mat(3, 3, CV_64F, m).inv();\n\\endcode\n</ol>\n\npartial yet very common cases of this "user-allocated data" case are conversions\nfrom CvMat and IplImage to cv::Mat. For this purpose there are special constructors\ntaking pointers to CvMat or IplImage and the optional\nflag indicating whether to copy the data or not.\n\nBackward conversion from cv::Mat to CvMat or IplImage is provided via cast operators\ncv::Mat::operator CvMat() an cv::Mat::operator IplImage().\nThe operators do not copy the data.\n\n\n\\code\nIplImage* img = cvLoadImage("greatwave.jpg", 1);\nMat mtx(img); // convert IplImage* -> cv::Mat\nCvMat oldmat = mtx; // convert cv::Mat -> CvMat\nCV_Assert(oldmat.cols == img->width && oldmat.rows == img->height &&\noldmat.data.ptr == (uchar*)img->imageData && oldmat.step == img->widthStep);\n\\endcode\n\n<li> by using MATLAB-style matrix initializers, cv::Mat::zeros(), cv::Mat::ones(), cv::Mat::eye(), e.g.:\n\n\\code\n// create a double-precision identity martix and add it to M.\nM += Mat::eye(M.rows, M.cols, CV_64F);\n\\endcode\n\n<li> by using comma-separated initializer:\n\n\\code\n// create 3x3 double-precision identity matrix\nMat M = (Mat_<double>(3,3) << 1, 0, 0, 0, 1, 0, 0, 0, 1);\n\\endcode\n\nhere we first call constructor of cv::Mat_ class (that we describe further) with the proper matrix,\nand then we just put "<<" operator followed by comma-separated values that can be constants,\nvariables, expressions etc. Also, note the extra parentheses that are needed to avoid compiler errors.\n\n</ul>\n\nOnce matrix is created, it will be automatically managed by using reference-counting mechanism\n(unless the matrix header is built on top of user-allocated data,\nin which case you should handle the data by yourself).\nThe matrix data will be deallocated when no one points to it;\nif you want to release the data pointed by a matrix header before the matrix destructor is called,\nuse cv::Mat::release().\n\nThe next important thing to learn about the matrix class is element access. Here is how the matrix is stored.\nThe elements are stored in row-major order (row by row). The cv::Mat::data member points to the first element of the first row,\ncv::Mat::rows contains the number of matrix rows and cv::Mat::cols - the number of matrix columns. There is yet another member,\ncv::Mat::step that is used to actually compute address of a matrix element. cv::Mat::step is needed because the matrix can be\na part of another matrix or because there can some padding space in the end of each row for a proper alignment.\n\nGiven these parameters, address of the matrix element M_{ij} is computed as following:\n\naddr(M_{ij})=M.data + M.step*i + j*M.elemSize()\n\nif you know the matrix element type, e.g. it is float, then you can use cv::Mat::at() method:\n\naddr(M_{ij})=&M.at<float>(i,j)\n\n(where & is used to convert the reference returned by cv::Mat::at() to a pointer).\nif you need to process a whole row of matrix, the most efficient way is to get\nthe pointer to the row first, and then just use plain C operator []:\n\n\\code\n// compute sum of positive matrix elements\n// (assuming that M is double-precision matrix)\ndouble sum=0;\nfor(int i = 0; i < M.rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < M.cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n\\endcode\n\nSome operations, like the above one, do not actually depend on the matrix shape,\nthey just process elements of a matrix one by one (or elements from multiple matrices\nthat are sitting in the same place, e.g. matrix addition). Such operations are called\nelement-wise and it makes sense to check whether all the input/output matrices are continuous,\ni.e. have no gaps in the end of each row, and if yes, process them as a single long row:\n\n\\code\n// compute sum of positive matrix elements, optimized variant\ndouble sum=0;\nint cols = M.cols, rows = M.rows;\nif(M.isContinuous())\n{\ncols *= rows;\nrows = 1;\n}\nfor(int i = 0; i < rows; i++)\n{\nconst double* Mi = M.ptr<double>(i);\nfor(int j = 0; j < cols; j++)\nsum += std::max(Mi[j], 0.);\n}\n\\endcode\nin the case of continuous matrix the outer loop body will be executed just once,\nso the overhead will be smaller, which will be especially noticeable in the case of small matrices.\n\nFinally, there are STL-style iterators that are smart enough to skip gaps between successive rows:\n\\code\n// compute sum of positive matrix elements, iterator-based variant\ndouble sum=0;\nMatConstIterator_<double> it = M.begin<double>(), it_end = M.end<double>();\nfor(; it != it_end; ++it)\nsum += std::max(*it, 0.);\n\\endcode\n\nThe matrix iterators are random-access iterators, so they can be passed\nto any STL algorithm, including std::sort().\n'])

--- Incoming ---
[u'cv.Mat.Mat', u'', ['/NW'], [], u'default constructor\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []]],
    u'constructs 2D matrix of the specified size and type\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'Size', u'size', '', []], [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []],
        [u'const Scalar&', u's', '', []]],
    u'constucts 2D matrix and fills it with the specified value _s.\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'Size', u'size', '', []],
        [u'int', u'type', '', []],
        [u'const Scalar&', u's', '', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sizes', '', []],
        [u'int', u'type', '', []]],
    u'constructs n-dimensional matrix\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sizes', '', []],
        [u'int', u'type', '', []],
        [u'const Scalar&', u's', '', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    u'copy constructor\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []],
        [u'void*', u'data', '', []],
        [u'size_t', u'step', u'AUTO_STEP', []]],
    u'constructor for matrix headers pointing to user-allocated data\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'Size', u'size', '', []],
        [u'int', u'type', '', []],
        [u'void*', u'data', '', []],
        [u'size_t', u'step', u'AUTO_STEP', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sizes', '', []],
        [u'int', u'type', '', []],
        [u'void*', u'data', '', []],
        [u'const size_t*', u'steps', u'0', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'const Mat&', u'm', '', []],
        [u'const Range&', u'rowRange', '', []],
        [u'const Range&', u'colRange', u'Range::all()', []]],
    u'creates a matrix header for a part of the bigger matrix\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'const Mat&', u'm', '', []], [u'const Rect&', u'roi', '', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'const Mat&', u'm', '', []], [u'const Range*', u'ranges', '', []]],
    '']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'const CvMat*', u'm', '', []], [u'bool', u'copyData', u'false', []]],
    u'converts old-style CvMat to the new matrix; the data is not copied by default\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [[u'const CvMatND*', u'm', '', []], [u'bool', u'copyData', u'false', []]],
    u'converts old-style CvMatND to the new matrix; the data is not copied by default\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW'],
    [   [u'const IplImage*', u'img', '', []],
        [u'bool', u'copyData', u'false', []]],
    u'converts old-style IplImage to the new matrix; the data is not copied by default\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[   u'cv.Mat.Mat',
    u'',
    ['/NW', '/E'],
    [[u'const gpu::GpuMat&', u'm', '', []]],
    u'download data from GpuMat\n']
parseName: cv.Mat.Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::Mat namespace:cv classpath:Mat classname:Mat name:Mat
register (constructor) new in cv::Mat

--- Incoming ---
[u'cv.Mat.~Mat', u'', ['/NW'], [], u'destructor - calls release()\n']
parseName: cv.Mat.~Mat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::~Mat namespace:cv classpath:Mat classname:Mat name:~Mat
ignore destructor (method) ~Mat in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator =',
    u'Mat&',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    u'assignment operators\n']
parseName: cv.Mat.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator = namespace:cv classpath:Mat classname:Mat name:operator =
ignore (method) operator = in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator =',
    u'Mat&',
    ['/NW'],
    [[u'const MatExpr&', u'expr', '', []]],
    '']
parseName: cv.Mat.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator = namespace:cv classpath:Mat classname:Mat name:operator =
ignore (method) operator = in cv::Mat

--- Incoming ---
[   u'cv.Mat.row',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'y', '', []]],
    u'returns a new matrix header for the specified row\n']
parseName: cv.Mat.row with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::row namespace:cv classpath:Mat classname:Mat name:row
register (method) row in cv::Mat

--- Incoming ---
[   u'cv.Mat.col',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'x', '', []]],
    u'returns a new matrix header for the specified column\n']
parseName: cv.Mat.col with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::col namespace:cv classpath:Mat classname:Mat name:col
register (method) col in cv::Mat

--- Incoming ---
[   u'cv.Mat.rowRange',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'startrow', '', []], [u'int', u'endrow', '', []]],
    u'... for the specified row span\n']
parseName: cv.Mat.rowRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::rowRange namespace:cv classpath:Mat classname:Mat name:rowRange
register (method) rowRange in cv::Mat

--- Incoming ---
[   u'cv.Mat.rowRange',
    u'Mat',
    ['/NW', '/C'],
    [[u'const Range&', u'r', '', []]],
    '']
parseName: cv.Mat.rowRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::rowRange namespace:cv classpath:Mat classname:Mat name:rowRange
register (method) rowRange in cv::Mat

--- Incoming ---
[   u'cv.Mat.colRange',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'startcol', '', []], [u'int', u'endcol', '', []]],
    u'... for the specified column span\n']
parseName: cv.Mat.colRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::colRange namespace:cv classpath:Mat classname:Mat name:colRange
register (method) colRange in cv::Mat

--- Incoming ---
[   u'cv.Mat.colRange',
    u'Mat',
    ['/NW', '/C'],
    [[u'const Range&', u'r', '', []]],
    '']
parseName: cv.Mat.colRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::colRange namespace:cv classpath:Mat classname:Mat name:colRange
register (method) colRange in cv::Mat

--- Incoming ---
[   u'cv.Mat.diag',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'd', u'0', []]],
    u'... for the specified diagonal\n']
parseName: cv.Mat.diag with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::diag namespace:cv classpath:Mat classname:Mat name:diag
register (method) diag in cv::Mat

--- Incoming ---
[   u'cv.Mat.diag',
    u'Mat',
    ['/NW', '/S'],
    [[u'const Mat&', u'd', '', []]],
    u'constructs a square diagonal matrix which main diagonal is vector "d"\n']
parseName: cv.Mat.diag with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::diag namespace:cv classpath:Mat classname:Mat name:diag
register (method) diag in cv::Mat

--- Incoming ---
[   u'cv.Mat.clone',
    u'Mat',
    ['/NW', '/C'],
    [],
    u'returns deep copy of the matrix, i.e. the data is copied\n']
parseName: cv.Mat.clone with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::clone namespace:cv classpath:Mat classname:Mat name:clone
register (method) clone in cv::Mat

--- Incoming ---
[   u'cv.Mat.copyTo',
    u'void',
    ['/NW', '/C'],
    [[u'OutputArray', u'm', '', []]],
    u'copies the matrix content to "m".\n']
parseName: cv.Mat.copyTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::copyTo namespace:cv classpath:Mat classname:Mat name:copyTo
register (method) copyTo in cv::Mat

--- Incoming ---
[   u'cv.Mat.copyTo',
    u'void',
    ['/NW', '/C'],
    [[u'OutputArray', u'm', '', []], [u'InputArray', u'mask', '', []]],
    u'copies those matrix elements to "m" that are marked with non-zero mask elements.\n']
parseName: cv.Mat.copyTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::copyTo namespace:cv classpath:Mat classname:Mat name:copyTo
register (method) copyTo in cv::Mat

--- Incoming ---
[   u'cv.Mat.convertTo',
    u'void',
    ['/NW', '/C'],
    [   [u'OutputArray', u'm', '', []],
        [u'int', u'rtype', '', []],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'converts matrix to another datatype with optional scalng. See cvConvertScale.\n']
parseName: cv.Mat.convertTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::convertTo namespace:cv classpath:Mat classname:Mat name:convertTo
register (method) convertTo in cv::Mat

--- Incoming ---
[   u'cv.Mat.assignTo',
    u'void',
    ['/NW', '/C'],
    [[u'Mat&', u'm', '', []], [u'int', u'type', u'-1', []]],
    '']
parseName: cv.Mat.assignTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::assignTo namespace:cv classpath:Mat classname:Mat name:assignTo
register (method) assignTo in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator =',
    u'Mat&',
    ['/NW'],
    [[u'const Scalar&', u's', '', []]],
    u'sets every matrix element to s\n']
parseName: cv.Mat.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator = namespace:cv classpath:Mat classname:Mat name:operator =
ignore (method) operator = in cv::Mat

--- Incoming ---
[   u'cv.Mat.setTo',
    u'Mat&',
    ['/NW'],
    [   [u'InputArray', u'value', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'sets some of the matrix elements to s, according to the mask\n']
parseName: cv.Mat.setTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::setTo namespace:cv classpath:Mat classname:Mat name:setTo
register (method) setTo in cv::Mat

--- Incoming ---
[   u'cv.Mat.reshape',
    u'Mat',
    ['/NW', '/C'],
    [[u'int', u'cn', '', []], [u'int', u'rows', u'0', []]],
    u'creates alternative matrix header for the same data, with different\n']
parseName: cv.Mat.reshape with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::reshape namespace:cv classpath:Mat classname:Mat name:reshape
register (method) reshape in cv::Mat

--- Incoming ---
[   u'cv.Mat.reshape',
    u'Mat',
    ['/NW', '/C'],
    [   [u'int', u'cn', '', []],
        [u'int', u'newndims', '', []],
        [u'const int*', u'newsz', '', []]],
    '']
parseName: cv.Mat.reshape with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::reshape namespace:cv classpath:Mat classname:Mat name:reshape
register (method) reshape in cv::Mat

--- Incoming ---
[   u'cv.Mat.t',
    u'MatExpr',
    ['/NW', '/C'],
    [],
    u'matrix transposition by means of matrix expressions\n']
parseName: cv.Mat.t with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::t namespace:cv classpath:Mat classname:Mat name:t
Registering an unknown type: MatExpr
register (method) t in cv::Mat

--- Incoming ---
[   u'cv.Mat.inv',
    u'MatExpr',
    ['/NW', '/C'],
    [[u'int', u'method', u'DECOMP_LU', []]],
    u'matrix inversion by means of matrix expressions\n']
parseName: cv.Mat.inv with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::inv namespace:cv classpath:Mat classname:Mat name:inv
register (method) inv in cv::Mat

--- Incoming ---
[   u'cv.Mat.mul',
    u'MatExpr',
    ['/NW', '/C'],
    [[u'InputArray', u'm', '', []], [u'double', u'scale', u'1', []]],
    u'per-element matrix multiplication by means of matrix expressions\n']
parseName: cv.Mat.mul with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::mul namespace:cv classpath:Mat classname:Mat name:mul
register (method) mul in cv::Mat

--- Incoming ---
[   u'cv.Mat.cross',
    u'Mat',
    ['/NW', '/C'],
    [[u'InputArray', u'm', '', []]],
    u'computes cross-product of 2 3D vectors\n']
parseName: cv.Mat.cross with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::cross namespace:cv classpath:Mat classname:Mat name:cross
register (method) cross in cv::Mat

--- Incoming ---
[   u'cv.Mat.dot',
    u'double',
    ['/NW', '/C'],
    [[u'InputArray', u'm', '', []]],
    u'computes dot-product\n']
parseName: cv.Mat.dot with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::dot namespace:cv classpath:Mat classname:Mat name:dot
register (method) dot in cv::Mat

--- Incoming ---
[   u'cv.Mat.zeros',
    u'MatExpr',
    ['/NW', '/S'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []]],
    u'Matlab-style matrix initialization\n']
parseName: cv.Mat.zeros with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::zeros namespace:cv classpath:Mat classname:Mat name:zeros
register (method) zeros in cv::Mat

--- Incoming ---
[   u'cv.Mat.zeros',
    u'MatExpr',
    ['/NW', '/S'],
    [[u'Size', u'size', '', []], [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.zeros with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::zeros namespace:cv classpath:Mat classname:Mat name:zeros
register (method) zeros in cv::Mat

--- Incoming ---
[   u'cv.Mat.zeros',
    u'MatExpr',
    ['/NW', '/S'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sz', '', []],
        [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.zeros with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::zeros namespace:cv classpath:Mat classname:Mat name:zeros
register (method) zeros in cv::Mat

--- Incoming ---
[   u'cv.Mat.ones',
    u'MatExpr',
    ['/NW', '/S'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.ones with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ones namespace:cv classpath:Mat classname:Mat name:ones
register (method) ones in cv::Mat

--- Incoming ---
[   u'cv.Mat.ones',
    u'MatExpr',
    ['/NW', '/S'],
    [[u'Size', u'size', '', []], [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.ones with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ones namespace:cv classpath:Mat classname:Mat name:ones
register (method) ones in cv::Mat

--- Incoming ---
[   u'cv.Mat.ones',
    u'MatExpr',
    ['/NW', '/S'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sz', '', []],
        [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.ones with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ones namespace:cv classpath:Mat classname:Mat name:ones
register (method) ones in cv::Mat

--- Incoming ---
[   u'cv.Mat.eye',
    u'MatExpr',
    ['/NW', '/S'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.eye with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::eye namespace:cv classpath:Mat classname:Mat name:eye
register (method) eye in cv::Mat

--- Incoming ---
[   u'cv.Mat.eye',
    u'MatExpr',
    ['/NW', '/S'],
    [[u'Size', u'size', '', []], [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.eye with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::eye namespace:cv classpath:Mat classname:Mat name:eye
register (method) eye in cv::Mat

--- Incoming ---
[   u'cv.Mat.create',
    u'void',
    ['/NW'],
    [   [u'int', u'rows', '', []],
        [u'int', u'cols', '', []],
        [u'int', u'type', '', []]],
    u'allocates new matrix data unless the matrix already has specified size and type.\n']
parseName: cv.Mat.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::create namespace:cv classpath:Mat classname:Mat name:create
register (method) create in cv::Mat

--- Incoming ---
[   u'cv.Mat.create',
    u'void',
    ['/NW'],
    [[u'Size', u'size', '', []], [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::create namespace:cv classpath:Mat classname:Mat name:create
register (method) create in cv::Mat

--- Incoming ---
[   u'cv.Mat.create',
    u'void',
    ['/NW'],
    [   [u'int', u'ndims', '', []],
        [u'const int*', u'sizes', '', []],
        [u'int', u'type', '', []]],
    '']
parseName: cv.Mat.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::create namespace:cv classpath:Mat classname:Mat name:create
register (method) create in cv::Mat

--- Incoming ---
[   u'cv.Mat.addref',
    u'void',
    ['/NW'],
    [],
    u'increases the reference counter; use with care to avoid memleaks\n']
parseName: cv.Mat.addref with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::addref namespace:cv classpath:Mat classname:Mat name:addref
register (method) addref in cv::Mat

--- Incoming ---
[u'cv.Mat.release', u'void', ['/NW'], [], u'decreases reference counter;\n']
parseName: cv.Mat.release with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::release namespace:cv classpath:Mat classname:Mat name:release
register (method) release in cv::Mat

--- Incoming ---
[u'cv.Mat.deallocate', u'void', ['/NW'], [], u'deallocates the matrix data\n']
parseName: cv.Mat.deallocate with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::deallocate namespace:cv classpath:Mat classname:Mat name:deallocate
register (method) deallocate in cv::Mat

--- Incoming ---
[   u'cv.Mat.copySize',
    u'void',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    u'internal use function; properly re-allocates _size, _step arrays\n']
parseName: cv.Mat.copySize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::copySize namespace:cv classpath:Mat classname:Mat name:copySize
register (method) copySize in cv::Mat

--- Incoming ---
[   u'cv.Mat.reserve',
    u'void',
    ['/NW'],
    [[u'size_t', u'sz', '', []]],
    u'reserves enough space to fit sz hyper-planes\n']
parseName: cv.Mat.reserve with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::reserve namespace:cv classpath:Mat classname:Mat name:reserve
register (method) reserve in cv::Mat

--- Incoming ---
[   u'cv.Mat.resize',
    u'void',
    ['/NW'],
    [[u'size_t', u'sz', '', []]],
    u'resizes matrix to the specified number of hyper-planes\n']
parseName: cv.Mat.resize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::resize namespace:cv classpath:Mat classname:Mat name:resize
register (method) resize in cv::Mat

--- Incoming ---
[   u'cv.Mat.resize',
    u'void',
    ['/NW'],
    [[u'size_t', u'sz', '', []], [u'const Scalar&', u's', '', []]],
    u'resizes matrix to the specified number of hyper-planes; initializes the newly added elements\n']
parseName: cv.Mat.resize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::resize namespace:cv classpath:Mat classname:Mat name:resize
register (method) resize in cv::Mat

--- Incoming ---
[   u'cv.Mat.push_back_',
    u'void',
    ['/NW'],
    [[u'const void*', u'elem', '', []]],
    u'internal function\n']
parseName: cv.Mat.push_back_ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::push_back_ namespace:cv classpath:Mat classname:Mat name:push_back_
register (method) push_back_ in cv::Mat

--- Incoming ---
[u'cv.Mat.push_back', u'void', ['/NW'], [[u'const Mat&', u'm', '', []]], '']
parseName: cv.Mat.push_back with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::push_back namespace:cv classpath:Mat classname:Mat name:push_back
register (method) push_back in cv::Mat

--- Incoming ---
[   u'cv.Mat.pop_back',
    u'void',
    ['/NW'],
    [[u'size_t', u'nelems', u'1', []]],
    u'removes several hyper-planes from bottom of the matrix\n']
parseName: cv.Mat.pop_back with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::pop_back namespace:cv classpath:Mat classname:Mat name:pop_back
register (method) pop_back in cv::Mat

--- Incoming ---
[   u'cv.Mat.locateROI',
    u'void',
    ['/NW', '/C'],
    [[u'Size&', u'wholeSize', '', []], [u'Point&', u'ofs', '', []]],
    u'locates matrix header within a parent matrix. See below\n']
parseName: cv.Mat.locateROI with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::locateROI namespace:cv classpath:Mat classname:Mat name:locateROI
register (method) locateROI in cv::Mat

--- Incoming ---
[   u'cv.Mat.adjustROI',
    u'Mat&',
    ['/NW'],
    [   [u'int', u'dtop', '', []],
        [u'int', u'dbottom', '', []],
        [u'int', u'dleft', '', []],
        [u'int', u'dright', '', []]],
    u'moves/resizes the current matrix ROI inside the parent matrix.\n']
parseName: cv.Mat.adjustROI with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::adjustROI namespace:cv classpath:Mat classname:Mat name:adjustROI
register (method) adjustROI in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator ()',
    u'Mat',
    ['/NW', '/C'],
    [[u'Range', u'rowRange', '', []], [u'Range', u'colRange', '', []]],
    u'extracts a rectangular sub-matrix\n']
parseName: cv.Mat.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator () namespace:cv classpath:Mat classname:Mat name:operator ()
ignore (method) operator () in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator ()',
    u'Mat',
    ['/NW', '/C'],
    [[u'const Rect&', u'roi', '', []]],
    '']
parseName: cv.Mat.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator () namespace:cv classpath:Mat classname:Mat name:operator ()
ignore (method) operator () in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator ()',
    u'Mat',
    ['/NW', '/C'],
    [[u'const Range*', u'ranges', '', []]],
    '']
parseName: cv.Mat.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator () namespace:cv classpath:Mat classname:Mat name:operator ()
ignore (method) operator () in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator CvMat',
    u'',
    ['/NW', '/C'],
    [],
    u'converts header to CvMat; no data is copied\n']
parseName: cv.Mat.operator CvMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator CvMat namespace:cv classpath:Mat classname:Mat name:operator CvMat
ignore (method) operator CvMat in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator CvMatND',
    u'',
    ['/NW', '/C'],
    [],
    u'converts header to CvMatND; no data is copied\n']
parseName: cv.Mat.operator CvMatND with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator CvMatND namespace:cv classpath:Mat classname:Mat name:operator CvMatND
ignore (method) operator CvMatND in cv::Mat

--- Incoming ---
[   u'cv.Mat.operator IplImage',
    u'',
    ['/NW', '/C'],
    [],
    u'converts header to IplImage; no data is copied\n']
parseName: cv.Mat.operator IplImage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::operator IplImage namespace:cv classpath:Mat classname:Mat name:operator IplImage
ignore (method) operator IplImage in cv::Mat

--- Incoming ---
[   u'cv.Mat.isContinuous',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true iff the matrix data is continuous\n']
parseName: cv.Mat.isContinuous with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::isContinuous namespace:cv classpath:Mat classname:Mat name:isContinuous
register (method) isContinuous in cv::Mat

--- Incoming ---
[   u'cv.Mat.isSubmatrix',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the matrix is a submatrix of another matrix\n']
parseName: cv.Mat.isSubmatrix with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::isSubmatrix namespace:cv classpath:Mat classname:Mat name:isSubmatrix
register (method) isSubmatrix in cv::Mat

--- Incoming ---
[   u'cv.Mat.elemSize',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns element size in bytes,\n']
parseName: cv.Mat.elemSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::elemSize namespace:cv classpath:Mat classname:Mat name:elemSize
register (method) elemSize in cv::Mat

--- Incoming ---
[   u'cv.Mat.elemSize1',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns the size of element channel in bytes.\n']
parseName: cv.Mat.elemSize1 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::elemSize1 namespace:cv classpath:Mat classname:Mat name:elemSize1
register (method) elemSize1 in cv::Mat

--- Incoming ---
[   u'cv.Mat.type',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns element type, similar to CV_MAT_TYPE(cvmat->type)\n']
parseName: cv.Mat.type with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::type namespace:cv classpath:Mat classname:Mat name:type
register (method) type in cv::Mat

--- Incoming ---
[   u'cv.Mat.depth',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns element type, similar to CV_MAT_DEPTH(cvmat->type)\n']
parseName: cv.Mat.depth with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::depth namespace:cv classpath:Mat classname:Mat name:depth
register (method) depth in cv::Mat

--- Incoming ---
[   u'cv.Mat.channels',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns element type, similar to CV_MAT_CN(cvmat->type)\n']
parseName: cv.Mat.channels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::channels namespace:cv classpath:Mat classname:Mat name:channels
register (method) channels in cv::Mat

--- Incoming ---
[   u'cv.Mat.step1',
    u'size_t',
    ['/NW', '/C'],
    [[u'int', u'i', u'0', []]],
    u'returns step/elemSize1()\n']
parseName: cv.Mat.step1 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::step1 namespace:cv classpath:Mat classname:Mat name:step1
register (method) step1 in cv::Mat

--- Incoming ---
[   u'cv.Mat.empty',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if matrix data is NULL\n']
parseName: cv.Mat.empty with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::empty namespace:cv classpath:Mat classname:Mat name:empty
register (method) empty in cv::Mat

--- Incoming ---
[   u'cv.Mat.total',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns the total number of matrix elements\n']
parseName: cv.Mat.total with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::total namespace:cv classpath:Mat classname:Mat name:total
register (method) total in cv::Mat

--- Incoming ---
[   u'cv.Mat.checkVector',
    u'int',
    ['/NW', '/C'],
    [   [u'int', u'elemChannels', '', []],
        [u'int', u'depth', u'-1', []],
        [u'bool', u'requireContinuous', u'true', []]],
    u'returns N if the matrix is 1-channel (N x ptdim) or ptdim-channel (1 x N) or (N x 1); negative number otherwise\n']
parseName: cv.Mat.checkVector with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::checkVector namespace:cv classpath:Mat classname:Mat name:checkVector
register (method) checkVector in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'uchar*',
    ['/NW'],
    [[u'int', u'i0', u'0', []]],
    u'returns pointer to i0-th submatrix along the dimension #0\n']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'const uchar*',
    ['/NW', '/C'],
    [[u'int', u'i0', u'0', []]],
    '']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'uchar*',
    ['/NW'],
    [[u'int', u'i0', '', []], [u'int', u'i1', '', []]],
    u'returns pointer to (i0,i1) submatrix along the dimensions #0 and #1\n']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'const uchar*',
    ['/NW', '/C'],
    [[u'int', u'i0', '', []], [u'int', u'i1', '', []]],
    '']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'uchar*',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'int', u'i2', '', []]],
    u'returns pointer to (i0,i1,i3) submatrix along the dimensions #0, #1, #2\n']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'const uchar*',
    ['/NW', '/C'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'int', u'i2', '', []]],
    '']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'uchar*',
    ['/NW'],
    [[u'const int*', u'idx', '', []]],
    u'returns pointer to the matrix element\n']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[   u'cv.Mat.ptr',
    u'const uchar*',
    ['/NW', '/C'],
    [[u'const int*', u'idx', '', []]],
    u'returns read-only pointer to the matrix element\n']
parseName: cv.Mat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::ptr namespace:cv classpath:Mat classname:Mat name:ptr
register (method) ptr in cv::Mat

--- Incoming ---
[u'const cv.Mat.MAGIC_VAL', u'0x42FF0000', [], []]
parseName: const cv.Mat.MAGIC_VAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MAGIC_VAL namespace:cv classpath:Mat classname:Mat name:MAGIC_VAL

--- Incoming ---
[u'const cv.Mat.AUTO_STEP', u'0', [], []]
parseName: const cv.Mat.AUTO_STEP with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::AUTO_STEP namespace:cv classpath:Mat classname:Mat name:AUTO_STEP

--- Incoming ---
[u'const cv.Mat.CONTINUOUS_FLAG', u'CV_MAT_CONT_FLAG', [], []]
parseName: const cv.Mat.CONTINUOUS_FLAG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::CONTINUOUS_FLAG namespace:cv classpath:Mat classname:Mat name:CONTINUOUS_FLAG

--- Incoming ---
[u'const cv.Mat.SUBMATRIX_FLAG', u'CV_SUBMAT_FLAG', [], []]
parseName: const cv.Mat.SUBMATRIX_FLAG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::SUBMATRIX_FLAG namespace:cv classpath:Mat classname:Mat name:SUBMATRIX_FLAG

--- Incoming ---
[u'struct cv.Mat.MSize', '', [], [], '']
parseName: struct cv.Mat.MSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize namespace:cv classpath:Mat classname:Mat name:MSize
register class cv::Mat::MSize ([u'struct cv.Mat.MSize', '', [], [], '']) [ignored]

--- Incoming ---
[u'cv.Mat.MSize.MSize', u'', ['/NW'], [[u'int*', u'_p', '', []]], '']
parseName: cv.Mat.MSize.MSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::MSize namespace:cv classpath:Mat::MSize classname:MSize name:MSize
register (constructor) new in cv::Mat::MSize

--- Incoming ---
[u'cv.Mat.MSize.operator ()', u'Size', ['/NW', '/C'], [], '']
parseName: cv.Mat.MSize.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator () namespace:cv classpath:Mat::MSize classname:MSize name:operator ()
ignore (method) operator () in cv::Mat::MSize

--- Incoming ---
[   u'cv.Mat.MSize.operator[]',
    u'const int&',
    ['/NW', '/C'],
    [[u'int', u'i', '', []]],
    '']
parseName: cv.Mat.MSize.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator[] namespace:cv classpath:Mat::MSize classname:MSize name:operator[]
ignore (method) operator[] in cv::Mat::MSize

--- Incoming ---
[u'cv.Mat.MSize.operator[]', u'int&', ['/NW'], [[u'int', u'i', '', []]], '']
parseName: cv.Mat.MSize.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator[] namespace:cv classpath:Mat::MSize classname:MSize name:operator[]
ignore (method) operator[] in cv::Mat::MSize

--- Incoming ---
[u'cv.Mat.MSize.operator const int*', u'operator const', ['/NW', '/C'], [], '']
parseName: cv.Mat.MSize.operator const int* with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator int* namespace:cv classpath:Mat::MSize classname:MSize name:operator int*
Registering an unknown type: operator const
ignore (method) operator int* in cv::Mat::MSize

--- Incoming ---
[   u'cv.Mat.MSize.operator ==',
    u'bool',
    ['/NW', '/C'],
    [[u'const MSize&', u'sz', '', []]],
    '']
parseName: cv.Mat.MSize.operator == with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator == namespace:cv classpath:Mat::MSize classname:MSize name:operator ==
ignore (method) operator == in cv::Mat::MSize

--- Incoming ---
[   u'cv.Mat.MSize.operator !=',
    u'bool',
    ['/NW', '/C'],
    [[u'const MSize&', u'sz', '', []]],
    '']
parseName: cv.Mat.MSize.operator != with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MSize::operator != namespace:cv classpath:Mat::MSize classname:MSize name:operator !=
ignore (method) operator != in cv::Mat::MSize

--- Incoming ---
[u'struct cv.Mat.MStep', '', [], [], '']
parseName: struct cv.Mat.MStep with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep namespace:cv classpath:Mat classname:Mat name:MStep
register class cv::Mat::MStep ([u'struct cv.Mat.MStep', '', [], [], '']) [ignored]

--- Incoming ---
[u'cv.Mat.MStep.MStep', u'', ['/NW'], [], '']
parseName: cv.Mat.MStep.MStep with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::MStep namespace:cv classpath:Mat::MStep classname:MStep name:MStep
register (constructor) new in cv::Mat::MStep

--- Incoming ---
[u'cv.Mat.MStep.MStep', u'', ['/NW'], [[u'size_t', u's', '', []]], '']
parseName: cv.Mat.MStep.MStep with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::MStep namespace:cv classpath:Mat::MStep classname:MStep name:MStep
register (constructor) new in cv::Mat::MStep

--- Incoming ---
[   u'cv.Mat.MStep.operator[]',
    u'const size_t&',
    ['/NW', '/C'],
    [[u'int', u'i', '', []]],
    '']
parseName: cv.Mat.MStep.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::operator[] namespace:cv classpath:Mat::MStep classname:MStep name:operator[]
ignore (method) operator[] in cv::Mat::MStep

--- Incoming ---
[u'cv.Mat.MStep.operator[]', u'size_t&', ['/NW'], [[u'int', u'i', '', []]], '']
parseName: cv.Mat.MStep.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::operator[] namespace:cv classpath:Mat::MStep classname:MStep name:operator[]
ignore (method) operator[] in cv::Mat::MStep

--- Incoming ---
[u'cv.Mat.MStep.operator size_t', u'', ['/NW', '/C'], [], '']
parseName: cv.Mat.MStep.operator size_t with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::operator size_t namespace:cv classpath:Mat::MStep classname:MStep name:operator size_t
ignore (method) operator size_t in cv::Mat::MStep

--- Incoming ---
[   u'cv.Mat.MStep.operator =',
    u'MStep&',
    ['/NW'],
    [[u'size_t', u's', '', []]],
    '']
parseName: cv.Mat.MStep.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::operator = namespace:cv classpath:Mat::MStep classname:MStep name:operator =
ignore (method) operator = in cv::Mat::MStep

--- Incoming ---
[   u'cv.Mat.MStep.operator =',
    u'MStep&',
    ['/NW', '/H'],
    [[u'const MStep&', u'', '', []]],
    '']
parseName: cv.Mat.MStep.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::MStep::operator = namespace:cv classpath:Mat::MStep classname:MStep name:operator =
ignore (method) operator = in cv::Mat::MStep

--- Incoming ---
[u'cv.Mat.initEmpty', u'void', ['/NW', '/H'], [], '']
parseName: cv.Mat.initEmpty with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::initEmpty namespace:cv classpath:Mat classname:Mat name:initEmpty

--- Incoming ---
[   u'class cv.RNG',
    '',
    [],
    [],
    u'Random Number Generator\n\nThe class implements RNG using Multiply-with-Carry algorithm\n']
parseName: class cv.RNG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG namespace:cv classpath: classname: name:RNG
register class cv::RNG ([u'class cv.RNG', '', [], [], u'Random Number Generator\n\nThe class implements RNG using Multiply-with-Carry algorithm\n']) [ignored]

--- Incoming ---
[u'const cv.RNG.UNIFORM', u'0', [], []]
parseName: const cv.RNG.UNIFORM with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::UNIFORM namespace:cv classpath:RNG classname:RNG name:UNIFORM

--- Incoming ---
[u'const cv.RNG.NORMAL', u'1', [], []]
parseName: const cv.RNG.NORMAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::NORMAL namespace:cv classpath:RNG classname:RNG name:NORMAL

--- Incoming ---
[u'cv.RNG.RNG', u'', ['/NW'], [], '']
parseName: cv.RNG.RNG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::RNG namespace:cv classpath:RNG classname:RNG name:RNG
register (constructor) new in cv::RNG

--- Incoming ---
[u'cv.RNG.RNG', u'', ['/NW'], [[u'uint64', u'state', '', []]], '']
parseName: cv.RNG.RNG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::RNG namespace:cv classpath:RNG classname:RNG name:RNG
Registering an unknown type: uint64
register (constructor) new in cv::RNG

--- Incoming ---
[   u'cv.RNG.next',
    u'unsigned',
    ['/NW'],
    [],
    u'updates the state and returns the next 32-bit unsigned integer random number\n']
parseName: cv.RNG.next with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::next namespace:cv classpath:RNG classname:RNG name:next
register (method) next in cv::RNG

--- Incoming ---
[u'cv.RNG.operator uchar', u'', ['/NW'], [], '']
parseName: cv.RNG.operator uchar with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator uchar namespace:cv classpath:RNG classname:RNG name:operator uchar
ignore (method) operator uchar in cv::RNG

--- Incoming ---
[u'cv.RNG.operator schar', u'', ['/NW'], [], '']
parseName: cv.RNG.operator schar with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator schar namespace:cv classpath:RNG classname:RNG name:operator schar
ignore (method) operator schar in cv::RNG

--- Incoming ---
[u'cv.RNG.operator ushort', u'', ['/NW'], [], '']
parseName: cv.RNG.operator ushort with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator ushort namespace:cv classpath:RNG classname:RNG name:operator ushort
ignore (method) operator ushort in cv::RNG

--- Incoming ---
[u'cv.RNG.operator short', u'', ['/NW'], [], '']
parseName: cv.RNG.operator short with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator short namespace:cv classpath:RNG classname:RNG name:operator short
ignore (method) operator short in cv::RNG

--- Incoming ---
[u'cv.RNG.operator unsigned', u'', ['/NW'], [], '']
parseName: cv.RNG.operator unsigned with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator unsigned namespace:cv classpath:RNG classname:RNG name:operator unsigned
ignore (method) operator unsigned in cv::RNG

--- Incoming ---
[   u'cv.RNG.operator ()',
    u'unsigned',
    ['/NW'],
    [[u'unsigned', u'N', '', []]],
    u'returns a random integer sampled uniformly from [0, N).\n']
parseName: cv.RNG.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator () namespace:cv classpath:RNG classname:RNG name:operator ()
ignore (method) operator () in cv::RNG

--- Incoming ---
[u'cv.RNG.operator ()', u'unsigned', ['/NW'], [], '']
parseName: cv.RNG.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator () namespace:cv classpath:RNG classname:RNG name:operator ()
ignore (method) operator () in cv::RNG

--- Incoming ---
[u'cv.RNG.operator int', u'', ['/NW'], [], '']
parseName: cv.RNG.operator int with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator int namespace:cv classpath:RNG classname:RNG name:operator int
ignore (method) operator int in cv::RNG

--- Incoming ---
[u'cv.RNG.operator float', u'', ['/NW'], [], '']
parseName: cv.RNG.operator float with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator float namespace:cv classpath:RNG classname:RNG name:operator float
ignore (method) operator float in cv::RNG

--- Incoming ---
[u'cv.RNG.operator double', u'', ['/NW'], [], '']
parseName: cv.RNG.operator double with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::operator double namespace:cv classpath:RNG classname:RNG name:operator double
ignore (method) operator double in cv::RNG

--- Incoming ---
[   u'cv.RNG.uniform',
    u'int',
    ['/NW'],
    [[u'int', u'a', '', []], [u'int', u'b', '', []]],
    u'returns uniformly distributed integer random number from [a,b) range\n']
parseName: cv.RNG.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::uniform namespace:cv classpath:RNG classname:RNG name:uniform
register (method) uniform in cv::RNG

--- Incoming ---
[   u'cv.RNG.uniform',
    u'float',
    ['/NW'],
    [[u'float', u'a', '', []], [u'float', u'b', '', []]],
    u'returns uniformly distributed floating-point random number from [a,b) range\n']
parseName: cv.RNG.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::uniform namespace:cv classpath:RNG classname:RNG name:uniform
register (method) uniform in cv::RNG

--- Incoming ---
[   u'cv.RNG.uniform',
    u'double',
    ['/NW'],
    [[u'double', u'a', '', []], [u'double', u'b', '', []]],
    u'returns uniformly distributed double-precision floating-point random number from [a,b) range\n']
parseName: cv.RNG.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::uniform namespace:cv classpath:RNG classname:RNG name:uniform
register (method) uniform in cv::RNG

--- Incoming ---
[   u'cv.RNG.fill',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'mat', '', []],
        [u'int', u'distType', '', []],
        [u'InputArray', u'a', '', []],
        [u'InputArray', u'b', '', []],
        [u'bool', u'saturateRange', u'false', []]],
    '']
parseName: cv.RNG.fill with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::fill namespace:cv classpath:RNG classname:RNG name:fill
Registering an unknown type: InputOutputArray
register (method) fill in cv::RNG

--- Incoming ---
[   u'cv.RNG.gaussian',
    u'double',
    ['/NW'],
    [[u'double', u'sigma', '', []]],
    u'returns Gaussian random variate with mean zero.\n']
parseName: cv.RNG.gaussian with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG::gaussian namespace:cv classpath:RNG classname:RNG name:gaussian
register (method) gaussian in cv::RNG

--- Incoming ---
[   u'class cv.RNG_MT19937',
    '',
    [],
    [],
    u'Random Number Generator - MT\n\nThe class implements RNG using the Mersenne Twister algorithm\n']
parseName: class cv.RNG_MT19937 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937 namespace:cv classpath: classname: name:RNG_MT19937
register class cv::RNG_MT19937 ([u'class cv.RNG_MT19937', '', [], [], u'Random Number Generator - MT\n\nThe class implements RNG using the Mersenne Twister algorithm\n']) [ignored]

--- Incoming ---
[u'cv.RNG_MT19937.RNG_MT19937', u'', ['/NW'], [], '']
parseName: cv.RNG_MT19937.RNG_MT19937 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::RNG_MT19937 namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:RNG_MT19937
register (constructor) new in cv::RNG_MT19937

--- Incoming ---
[   u'cv.RNG_MT19937.RNG_MT19937',
    u'',
    ['/NW'],
    [[u'unsigned', u's', '', []]],
    '']
parseName: cv.RNG_MT19937.RNG_MT19937 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::RNG_MT19937 namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:RNG_MT19937
register (constructor) new in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.seed', u'void', ['/NW'], [[u'unsigned', u's', '', []]], '']
parseName: cv.RNG_MT19937.seed with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::seed namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:seed
register (method) seed in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.next', u'unsigned', ['/NW'], [], '']
parseName: cv.RNG_MT19937.next with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::next namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:next
register (method) next in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.operator int', u'', ['/NW'], [], '']
parseName: cv.RNG_MT19937.operator int with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator int namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator int
ignore (method) operator int in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.operator unsigned', u'', ['/NW'], [], '']
parseName: cv.RNG_MT19937.operator unsigned with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator unsigned namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator unsigned
ignore (method) operator unsigned in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.operator float', u'', ['/NW'], [], '']
parseName: cv.RNG_MT19937.operator float with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator float namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator float
ignore (method) operator float in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.operator double', u'', ['/NW'], [], '']
parseName: cv.RNG_MT19937.operator double with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator double namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator double
ignore (method) operator double in cv::RNG_MT19937

--- Incoming ---
[   u'cv.RNG_MT19937.operator ()',
    u'unsigned',
    ['/NW'],
    [[u'unsigned', u'N', '', []]],
    '']
parseName: cv.RNG_MT19937.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator () namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator ()
ignore (method) operator () in cv::RNG_MT19937

--- Incoming ---
[u'cv.RNG_MT19937.operator ()', u'unsigned', ['/NW'], [], '']
parseName: cv.RNG_MT19937.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::operator () namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:operator ()
ignore (method) operator () in cv::RNG_MT19937

--- Incoming ---
[   u'cv.RNG_MT19937.uniform',
    u'int',
    ['/NW'],
    [[u'int', u'a', '', []], [u'int', u'b', '', []]],
    u'returns uniformly distributed integer random number from [a,b) range\n']
parseName: cv.RNG_MT19937.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::uniform namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:uniform
register (method) uniform in cv::RNG_MT19937

--- Incoming ---
[   u'cv.RNG_MT19937.uniform',
    u'float',
    ['/NW'],
    [[u'float', u'a', '', []], [u'float', u'b', '', []]],
    u'returns uniformly distributed floating-point random number from [a,b) range\n']
parseName: cv.RNG_MT19937.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::uniform namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:uniform
register (method) uniform in cv::RNG_MT19937

--- Incoming ---
[   u'cv.RNG_MT19937.uniform',
    u'double',
    ['/NW'],
    [[u'double', u'a', '', []], [u'double', u'b', '', []]],
    u'returns uniformly distributed double-precision floating-point random number from [a,b) range\n']
parseName: cv.RNG_MT19937.uniform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::RNG_MT19937::uniform namespace:cv classpath:RNG_MT19937 classname:RNG_MT19937 name:uniform
register (method) uniform in cv::RNG_MT19937

--- Incoming ---
[   u'class cv.TermCriteria',
    '',
    [],
    [],
    u'Termination criteria in iterative algorithms\n']
parseName: class cv.TermCriteria with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria namespace:cv classpath: classname: name:TermCriteria
register class cv::TermCriteria ([u'class cv.TermCriteria', '', [], [], u'Termination criteria in iterative algorithms\n'])

--- Incoming ---
[u'const cv.TermCriteria.COUNT', u'1', [], []]
parseName: const cv.TermCriteria.COUNT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::COUNT namespace:cv classpath:TermCriteria classname:TermCriteria name:COUNT

--- Incoming ---
[u'const cv.TermCriteria.MAX_ITER', u'COUNT', [], []]
parseName: const cv.TermCriteria.MAX_ITER with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::MAX_ITER namespace:cv classpath:TermCriteria classname:TermCriteria name:MAX_ITER

--- Incoming ---
[u'const cv.TermCriteria.EPS', u'2', [], []]
parseName: const cv.TermCriteria.EPS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::EPS namespace:cv classpath:TermCriteria classname:TermCriteria name:EPS

--- Incoming ---
[u'cv.TermCriteria.TermCriteria', u'', ['/NW'], [], u'default constructor\n']
parseName: cv.TermCriteria.TermCriteria with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::TermCriteria namespace:cv classpath:TermCriteria classname:TermCriteria name:TermCriteria
register (constructor) new in cv::TermCriteria

--- Incoming ---
[   u'cv.TermCriteria.TermCriteria',
    u'',
    ['/NW'],
    [   [u'int', u'type', '', []],
        [u'int', u'maxCount', '', []],
        [u'double', u'epsilon', '', []]],
    u'full constructor\n']
parseName: cv.TermCriteria.TermCriteria with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::TermCriteria namespace:cv classpath:TermCriteria classname:TermCriteria name:TermCriteria
register (constructor) new in cv::TermCriteria

--- Incoming ---
[   u'cv.TermCriteria.TermCriteria',
    u'',
    ['/NW'],
    [[u'const CvTermCriteria&', u'criteria', '', []]],
    u'conversion from CvTermCriteria\n']
parseName: cv.TermCriteria.TermCriteria with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::TermCriteria namespace:cv classpath:TermCriteria classname:TermCriteria name:TermCriteria
register (constructor) new in cv::TermCriteria

--- Incoming ---
[   u'cv.TermCriteria.operator CvTermCriteria',
    u'',
    ['/NW', '/C'],
    [],
    u'conversion to CvTermCriteria\n']
parseName: cv.TermCriteria.operator CvTermCriteria with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TermCriteria::operator CvTermCriteria namespace:cv classpath:TermCriteria classname:TermCriteria name:operator CvTermCriteria
ignore (method) operator CvTermCriteria in cv::TermCriteria

--- Incoming ---
[   u'cv.getConvertFunc',
    u'BinaryFunc',
    ['/NW'],
    [[u'int', u'sdepth', '', []], [u'int', u'ddepth', '', []]],
    '']
parseName: cv.getConvertFunc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getConvertFunc namespace:cv classpath: classname: name:getConvertFunc
Registering an unknown type: BinaryFunc
register (function) getConvertFunc

--- Incoming ---
[   u'cv.getConvertScaleFunc',
    u'BinaryFunc',
    ['/NW'],
    [[u'int', u'sdepth', '', []], [u'int', u'ddepth', '', []]],
    '']
parseName: cv.getConvertScaleFunc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getConvertScaleFunc namespace:cv classpath: classname: name:getConvertScaleFunc
register (function) getConvertScaleFunc

--- Incoming ---
[   u'cv.getCopyMaskFunc',
    u'BinaryFunc',
    ['/NW'],
    [[u'size_t', u'esz', '', []]],
    '']
parseName: cv.getCopyMaskFunc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getCopyMaskFunc namespace:cv classpath: classname: name:getCopyMaskFunc
register (function) getCopyMaskFunc

--- Incoming ---
[   u'cv.swap',
    u'void',
    ['/NW'],
    [[u'Mat&', u'a', '', []], [u'Mat&', u'b', '', []]],
    u'swaps two matrices\n']
parseName: cv.swap with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::swap namespace:cv classpath: classname: name:swap
register (function) swap

--- Incoming ---
[   u'cv.cvarrToMat',
    u'Mat',
    ['/NW'],
    [   [u'const CvArr*', u'arr', '', []],
        [u'bool', u'copyData', u'false', []],
        [u'bool', u'allowND', u'true', []],
        [u'int', u'coiMode', u'0', []]],
    u'converts array (CvMat or IplImage) to cv::Mat\n']
parseName: cv.cvarrToMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::cvarrToMat namespace:cv classpath: classname: name:cvarrToMat
Registering an unknown type: CvArr
register (function) cvarrToMat

--- Incoming ---
[   u'cv.extractImageCOI',
    u'void',
    ['/NW'],
    [   [u'const CvArr*', u'arr', '', []],
        [u'OutputArray', u'coiimg', '', []],
        [u'int', u'coi', u'-1', []]],
    u'extracts Channel of Interest from CvMat or IplImage and makes cv::Mat out of it.\n']
parseName: cv.extractImageCOI with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::extractImageCOI namespace:cv classpath: classname: name:extractImageCOI
register (function) extractImageCOI

--- Incoming ---
[   u'cv.insertImageCOI',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'coiimg', '', []],
        [u'CvArr*', u'arr', '', []],
        [u'int', u'coi', u'-1', []]],
    u'inserts single-channel cv::Mat into a multi-channel CvMat or IplImage\n']
parseName: cv.insertImageCOI with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::insertImageCOI namespace:cv classpath: classname: name:insertImageCOI
Registering an unknown type: CvArr
register (function) insertImageCOI

--- Incoming ---
[   u'cv.add',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []],
        [u'int', u'dtype', u'-1', []]],
    u'adds one matrix to another (dst = src1 + src2)\n']
parseName: cv.add with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::add namespace:cv classpath: classname: name:add
register (function) add

--- Incoming ---
[   u'cv.subtract',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []],
        [u'int', u'dtype', u'-1', []]],
    u'subtracts one matrix from another (dst = src1 - src2)\n']
parseName: cv.subtract with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::subtract namespace:cv classpath: classname: name:subtract
register (function) subtract

--- Incoming ---
[   u'cv.multiply',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'computes element-wise weighted product of the two arrays (dst = scale*src1*src2)\n']
parseName: cv.multiply with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::multiply namespace:cv classpath: classname: name:multiply
register (function) multiply

--- Incoming ---
[   u'cv.divide',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'computes element-wise weighted quotient of the two arrays (dst = scale*src1/src2)\n']
parseName: cv.divide with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::divide namespace:cv classpath: classname: name:divide
register (function) divide

--- Incoming ---
[   u'cv.divide',
    u'void',
    ['/NW'],
    [   [u'double', u'scale', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'dtype', u'-1', []]],
    u'computes element-wise weighted reciprocal of an array (dst = scale/src2)\n']
parseName: cv.divide with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::divide namespace:cv classpath: classname: name:divide
register (function) divide

--- Incoming ---
[   u'cv.scaleAdd',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'double', u'alpha', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'adds scaled array to another one (dst = alpha*src1 + src2)\n']
parseName: cv.scaleAdd with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::scaleAdd namespace:cv classpath: classname: name:scaleAdd
register (function) scaleAdd

--- Incoming ---
[   u'cv.addWeighted',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'double', u'alpha', '', []],
        [u'InputArray', u'src2', '', []],
        [u'double', u'beta', '', []],
        [u'double', u'gamma', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'dtype', u'-1', []]],
    u'computes weighted sum of two arrays (dst = alpha*src1 + beta*src2 + gamma)\n']
parseName: cv.addWeighted with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::addWeighted namespace:cv classpath: classname: name:addWeighted
register (function) addWeighted

--- Incoming ---
[   u'cv.convertScaleAbs',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'scales array elements, computes absolute values and converts the results to 8-bit unsigned integers: dst(i)=saturate_cast<uchar>abs(src(i)*alpha+beta)\n']
parseName: cv.convertScaleAbs with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::convertScaleAbs namespace:cv classpath: classname: name:convertScaleAbs
register (function) convertScaleAbs

--- Incoming ---
[   u'cv.LUT',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'InputArray', u'lut', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'interpolation', u'0', []]],
    u'transforms array of numbers using a lookup table: dst(i)=lut(src(i))\n']
parseName: cv.LUT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LUT namespace:cv classpath: classname: name:LUT
register (function) LUT

--- Incoming ---
[   u'cv.sum',
    u'Scalar',
    ['/NW'],
    [[u'InputArray', u'src', '', []]],
    u'computes sum of array elements\n']
parseName: cv.sum with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::sum namespace:cv classpath: classname: name:sum
register (function) sum

--- Incoming ---
[   u'cv.countNonZero',
    u'int',
    ['/NW'],
    [[u'InputArray', u'src', '', []]],
    u'computes the number of nonzero array elements\n']
parseName: cv.countNonZero with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::countNonZero namespace:cv classpath: classname: name:countNonZero
register (function) countNonZero

--- Incoming ---
[   u'cv.findNonZero',
    u'void',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'idx', '', []]],
    u'returns the list of locations of non-zero pixels\n']
parseName: cv.findNonZero with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::findNonZero namespace:cv classpath: classname: name:findNonZero
register (function) findNonZero

--- Incoming ---
[   u'cv.mean',
    u'Scalar',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes mean value of selected array elements\n']
parseName: cv.mean with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mean namespace:cv classpath: classname: name:mean
register (function) mean

--- Incoming ---
[   u'cv.meanStdDev',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'mean', '', []],
        [u'OutputArray', u'stddev', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes mean value and standard deviation of all or selected array elements\n']
parseName: cv.meanStdDev with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::meanStdDev namespace:cv classpath: classname: name:meanStdDev
register (function) meanStdDev

--- Incoming ---
[   u'cv.norm',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes norm of the selected array part\n']
parseName: cv.norm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::norm namespace:cv classpath: classname: name:norm
register (function) norm

--- Incoming ---
[   u'cv.norm',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes norm of selected part of the difference between two arrays\n']
parseName: cv.norm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::norm namespace:cv classpath: classname: name:norm
register (function) norm

--- Incoming ---
[   u'cv.batchDistance',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dist', '', []],
        [u'int', u'dtype', '', []],
        [u'OutputArray', u'nidx', '', []],
        [u'int', u'normType', u'NORM_L2', []],
        [u'int', u'K', u'0', []],
        [u'InputArray', u'mask', u'noArray()', []],
        [u'int', u'update', u'0', []],
        [u'bool', u'crosscheck', u'false', []]],
    u'naive nearest neighbor finder\n']
parseName: cv.batchDistance with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::batchDistance namespace:cv classpath: classname: name:batchDistance
register (function) batchDistance

--- Incoming ---
[   u'cv.normalize',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []],
        [u'int', u'norm_type', u'NORM_L2', []],
        [u'int', u'dtype', u'-1', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values\n']
parseName: cv.normalize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::normalize namespace:cv classpath: classname: name:normalize
register (function) normalize

--- Incoming ---
[   u'cv.minMaxLoc',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'double*', u'minVal', '', []],
        [u'double*', u'maxVal', u'0', []],
        [u'Point*', u'minLoc', u'0', []],
        [u'Point*', u'maxLoc', u'0', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'finds global minimum and maximum array elements and returns their values and their locations\n']
parseName: cv.minMaxLoc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::minMaxLoc namespace:cv classpath: classname: name:minMaxLoc
register (function) minMaxLoc

--- Incoming ---
[   u'cv.minMaxIdx',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'double*', u'minVal', '', []],
        [u'double*', u'maxVal', '', []],
        [u'int*', u'minIdx', u'0', []],
        [u'int*', u'maxIdx', u'0', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    '']
parseName: cv.minMaxIdx with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::minMaxIdx namespace:cv classpath: classname: name:minMaxIdx
register (function) minMaxIdx

--- Incoming ---
[   u'cv.reduce',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'dim', '', []],
        [u'int', u'rtype', '', []],
        [u'int', u'dtype', u'-1', []]],
    u'transforms 2D matrix to 1D row or column vector by taking sum, minimum, maximum or mean value over all the rows\n']
parseName: cv.reduce with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::reduce namespace:cv classpath: classname: name:reduce
register (function) reduce

--- Incoming ---
[   u'cv.merge',
    u'void',
    ['/NW'],
    [   [u'const Mat*', u'mv', '', []],
        [u'size_t', u'count', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'makes multi-channel array out of several single-channel arrays\n']
parseName: cv.merge with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::merge namespace:cv classpath: classname: name:merge
register (function) merge

--- Incoming ---
[   u'cv.merge',
    u'void',
    ['/NW'],
    [[u'const vector<Mat>&', u'mv', '', []], [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.merge with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::merge namespace:cv classpath: classname: name:merge
register (function) merge

--- Incoming ---
[   u'cv.merge',
    u'void',
    ['/NW'],
    [[u'InputArrayOfArrays', u'mv', '', []], [u'OutputArray', u'dst', '', []]],
    u'makes multi-channel array out of several single-channel arrays\n']
parseName: cv.merge with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::merge namespace:cv classpath: classname: name:merge
Registering an unknown type: InputArrayOfArrays
register (function) merge

--- Incoming ---
[   u'cv.split',
    u'void',
    ['/NW'],
    [[u'const Mat&', u'src', '', []], [u'Mat*', u'mvbegin', '', []]],
    u'copies each plane of a multi-channel array to a dedicated array\n']
parseName: cv.split with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::split namespace:cv classpath: classname: name:split
register (function) split

--- Incoming ---
[   u'cv.split',
    u'void',
    ['/NW'],
    [[u'const Mat&', u'm', '', []], [u'vector<Mat>&', u'mv', '', []]],
    '']
parseName: cv.split with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::split namespace:cv classpath: classname: name:split
register (function) split

--- Incoming ---
[   u'cv.split',
    u'void',
    ['/NW'],
    [[u'InputArray', u'm', '', []], [u'OutputArrayOfArrays', u'mv', '', []]],
    u'copies each plane of a multi-channel array to a dedicated array\n']
parseName: cv.split with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::split namespace:cv classpath: classname: name:split
Registering an unknown type: OutputArrayOfArrays
register (function) split

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    ['/NW'],
    [   [u'const Mat*', u'src', '', []],
        [u'size_t', u'nsrcs', '', []],
        [u'Mat*', u'dst', '', []],
        [u'size_t', u'ndsts', '', []],
        [u'const int*', u'fromTo', '', []],
        [u'size_t', u'npairs', '', []]],
    u'copies selected channels from the input arrays to the selected channels of the output arrays\n']
parseName: cv.mixChannels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mixChannels namespace:cv classpath: classname: name:mixChannels
register (function) mixChannels

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    ['/NW'],
    [   [u'const vector<Mat>&', u'src', '', []],
        [u'vector<Mat>&', u'dst', '', []],
        [u'const int*', u'fromTo', '', []],
        [u'size_t', u'npairs', '', []]],
    '']
parseName: cv.mixChannels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mixChannels namespace:cv classpath: classname: name:mixChannels
register (function) mixChannels

--- Incoming ---
[   u'cv.mixChannels',
    u'void',
    ['/NW'],
    [   [u'InputArrayOfArrays', u'src', '', []],
        [u'InputArrayOfArrays', u'dst', '', []],
        [u'const vector<int>&', u'fromTo', '', []]],
    '']
parseName: cv.mixChannels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mixChannels namespace:cv classpath: classname: name:mixChannels
register (function) mixChannels

--- Incoming ---
[   u'cv.extractChannel',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'coi', '', []]],
    u'extracts a single channel from src (coi is 0-based index)\n']
parseName: cv.extractChannel with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::extractChannel namespace:cv classpath: classname: name:extractChannel
register (function) extractChannel

--- Incoming ---
[   u'cv.insertChannel',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'InputOutputArray', u'dst', '', []],
        [u'int', u'coi', '', []]],
    u'inserts a single channel to dst (coi is 0-based index)\n']
parseName: cv.insertChannel with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::insertChannel namespace:cv classpath: classname: name:insertChannel
register (function) insertChannel

--- Incoming ---
[   u'cv.flip',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flipCode', '', []]],
    u'reverses the order of the rows, columns or both in a matrix\n']
parseName: cv.flip with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::flip namespace:cv classpath: classname: name:flip
register (function) flip

--- Incoming ---
[   u'cv.repeat',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'int', u'ny', '', []],
        [u'int', u'nx', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'replicates the input matrix the specified number of times in the horizontal and/or vertical direction\n']
parseName: cv.repeat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::repeat namespace:cv classpath: classname: name:repeat
register (function) repeat

--- Incoming ---
[   u'cv.repeat',
    u'Mat',
    ['/NW'],
    [   [u'const Mat&', u'src', '', []],
        [u'int', u'ny', '', []],
        [u'int', u'nx', '', []]],
    '']
parseName: cv.repeat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::repeat namespace:cv classpath: classname: name:repeat
register (function) repeat

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    ['/NW'],
    [   [u'const Mat*', u'src', '', []],
        [u'size_t', u'nsrc', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.hconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::hconcat namespace:cv classpath: classname: name:hconcat
register (function) hconcat

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.hconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::hconcat namespace:cv classpath: classname: name:hconcat
register (function) hconcat

--- Incoming ---
[   u'cv.hconcat',
    u'void',
    ['/NW'],
    [   [u'InputArrayOfArrays', u'src', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.hconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::hconcat namespace:cv classpath: classname: name:hconcat
register (function) hconcat

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    ['/NW'],
    [   [u'const Mat*', u'src', '', []],
        [u'size_t', u'nsrc', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.vconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::vconcat namespace:cv classpath: classname: name:vconcat
register (function) vconcat

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.vconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::vconcat namespace:cv classpath: classname: name:vconcat
register (function) vconcat

--- Incoming ---
[   u'cv.vconcat',
    u'void',
    ['/NW'],
    [   [u'InputArrayOfArrays', u'src', '', []],
        [u'OutputArray', u'dst', '', []]],
    '']
parseName: cv.vconcat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::vconcat namespace:cv classpath: classname: name:vconcat
register (function) vconcat

--- Incoming ---
[   u'cv.bitwise_and',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes bitwise conjunction of the two arrays (dst = src1 & src2)\n']
parseName: cv.bitwise_and with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::bitwise_and namespace:cv classpath: classname: name:bitwise_and
register (function) bitwise_and

--- Incoming ---
[   u'cv.bitwise_or',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes bitwise disjunction of the two arrays (dst = src1 | src2)\n']
parseName: cv.bitwise_or with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::bitwise_or namespace:cv classpath: classname: name:bitwise_or
register (function) bitwise_or

--- Incoming ---
[   u'cv.bitwise_xor',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'computes bitwise exclusive-or of the two arrays (dst = src1 ^ src2)\n']
parseName: cv.bitwise_xor with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::bitwise_xor namespace:cv classpath: classname: name:bitwise_xor
register (function) bitwise_xor

--- Incoming ---
[   u'cv.bitwise_not',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'mask', u'noArray()', []]],
    u'inverts each bit of array (dst = ~src)\n']
parseName: cv.bitwise_not with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::bitwise_not namespace:cv classpath: classname: name:bitwise_not
register (function) bitwise_not

--- Incoming ---
[   u'cv.absdiff',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'computes element-wise absolute difference of two arrays (dst = abs(src1 - src2))\n']
parseName: cv.absdiff with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::absdiff namespace:cv classpath: classname: name:absdiff
register (function) absdiff

--- Incoming ---
[   u'cv.inRange',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'InputArray', u'lowerb', '', []],
        [u'InputArray', u'upperb', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'set mask elements for those array elements which are within the element-specific bounding box (dst = lowerb <= src && src < upperb)\n']
parseName: cv.inRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::inRange namespace:cv classpath: classname: name:inRange
register (function) inRange

--- Incoming ---
[   u'cv.compare',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'cmpop', '', []]],
    u'compares elements of two arrays (dst = src1 \\<cmpop\\> src2)\n']
parseName: cv.compare with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::compare namespace:cv classpath: classname: name:compare
register (function) compare

--- Incoming ---
[   u'cv.min',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'computes per-element minimum of two arrays (dst = min(src1, src2))\n']
parseName: cv.min with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::min namespace:cv classpath: classname: name:min
register (function) min

--- Incoming ---
[   u'cv.max',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'computes per-element maximum of two arrays (dst = max(src1, src2))\n']
parseName: cv.max with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::max namespace:cv classpath: classname: name:max
register (function) max

--- Incoming ---
[   u'cv.min',
    u'void',
    ['/NW'],
    [   [u'const Mat&', u'src1', '', []],
        [u'const Mat&', u'src2', '', []],
        [u'Mat&', u'dst', '', []]],
    u'computes per-element minimum of two arrays (dst = min(src1, src2))\n']
parseName: cv.min with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::min namespace:cv classpath: classname: name:min
register (function) min

--- Incoming ---
[   u'cv.min',
    u'void',
    ['/NW'],
    [   [u'const Mat&', u'src1', '', []],
        [u'double', u'src2', '', []],
        [u'Mat&', u'dst', '', []]],
    u'computes per-element minimum of array and scalar (dst = min(src1, src2))\n']
parseName: cv.min with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::min namespace:cv classpath: classname: name:min
register (function) min

--- Incoming ---
[   u'cv.max',
    u'void',
    ['/NW'],
    [   [u'const Mat&', u'src1', '', []],
        [u'const Mat&', u'src2', '', []],
        [u'Mat&', u'dst', '', []]],
    u'computes per-element maximum of two arrays (dst = max(src1, src2))\n']
parseName: cv.max with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::max namespace:cv classpath: classname: name:max
register (function) max

--- Incoming ---
[   u'cv.max',
    u'void',
    ['/NW'],
    [   [u'const Mat&', u'src1', '', []],
        [u'double', u'src2', '', []],
        [u'Mat&', u'dst', '', []]],
    u'computes per-element maximum of array and scalar (dst = max(src1, src2))\n']
parseName: cv.max with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::max namespace:cv classpath: classname: name:max
register (function) max

--- Incoming ---
[   u'cv.sqrt',
    u'void',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'dst', '', []]],
    u'computes square root of each matrix element (dst = src**0.5)\n']
parseName: cv.sqrt with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::sqrt namespace:cv classpath: classname: name:sqrt
register (function) sqrt

--- Incoming ---
[   u'cv.pow',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'double', u'power', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'raises the input matrix elements to the specified power (b = a**power)\n']
parseName: cv.pow with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::pow namespace:cv classpath: classname: name:pow
register (function) pow

--- Incoming ---
[   u'cv.exp',
    u'void',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'dst', '', []]],
    u'computes exponent of each matrix element (dst = e**src)\n']
parseName: cv.exp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::exp namespace:cv classpath: classname: name:exp
register (function) exp

--- Incoming ---
[   u'cv.log',
    u'void',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'dst', '', []]],
    u'computes natural logarithm of absolute value of each matrix element: dst = log(abs(src))\n']
parseName: cv.log with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::log namespace:cv classpath: classname: name:log
register (function) log

--- Incoming ---
[   u'cv.cubeRoot',
    u'float',
    ['/NW'],
    [[u'float', u'val', '', []]],
    u'computes cube root of the argument\n']
parseName: cv.cubeRoot with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::cubeRoot namespace:cv classpath: classname: name:cubeRoot
register (function) cubeRoot

--- Incoming ---
[   u'cv.fastAtan2',
    u'float',
    ['/NW'],
    [[u'float', u'y', '', []], [u'float', u'x', '', []]],
    u'computes the angle in degrees (0..360) of the vector (x,y)\n']
parseName: cv.fastAtan2 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fastAtan2 namespace:cv classpath: classname: name:fastAtan2
register (function) fastAtan2

--- Incoming ---
[   u'cv.exp',
    u'void',
    ['/NW'],
    [   [u'const float*', u'src', '', []],
        [u'float*', u'dst', '', []],
        [u'int', u'n', '', []]],
    '']
parseName: cv.exp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::exp namespace:cv classpath: classname: name:exp
register (function) exp

--- Incoming ---
[   u'cv.log',
    u'void',
    ['/NW'],
    [   [u'const float*', u'src', '', []],
        [u'float*', u'dst', '', []],
        [u'int', u'n', '', []]],
    '']
parseName: cv.log with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::log namespace:cv classpath: classname: name:log
register (function) log

--- Incoming ---
[   u'cv.fastAtan2',
    u'void',
    ['/NW'],
    [   [u'const float*', u'y', '', []],
        [u'const float*', u'x', '', []],
        [u'float*', u'dst', '', []],
        [u'int', u'n', '', []],
        [u'bool', u'angleInDegrees', '', []]],
    '']
parseName: cv.fastAtan2 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fastAtan2 namespace:cv classpath: classname: name:fastAtan2
register (function) fastAtan2

--- Incoming ---
[   u'cv.magnitude',
    u'void',
    ['/NW'],
    [   [u'const float*', u'x', '', []],
        [u'const float*', u'y', '', []],
        [u'float*', u'dst', '', []],
        [u'int', u'n', '', []]],
    '']
parseName: cv.magnitude with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::magnitude namespace:cv classpath: classname: name:magnitude
register (function) magnitude

--- Incoming ---
[   u'cv.polarToCart',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'magnitude', '', []],
        [u'InputArray', u'angle', '', []],
        [u'OutputArray', u'x', '', []],
        [u'OutputArray', u'y', '', []],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'converts polar coordinates to Cartesian\n']
parseName: cv.polarToCart with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::polarToCart namespace:cv classpath: classname: name:polarToCart
register (function) polarToCart

--- Incoming ---
[   u'cv.cartToPolar',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'x', '', []],
        [u'InputArray', u'y', '', []],
        [u'OutputArray', u'magnitude', '', []],
        [u'OutputArray', u'angle', '', []],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'converts Cartesian coordinates to polar\n']
parseName: cv.cartToPolar with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::cartToPolar namespace:cv classpath: classname: name:cartToPolar
register (function) cartToPolar

--- Incoming ---
[   u'cv.phase',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'x', '', []],
        [u'InputArray', u'y', '', []],
        [u'OutputArray', u'angle', '', []],
        [u'bool', u'angleInDegrees', u'false', []]],
    u'computes angle (angle(i)) of each (x(i), y(i)) vector\n']
parseName: cv.phase with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::phase namespace:cv classpath: classname: name:phase
register (function) phase

--- Incoming ---
[   u'cv.magnitude',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'x', '', []],
        [u'InputArray', u'y', '', []],
        [u'OutputArray', u'magnitude', '', []]],
    u'computes magnitude (magnitude(i)) of each (x(i), y(i)) vector\n']
parseName: cv.magnitude with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::magnitude namespace:cv classpath: classname: name:magnitude
register (function) magnitude

--- Incoming ---
[   u'cv.checkRange',
    u'bool',
    ['/NW'],
    [   [u'InputArray', u'a', '', []],
        [u'bool', u'quiet', u'true', []],
        [u'Point*', u'pos', u'0', []],
        [u'double', u'minVal', u'-DBL_MAX', []],
        [u'double', u'maxVal', u'DBL_MAX', []]],
    u'checks that each matrix element is within the specified range.\n']
parseName: cv.checkRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::checkRange namespace:cv classpath: classname: name:checkRange
register (function) checkRange

--- Incoming ---
[   u'cv.patchNaNs',
    u'void',
    ['/NW'],
    [[u'InputOutputArray', u'a', '', []], [u'double', u'val', u'0', []]],
    u"converts NaN's to the given number\n"]
parseName: cv.patchNaNs with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::patchNaNs namespace:cv classpath: classname: name:patchNaNs
register (function) patchNaNs

--- Incoming ---
[   u'cv.gemm',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'double', u'alpha', '', []],
        [u'InputArray', u'src3', '', []],
        [u'double', u'beta', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'0', []]],
    u'implements generalized matrix product algorithm GEMM from BLAS\n']
parseName: cv.gemm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::gemm namespace:cv classpath: classname: name:gemm
register (function) gemm

--- Incoming ---
[   u'cv.mulTransposed',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'bool', u'aTa', '', []],
        [u'InputArray', u'delta', u'noArray()', []],
        [u'double', u'scale', u'1', []],
        [u'int', u'dtype', u'-1', []]],
    u'multiplies matrix by its transposition from the left or from the right\n']
parseName: cv.mulTransposed with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mulTransposed namespace:cv classpath: classname: name:mulTransposed
register (function) mulTransposed

--- Incoming ---
[   u'cv.transpose',
    u'void',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'dst', '', []]],
    u'transposes the matrix\n']
parseName: cv.transpose with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::transpose namespace:cv classpath: classname: name:transpose
register (function) transpose

--- Incoming ---
[   u'cv.transform',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'm', '', []]],
    u'performs affine transformation of each element of multi-channel input matrix\n']
parseName: cv.transform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::transform namespace:cv classpath: classname: name:transform
register (function) transform

--- Incoming ---
[   u'cv.perspectiveTransform',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'InputArray', u'm', '', []]],
    u'performs perspective transformation of each element of multi-channel input matrix\n']
parseName: cv.perspectiveTransform with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::perspectiveTransform namespace:cv classpath: classname: name:perspectiveTransform
register (function) perspectiveTransform

--- Incoming ---
[   u'cv.completeSymm',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'mtx', '', []],
        [u'bool', u'lowerToUpper', u'false', []]],
    u'extends the symmetrical matrix from the lower half or from the upper half\n']
parseName: cv.completeSymm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::completeSymm namespace:cv classpath: classname: name:completeSymm
register (function) completeSymm

--- Incoming ---
[   u'cv.setIdentity',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'mtx', '', []],
        [u'const Scalar&', u's', u'Scalar(1)', []]],
    u'initializes scaled identity matrix\n']
parseName: cv.setIdentity with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::setIdentity namespace:cv classpath: classname: name:setIdentity
register (function) setIdentity

--- Incoming ---
[   u'cv.determinant',
    u'double',
    ['/NW'],
    [[u'InputArray', u'mtx', '', []]],
    u'computes determinant of a square matrix\n']
parseName: cv.determinant with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::determinant namespace:cv classpath: classname: name:determinant
register (function) determinant

--- Incoming ---
[   u'cv.trace',
    u'Scalar',
    ['/NW'],
    [[u'InputArray', u'mtx', '', []]],
    u'computes trace of a matrix\n']
parseName: cv.trace with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::trace namespace:cv classpath: classname: name:trace
register (function) trace

--- Incoming ---
[   u'cv.invert',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'computes inverse or pseudo-inverse matrix\n']
parseName: cv.invert with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::invert namespace:cv classpath: classname: name:invert
register (function) invert

--- Incoming ---
[   u'cv.solve',
    u'bool',
    ['/NW'],
    [   [u'InputArray', u'src1', '', []],
        [u'InputArray', u'src2', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'DECOMP_LU', []]],
    u'solves linear system or a least-square problem\n']
parseName: cv.solve with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::solve namespace:cv classpath: classname: name:solve
register (function) solve

--- Incoming ---
[u'const cv.SORT_EVERY_ROW', u'0', [], []]
parseName: const cv.SORT_EVERY_ROW with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SORT_EVERY_ROW namespace:cv classpath: classname: name:SORT_EVERY_ROW

--- Incoming ---
[u'const cv.SORT_EVERY_COLUMN', u'1', [], []]
parseName: const cv.SORT_EVERY_COLUMN with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SORT_EVERY_COLUMN namespace:cv classpath: classname: name:SORT_EVERY_COLUMN

--- Incoming ---
[u'const cv.SORT_ASCENDING', u'0', [], []]
parseName: const cv.SORT_ASCENDING with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SORT_ASCENDING namespace:cv classpath: classname: name:SORT_ASCENDING

--- Incoming ---
[u'const cv.SORT_DESCENDING', u'16', [], []]
parseName: const cv.SORT_DESCENDING with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SORT_DESCENDING namespace:cv classpath: classname: name:SORT_DESCENDING

--- Incoming ---
[   u'cv.sort',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', '', []]],
    u'sorts independently each matrix row or each matrix column\n']
parseName: cv.sort with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::sort namespace:cv classpath: classname: name:sort
register (function) sort

--- Incoming ---
[   u'cv.sortIdx',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', '', []]],
    u'sorts independently each matrix row or each matrix column\n']
parseName: cv.sortIdx with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::sortIdx namespace:cv classpath: classname: name:sortIdx
register (function) sortIdx

--- Incoming ---
[   u'cv.solveCubic',
    u'int',
    ['/NW'],
    [[u'InputArray', u'coeffs', '', []], [u'OutputArray', u'roots', '', []]],
    u'finds real roots of a cubic polynomial\n']
parseName: cv.solveCubic with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::solveCubic namespace:cv classpath: classname: name:solveCubic
register (function) solveCubic

--- Incoming ---
[   u'cv.solvePoly',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'coeffs', '', []],
        [u'OutputArray', u'roots', '', []],
        [u'int', u'maxIters', u'300', []]],
    u'finds real and complex roots of a polynomial\n']
parseName: cv.solvePoly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::solvePoly namespace:cv classpath: classname: name:solvePoly
register (function) solvePoly

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'eigenvalues', '', []],
        [u'int', u'lowindex', u'-1', []],
        [u'int', u'highindex', u'-1', []]],
    u'finds eigenvalues of a symmetric matrix\n']
parseName: cv.eigen with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::eigen namespace:cv classpath: classname: name:eigen
register (function) eigen

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'eigenvalues', '', []],
        [u'OutputArray', u'eigenvectors', '', []],
        [u'int', u'lowindex', u'-1', []],
        [u'int', u'highindex', u'-1', []]],
    u'finds eigenvalues and eigenvectors of a symmetric matrix\n']
parseName: cv.eigen with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::eigen namespace:cv classpath: classname: name:eigen
register (function) eigen

--- Incoming ---
[   u'cv.eigen',
    u'bool',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'bool', u'computeEigenvectors', '', []],
        [u'OutputArray', u'eigenvalues', '', []],
        [u'OutputArray', u'eigenvectors', '', []]],
    '']
parseName: cv.eigen with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::eigen namespace:cv classpath: classname: name:eigen
register (function) eigen

--- Incoming ---
[u'const cv.COVAR_SCRAMBLED', u'0', [], []]
parseName: const cv.COVAR_SCRAMBLED with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_SCRAMBLED namespace:cv classpath: classname: name:COVAR_SCRAMBLED

--- Incoming ---
[u'const cv.COVAR_NORMAL', u'1', [], []]
parseName: const cv.COVAR_NORMAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_NORMAL namespace:cv classpath: classname: name:COVAR_NORMAL

--- Incoming ---
[u'const cv.COVAR_USE_AVG', u'2', [], []]
parseName: const cv.COVAR_USE_AVG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_USE_AVG namespace:cv classpath: classname: name:COVAR_USE_AVG

--- Incoming ---
[u'const cv.COVAR_SCALE', u'4', [], []]
parseName: const cv.COVAR_SCALE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_SCALE namespace:cv classpath: classname: name:COVAR_SCALE

--- Incoming ---
[u'const cv.COVAR_ROWS', u'8', [], []]
parseName: const cv.COVAR_ROWS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_ROWS namespace:cv classpath: classname: name:COVAR_ROWS

--- Incoming ---
[u'const cv.COVAR_COLS', u'16', [], []]
parseName: const cv.COVAR_COLS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::COVAR_COLS namespace:cv classpath: classname: name:COVAR_COLS

--- Incoming ---
[   u'cv.calcCovarMatrix',
    u'void',
    ['/NW'],
    [   [u'const Mat*', u'samples', '', []],
        [u'int', u'nsamples', '', []],
        [u'Mat&', u'covar', '', []],
        [u'Mat&', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'int', u'ctype', u'CV_64F', []]],
    u'computes covariation matrix of a set of samples\n']
parseName: cv.calcCovarMatrix with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::calcCovarMatrix namespace:cv classpath: classname: name:calcCovarMatrix
register (function) calcCovarMatrix

--- Incoming ---
[   u'cv.calcCovarMatrix',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'samples', '', []],
        [u'OutputArray', u'covar', '', []],
        [u'OutputArray', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'int', u'ctype', u'CV_64F', []]],
    u'computes covariation matrix of a set of samples\n']
parseName: cv.calcCovarMatrix with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::calcCovarMatrix namespace:cv classpath: classname: name:calcCovarMatrix
register (function) calcCovarMatrix

--- Incoming ---
[   u'class cv.PCA',
    '',
    [],
    [],
    u'Principal Component Analysis\n\nThe class PCA is used to compute the special basis for a set of vectors.\nThe basis will consist of eigenvectors of the covariance matrix computed\nfrom the input set of vectors. After PCA is performed, vectors can be transformed from\nthe original high-dimensional space to the subspace formed by a few most\nprominent eigenvectors (called the principal components),\ncorresponding to the largest eigenvalues of the covariation matrix.\nThus the dimensionality of the vector and the correlation between the coordinates is reduced.\n\nThe following sample is the function that takes two matrices. The first one stores the set\nof vectors (a row per vector) that is used to compute PCA, the second one stores another\n"test" set of vectors (a row per vector) that are first compressed with PCA,\nthen reconstructed back and then the reconstruction error norm is computed and printed for each vector.\n\n\\code\nusing namespace cv;\n\nPCA compressPCA(const Mat& pcaset, int maxComponents,\nconst Mat& testset, Mat& compressed)\n{\nPCA pca(pcaset, // pass the data\nMat(), // we do not have a pre-computed mean vector,\n// so let the PCA engine to compute it\nCV_PCA_DATA_AS_ROW, // indicate that the vectors\n// are stored as matrix rows\n// (use CV_PCA_DATA_AS_COL if the vectors are\n// the matrix columns)\nmaxComponents // specify, how many principal components to retain\n);\n// if there is no test data, just return the computed basis, ready-to-use\nif( !testset.data )\nreturn pca;\nCV_Assert( testset.cols == pcaset.cols );\n\ncompressed.create(testset.rows, maxComponents, testset.type());\n\nMat reconstructed;\nfor( int i = 0; i < testset.rows; i++ )\n{\nMat vec = testset.row(i), coeffs = compressed.row(i), reconstructed;\n// compress the vector, the result will be stored\n// in the i-th row of the output matrix\npca.project(vec, coeffs);\n// and then reconstruct it\npca.backProject(coeffs, reconstructed);\n// and measure the error\nprintf("%d. diff = %g\\n", i, norm(vec, reconstructed, NORM_L2));\n}\nreturn pca;\n}\n\\endcode\n']
parseName: class cv.PCA with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA namespace:cv classpath: classname: name:PCA
register class cv::PCA ([u'class cv.PCA', '', [], [], u'Principal Component Analysis\n\nThe class PCA is used to compute the special basis for a set of vectors.\nThe basis will consist of eigenvectors of the covariance matrix computed\nfrom the input set of vectors. After PCA is performed, vectors can be transformed from\nthe original high-dimensional space to the subspace formed by a few most\nprominent eigenvectors (called the principal components),\ncorresponding to the largest eigenvalues of the covariation matrix.\nThus the dimensionality of the vector and the correlation between the coordinates is reduced.\n\nThe following sample is the function that takes two matrices. The first one stores the set\nof vectors (a row per vector) that is used to compute PCA, the second one stores another\n"test" set of vectors (a row per vector) that are first compressed with PCA,\nthen reconstructed back and then the reconstruction error norm is computed and printed for each vector.\n\n\\code\nusing namespace cv;\n\nPCA compressPCA(const Mat& pcaset, int maxComponents,\nconst Mat& testset, Mat& compressed)\n{\nPCA pca(pcaset, // pass the data\nMat(), // we do not have a pre-computed mean vector,\n// so let the PCA engine to compute it\nCV_PCA_DATA_AS_ROW, // indicate that the vectors\n// are stored as matrix rows\n// (use CV_PCA_DATA_AS_COL if the vectors are\n// the matrix columns)\nmaxComponents // specify, how many principal components to retain\n);\n// if there is no test data, just return the computed basis, ready-to-use\nif( !testset.data )\nreturn pca;\nCV_Assert( testset.cols == pcaset.cols );\n\ncompressed.create(testset.rows, maxComponents, testset.type());\n\nMat reconstructed;\nfor( int i = 0; i < testset.rows; i++ )\n{\nMat vec = testset.row(i), coeffs = compressed.row(i), reconstructed;\n// compress the vector, the result will be stored\n// in the i-th row of the output matrix\npca.project(vec, coeffs);\n// and then reconstruct it\npca.backProject(coeffs, reconstructed);\n// and measure the error\nprintf("%d. diff = %g\\n", i, norm(vec, reconstructed, NORM_L2));\n}\nreturn pca;\n}\n\\endcode\n'])

--- Incoming ---
[u'cv.PCA.PCA', u'', ['/NW'], [], u'default constructor\n']
parseName: cv.PCA.PCA with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::PCA namespace:cv classpath:PCA classname:PCA name:PCA
register (constructor) new in cv::PCA

--- Incoming ---
[   u'cv.PCA.PCA',
    u'',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'int', u'maxComponents', u'0', []]],
    u'the constructor that performs PCA\n']
parseName: cv.PCA.PCA with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::PCA namespace:cv classpath:PCA classname:PCA name:PCA
register (constructor) new in cv::PCA

--- Incoming ---
[   u'cv.PCA.PCA',
    u'',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'double', u'retainedVariance', '', []]],
    '']
parseName: cv.PCA.PCA with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::PCA namespace:cv classpath:PCA classname:PCA name:PCA
register (constructor) new in cv::PCA

--- Incoming ---
[   u'cv.PCA.operator ()',
    u'PCA&',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'int', u'maxComponents', u'0', []]],
    u'operator that performs PCA. The previously stored data, if any, is released\n']
parseName: cv.PCA.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::operator () namespace:cv classpath:PCA classname:PCA name:operator ()
ignore (method) operator () in cv::PCA

--- Incoming ---
[   u'cv.PCA.computeVar',
    u'PCA&',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'int', u'flags', '', []],
        [u'double', u'retainedVariance', '', []]],
    '']
parseName: cv.PCA.computeVar with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::computeVar namespace:cv classpath:PCA classname:PCA name:computeVar
register (method) computeVar in cv::PCA

--- Incoming ---
[   u'cv.PCA.project',
    u'Mat',
    ['/NW', '/C'],
    [[u'InputArray', u'vec', '', []]],
    u'projects vector from the original space to the principal components subspace\n']
parseName: cv.PCA.project with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::project namespace:cv classpath:PCA classname:PCA name:project
register (method) project in cv::PCA

--- Incoming ---
[   u'cv.PCA.project',
    u'void',
    ['/NW', '/C'],
    [[u'InputArray', u'vec', '', []], [u'OutputArray', u'result', '', []]],
    u'projects vector from the original space to the principal components subspace\n']
parseName: cv.PCA.project with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::project namespace:cv classpath:PCA classname:PCA name:project
register (method) project in cv::PCA

--- Incoming ---
[   u'cv.PCA.backProject',
    u'Mat',
    ['/NW', '/C'],
    [[u'InputArray', u'vec', '', []]],
    u'reconstructs the original vector from the projection\n']
parseName: cv.PCA.backProject with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::backProject namespace:cv classpath:PCA classname:PCA name:backProject
register (method) backProject in cv::PCA

--- Incoming ---
[   u'cv.PCA.backProject',
    u'void',
    ['/NW', '/C'],
    [[u'InputArray', u'vec', '', []], [u'OutputArray', u'result', '', []]],
    u'reconstructs the original vector from the projection\n']
parseName: cv.PCA.backProject with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCA::backProject namespace:cv classpath:PCA classname:PCA name:backProject
register (method) backProject in cv::PCA

--- Incoming ---
[   u'cv.PCACompute',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputOutputArray', u'mean', '', []],
        [u'OutputArray', u'eigenvectors', '', []],
        [u'int', u'maxComponents', u'0', []]],
    '']
parseName: cv.PCACompute with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCACompute namespace:cv classpath: classname: name:PCACompute
register (function) PCACompute

--- Incoming ---
[   u'cv.PCAComputeVar',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputOutputArray', u'mean', '', []],
        [u'OutputArray', u'eigenvectors', '', []],
        [u'double', u'retainedVariance', '', []]],
    '']
parseName: cv.PCAComputeVar with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCAComputeVar namespace:cv classpath: classname: name:PCAComputeVar
register (function) PCAComputeVar

--- Incoming ---
[   u'cv.PCAProject',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'InputArray', u'eigenvectors', '', []],
        [u'OutputArray', u'result', '', []]],
    '']
parseName: cv.PCAProject with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCAProject namespace:cv classpath: classname: name:PCAProject
register (function) PCAProject

--- Incoming ---
[   u'cv.PCABackProject',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'InputArray', u'mean', '', []],
        [u'InputArray', u'eigenvectors', '', []],
        [u'OutputArray', u'result', '', []]],
    '']
parseName: cv.PCABackProject with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::PCABackProject namespace:cv classpath: classname: name:PCABackProject
register (function) PCABackProject

--- Incoming ---
[   u'class cv.SVD',
    '',
    [],
    [],
    u'Singular Value Decomposition class\n\nThe class is used to compute Singular Value Decomposition of a floating-point matrix and then\nuse it to solve least-square problems, under-determined linear systems, invert matrices,\ncompute condition numbers etc.\n\nFor a bit faster operation you can pass flags=SVD::MODIFY_A|... to modify the decomposed matrix\nwhen it is not necessarily to preserve it. If you want to compute condition number of a matrix\nor absolute value of its determinant - you do not need SVD::u or SVD::vt,\nso you can pass flags=SVD::NO_UV|... . Another flag SVD::FULL_UV indicates that the full-size SVD::u and SVD::vt\nmust be computed, which is not necessary most of the time.\n']
parseName: class cv.SVD with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD namespace:cv classpath: classname: name:SVD
register class cv::SVD ([u'class cv.SVD', '', [], [], u'Singular Value Decomposition class\n\nThe class is used to compute Singular Value Decomposition of a floating-point matrix and then\nuse it to solve least-square problems, under-determined linear systems, invert matrices,\ncompute condition numbers etc.\n\nFor a bit faster operation you can pass flags=SVD::MODIFY_A|... to modify the decomposed matrix\nwhen it is not necessarily to preserve it. If you want to compute condition number of a matrix\nor absolute value of its determinant - you do not need SVD::u or SVD::vt,\nso you can pass flags=SVD::NO_UV|... . Another flag SVD::FULL_UV indicates that the full-size SVD::u and SVD::vt\nmust be computed, which is not necessary most of the time.\n']) [ignored]

--- Incoming ---
[u'const cv.SVD.MODIFY_A', u'1', [], []]
parseName: const cv.SVD.MODIFY_A with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::MODIFY_A namespace:cv classpath:SVD classname:SVD name:MODIFY_A

--- Incoming ---
[u'const cv.SVD.NO_UV', u'2', [], []]
parseName: const cv.SVD.NO_UV with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::NO_UV namespace:cv classpath:SVD classname:SVD name:NO_UV

--- Incoming ---
[u'const cv.SVD.FULL_UV', u'4', [], []]
parseName: const cv.SVD.FULL_UV with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::FULL_UV namespace:cv classpath:SVD classname:SVD name:FULL_UV

--- Incoming ---
[u'cv.SVD.SVD', u'', ['/NW'], [], u'the default constructor\n']
parseName: cv.SVD.SVD with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::SVD namespace:cv classpath:SVD classname:SVD name:SVD
register (constructor) new in cv::SVD

--- Incoming ---
[   u'cv.SVD.SVD',
    u'',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'int', u'flags', u'0', []]],
    u'the constructor that performs SVD\n']
parseName: cv.SVD.SVD with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::SVD namespace:cv classpath:SVD classname:SVD name:SVD
register (constructor) new in cv::SVD

--- Incoming ---
[   u'cv.SVD.operator ()',
    u'SVD&',
    ['/NW'],
    [[u'InputArray', u'src', '', []], [u'int', u'flags', u'0', []]],
    u'the operator that performs SVD. The previously allocated SVD::u, SVD::w are SVD::vt are released.\n']
parseName: cv.SVD.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::operator () namespace:cv classpath:SVD classname:SVD name:operator ()
ignore (method) operator () in cv::SVD

--- Incoming ---
[   u'cv.SVD.compute',
    u'void',
    ['/NW', '/S'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'w', '', []],
        [u'OutputArray', u'u', '', []],
        [u'OutputArray', u'vt', '', []],
        [u'int', u'flags', u'0', []]],
    u'decomposes matrix and stores the results to user-provided matrices\n']
parseName: cv.SVD.compute with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::compute namespace:cv classpath:SVD classname:SVD name:compute
register (method) compute in cv::SVD

--- Incoming ---
[   u'cv.SVD.compute',
    u'void',
    ['/NW', '/S'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'w', '', []],
        [u'int', u'flags', u'0', []]],
    u'computes singular values of a matrix\n']
parseName: cv.SVD.compute with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::compute namespace:cv classpath:SVD classname:SVD name:compute
register (method) compute in cv::SVD

--- Incoming ---
[   u'cv.SVD.backSubst',
    u'void',
    ['/NW', '/S'],
    [   [u'InputArray', u'w', '', []],
        [u'InputArray', u'u', '', []],
        [u'InputArray', u'vt', '', []],
        [u'InputArray', u'rhs', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'performs back substitution\n']
parseName: cv.SVD.backSubst with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::backSubst namespace:cv classpath:SVD classname:SVD name:backSubst
register (method) backSubst in cv::SVD

--- Incoming ---
[   u'cv.SVD.solveZ',
    u'void',
    ['/NW', '/S'],
    [[u'InputArray', u'src', '', []], [u'OutputArray', u'dst', '', []]],
    u'finds dst = arg min_{|dst|=1} |m*dst|\n']
parseName: cv.SVD.solveZ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::solveZ namespace:cv classpath:SVD classname:SVD name:solveZ
register (method) solveZ in cv::SVD

--- Incoming ---
[   u'cv.SVD.backSubst',
    u'void',
    ['/NW', '/C'],
    [[u'InputArray', u'rhs', '', []], [u'OutputArray', u'dst', '', []]],
    u'performs back substitution, so that dst is the solution or pseudo-solution of m*dst = rhs, where m is the decomposed matrix\n']
parseName: cv.SVD.backSubst with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVD::backSubst namespace:cv classpath:SVD classname:SVD name:backSubst
register (method) backSubst in cv::SVD

--- Incoming ---
[   u'cv.SVDecomp',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'w', '', []],
        [u'OutputArray', u'u', '', []],
        [u'OutputArray', u'vt', '', []],
        [u'int', u'flags', u'0', []]],
    u'computes SVD of src\n']
parseName: cv.SVDecomp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVDecomp namespace:cv classpath: classname: name:SVDecomp
register (function) SVDecomp

--- Incoming ---
[   u'cv.SVBackSubst',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'w', '', []],
        [u'InputArray', u'u', '', []],
        [u'InputArray', u'vt', '', []],
        [u'InputArray', u'rhs', '', []],
        [u'OutputArray', u'dst', '', []]],
    u'performs back substitution for the previously computed SVD\n']
parseName: cv.SVBackSubst with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SVBackSubst namespace:cv classpath: classname: name:SVBackSubst
register (function) SVBackSubst

--- Incoming ---
[   u'cv.Mahalanobis',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'v1', '', []],
        [u'InputArray', u'v2', '', []],
        [u'InputArray', u'icovar', '', []]],
    u"computes Mahalanobis distance between two vectors: sqrt((v1-v2)'*icovar*(v1-v2)), where icovar is the inverse covariation matrix\n"]
parseName: cv.Mahalanobis with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mahalanobis namespace:cv classpath: classname: name:Mahalanobis
register (function) Mahalanobis

--- Incoming ---
[   u'cv.Mahalonobis',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'v1', '', []],
        [u'InputArray', u'v2', '', []],
        [u'InputArray', u'icovar', '', []]],
    u'a synonym for Mahalanobis\n']
parseName: cv.Mahalonobis with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mahalonobis namespace:cv classpath: classname: name:Mahalonobis
register (function) Mahalonobis

--- Incoming ---
[   u'cv.dft',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'performs forward or inverse 1D or 2D Discrete Fourier Transformation\n']
parseName: cv.dft with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::dft namespace:cv classpath: classname: name:dft
register (function) dft

--- Incoming ---
[   u'cv.idft',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'0', []],
        [u'int', u'nonzeroRows', u'0', []]],
    u'performs inverse 1D or 2D Discrete Fourier Transformation\n']
parseName: cv.idft with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::idft namespace:cv classpath: classname: name:idft
register (function) idft

--- Incoming ---
[   u'cv.dct',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'0', []]],
    u'performs forward or inverse 1D or 2D Discrete Cosine Transformation\n']
parseName: cv.dct with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::dct namespace:cv classpath: classname: name:dct
register (function) dct

--- Incoming ---
[   u'cv.idct',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'src', '', []],
        [u'OutputArray', u'dst', '', []],
        [u'int', u'flags', u'0', []]],
    u'performs inverse 1D or 2D Discrete Cosine Transformation\n']
parseName: cv.idct with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::idct namespace:cv classpath: classname: name:idct
register (function) idct

--- Incoming ---
[   u'cv.mulSpectrums',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'a', '', []],
        [u'InputArray', u'b', '', []],
        [u'OutputArray', u'c', '', []],
        [u'int', u'flags', '', []],
        [u'bool', u'conjB', u'false', []]],
    u'computes element-wise product of the two Fourier spectrums. The second spectrum can optionally be conjugated before the multiplication\n']
parseName: cv.mulSpectrums with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::mulSpectrums namespace:cv classpath: classname: name:mulSpectrums
register (function) mulSpectrums

--- Incoming ---
[   u'cv.getOptimalDFTSize',
    u'int',
    ['/NW'],
    [[u'int', u'vecsize', '', []]],
    u'computes the minimal vector size vecsize1 >= vecsize so that the dft() of the vector of length vecsize1 can be computed efficiently\n']
parseName: cv.getOptimalDFTSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getOptimalDFTSize namespace:cv classpath: classname: name:getOptimalDFTSize
register (function) getOptimalDFTSize

--- Incoming ---
[u'const cv.KMEANS_RANDOM_CENTERS', u'0', [], []]
parseName: const cv.KMEANS_RANDOM_CENTERS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KMEANS_RANDOM_CENTERS namespace:cv classpath: classname: name:KMEANS_RANDOM_CENTERS

--- Incoming ---
[u'const cv.KMEANS_PP_CENTERS', u'2', [], []]
parseName: const cv.KMEANS_PP_CENTERS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KMEANS_PP_CENTERS namespace:cv classpath: classname: name:KMEANS_PP_CENTERS

--- Incoming ---
[u'const cv.KMEANS_USE_INITIAL_LABELS', u'1', [], []]
parseName: const cv.KMEANS_USE_INITIAL_LABELS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KMEANS_USE_INITIAL_LABELS namespace:cv classpath: classname: name:KMEANS_USE_INITIAL_LABELS

--- Incoming ---
[   u'cv.kmeans',
    u'double',
    ['/NW'],
    [   [u'InputArray', u'data', '', []],
        [u'int', u'K', '', []],
        [u'InputOutputArray', u'bestLabels', '', []],
        [u'TermCriteria', u'criteria', '', []],
        [u'int', u'attempts', '', []],
        [u'int', u'flags', '', []],
        [u'OutputArray', u'centers', u'noArray()', []]],
    u'clusters the input data using k-Means algorithm\n']
parseName: cv.kmeans with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::kmeans namespace:cv classpath: classname: name:kmeans
register (function) kmeans

--- Incoming ---
[   u'cv.theRNG',
    u'RNG&',
    ['/NW'],
    [],
    u'returns the thread-local Random number generator\n']
parseName: cv.theRNG with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::theRNG namespace:cv classpath: classname: name:theRNG
register (function) theRNG

--- Incoming ---
[   u'cv.setRNGSeed',
    u'void',
    ['/NW'],
    [[u'int', u'seed', '', []]],
    u'sets state of the thread-local Random number generator\n']
parseName: cv.setRNGSeed with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::setRNGSeed namespace:cv classpath: classname: name:setRNGSeed
register (function) setRNGSeed

--- Incoming ---
[   u'cv.randu',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'dst', '', []],
        [u'InputArray', u'low', '', []],
        [u'InputArray', u'high', '', []]],
    u'fills array with uniformly-distributed random numbers from the range [low, high)\n']
parseName: cv.randu with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::randu namespace:cv classpath: classname: name:randu
register (function) randu

--- Incoming ---
[   u'cv.randn',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'dst', '', []],
        [u'InputArray', u'mean', '', []],
        [u'InputArray', u'stddev', '', []]],
    u'fills array with normally-distributed random numbers with the specified mean and the standard deviation\n']
parseName: cv.randn with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::randn namespace:cv classpath: classname: name:randn
register (function) randn

--- Incoming ---
[   u'cv.randShuffle',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'dst', '', []],
        [u'double', u'iterFactor', u'1.', []],
        [u'RNG*', u'rng', u'0', []]],
    u'shuffles the input array elements\n']
parseName: cv.randShuffle with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::randShuffle namespace:cv classpath: classname: name:randShuffle
register (function) randShuffle

--- Incoming ---
[   u'cv.randShuffle_',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'dst', '', []],
        [u'double', u'iterFactor', u'1.', []]],
    '']
parseName: cv.randShuffle_ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::randShuffle_ namespace:cv classpath: classname: name:randShuffle_
register (function) randShuffle_

--- Incoming ---
[   u'cv.line',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'pt1', '', []],
        [u'Point', u'pt2', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws the line segment (pt1, pt2) in the image\n']
parseName: cv.line with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::line namespace:cv classpath: classname: name:line
register (function) line

--- Incoming ---
[   u'cv.arrowedLine',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'pt1', '', []],
        [u'Point', u'pt2', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'double', u'tipLength', u'0.1', []]],
    u'draws an arrow from pt1 to pt2 in the image\n']
parseName: cv.arrowedLine with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::arrowedLine namespace:cv classpath: classname: name:arrowedLine
register (function) arrowedLine

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'pt1', '', []],
        [u'Point', u'pt2', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws the rectangle outline or a solid rectangle with the opposite corners pt1 and pt2 in the image\n']
parseName: cv.rectangle with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::rectangle namespace:cv classpath: classname: name:rectangle
register (function) rectangle

--- Incoming ---
[   u'cv.rectangle',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Rect', u'rec', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws the rectangle outline or a solid rectangle covering rec in the image\n']
parseName: cv.rectangle with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::rectangle namespace:cv classpath: classname: name:rectangle
register (function) rectangle

--- Incoming ---
[   u'cv.circle',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'center', '', []],
        [u'int', u'radius', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws the circle outline or a solid circle in the image\n']
parseName: cv.circle with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::circle namespace:cv classpath: classname: name:circle
register (function) circle

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'center', '', []],
        [u'Size', u'axes', '', []],
        [u'double', u'angle', '', []],
        [u'double', u'startAngle', '', []],
        [u'double', u'endAngle', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws an elliptic arc, ellipse sector or a rotated ellipse in the image\n']
parseName: cv.ellipse with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ellipse namespace:cv classpath: classname: name:ellipse
register (function) ellipse

--- Incoming ---
[   u'cv.ellipse',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'const RotatedRect&', u'box', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []]],
    u'draws a rotated ellipse in the image\n']
parseName: cv.ellipse with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ellipse namespace:cv classpath: classname: name:ellipse
register (function) ellipse

--- Incoming ---
[u'const cv.MARKER_CROSS', u'0', [], []]
parseName: const cv.MARKER_CROSS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_CROSS namespace:cv classpath: classname: name:MARKER_CROSS

--- Incoming ---
[u'const cv.MARKER_TILTED_CROSS', u'1', [], []]
parseName: const cv.MARKER_TILTED_CROSS with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_TILTED_CROSS namespace:cv classpath: classname: name:MARKER_TILTED_CROSS

--- Incoming ---
[u'const cv.MARKER_STAR', u'2', [], []]
parseName: const cv.MARKER_STAR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_STAR namespace:cv classpath: classname: name:MARKER_STAR

--- Incoming ---
[u'const cv.MARKER_DIAMOND', u'3', [], []]
parseName: const cv.MARKER_DIAMOND with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_DIAMOND namespace:cv classpath: classname: name:MARKER_DIAMOND

--- Incoming ---
[u'const cv.MARKER_SQUARE', u'4', [], []]
parseName: const cv.MARKER_SQUARE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_SQUARE namespace:cv classpath: classname: name:MARKER_SQUARE

--- Incoming ---
[u'const cv.MARKER_TRIANGLE_UP', u'5', [], []]
parseName: const cv.MARKER_TRIANGLE_UP with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_TRIANGLE_UP namespace:cv classpath: classname: name:MARKER_TRIANGLE_UP

--- Incoming ---
[u'const cv.MARKER_TRIANGLE_DOWN', u'6', [], []]
parseName: const cv.MARKER_TRIANGLE_DOWN with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MARKER_TRIANGLE_DOWN namespace:cv classpath: classname: name:MARKER_TRIANGLE_DOWN

--- Incoming ---
[   u'cv.drawMarker',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'Point', u'position', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'markerType', u'MARKER_CROSS', []],
        [u'int', u'markerSize', u'20', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'line_type', u'8', []]],
    u'@brief Draws a marker on a predefined position in an image.\n\nThe function drawMarker draws a marker on a given position in the image. For the moment several\nmarker types are supported (`MARKER_CROSS`, `MARKER_TILTED_CROSS`, `MARKER_STAR`, `MARKER_DIAMOND`, `MARKER_SQUARE`,\n`MARKER_TRIANGLE_UP` and `MARKER_TRIANGLE_DOWN`).\n\n@param img Image.\n@param position The point where the crosshair is positioned.\n@param markerType The specific type of marker you want to use, see\n@param color Line color.\n@param thickness Line thickness.\n@param line_type Type of the line, see cv::LineTypes\n@param markerSize The length of the marker axis [default = 20 pixels]\n']
parseName: cv.drawMarker with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::drawMarker namespace:cv classpath: classname: name:drawMarker
register (function) drawMarker

--- Incoming ---
[   u'cv.fillConvexPoly',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'const Point*', u'pts', '', []],
        [u'int', u'npts', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws a filled convex polygon in the image\n']
parseName: cv.fillConvexPoly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fillConvexPoly namespace:cv classpath: classname: name:fillConvexPoly
register (function) fillConvexPoly

--- Incoming ---
[   u'cv.fillConvexPoly',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'img', '', []],
        [u'InputArray', u'points', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    '']
parseName: cv.fillConvexPoly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fillConvexPoly namespace:cv classpath: classname: name:fillConvexPoly
register (function) fillConvexPoly

--- Incoming ---
[   u'cv.fillPoly',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'const Point**', u'pts', '', []],
        [u'const int*', u'npts', '', []],
        [u'int', u'ncontours', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'Point', u'offset', u'Point()', []]],
    u'fills an area bounded by one or more polygons\n']
parseName: cv.fillPoly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fillPoly namespace:cv classpath: classname: name:fillPoly
register (function) fillPoly

--- Incoming ---
[   u'cv.fillPoly',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'img', '', []],
        [u'InputArrayOfArrays', u'pts', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []],
        [u'Point', u'offset', u'Point()', []]],
    '']
parseName: cv.fillPoly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::fillPoly namespace:cv classpath: classname: name:fillPoly
register (function) fillPoly

--- Incoming ---
[   u'cv.polylines',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'const Point**', u'pts', '', []],
        [u'const int*', u'npts', '', []],
        [u'int', u'ncontours', '', []],
        [u'bool', u'isClosed', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    u'draws one or more polygonal curves\n']
parseName: cv.polylines with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::polylines namespace:cv classpath: classname: name:polylines
register (function) polylines

--- Incoming ---
[   u'cv.polylines',
    u'void',
    ['/NW'],
    [   [u'InputOutputArray', u'img', '', []],
        [u'InputArrayOfArrays', u'pts', '', []],
        [u'bool', u'isClosed', '', []],
        [u'const Scalar&', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'int', u'shift', u'0', []]],
    '']
parseName: cv.polylines with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::polylines namespace:cv classpath: classname: name:polylines
register (function) polylines

--- Incoming ---
[   u'cv.clipLine',
    u'bool',
    ['/NW'],
    [   [u'Size', u'imgSize', '', []],
        [u'Point&', u'pt1', '', []],
        [u'Point&', u'pt2', '', []]],
    u'clips the line segment by the rectangle Rect(0, 0, imgSize.width, imgSize.height)\n']
parseName: cv.clipLine with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::clipLine namespace:cv classpath: classname: name:clipLine
register (function) clipLine

--- Incoming ---
[   u'cv.clipLine',
    u'bool',
    ['/NW'],
    [   [u'Rect', u'imgRect', '', []],
        [u'Point&', u'pt1', '', []],
        [u'Point&', u'pt2', '', []]],
    u'clips the line segment by the rectangle imgRect\n']
parseName: cv.clipLine with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::clipLine namespace:cv classpath: classname: name:clipLine
register (function) clipLine

--- Incoming ---
[   u'class cv.LineIterator',
    '',
    [],
    [],
    u'Line iterator class\n\nThe class is used to iterate over all the pixels on the raster line\nsegment connecting two specified points.\n']
parseName: class cv.LineIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator namespace:cv classpath: classname: name:LineIterator
register class cv::LineIterator ([u'class cv.LineIterator', '', [], [], u'Line iterator class\n\nThe class is used to iterate over all the pixels on the raster line\nsegment connecting two specified points.\n'])

--- Incoming ---
[   u'cv.LineIterator.LineIterator',
    u'',
    ['/NW'],
    [   [u'const Mat&', u'img', '', []],
        [u'Point', u'pt1', '', []],
        [u'Point', u'pt2', '', []],
        [u'int', u'connectivity', u'8', []],
        [u'bool', u'leftToRight', u'false', []]],
    u'intializes the iterator\n']
parseName: cv.LineIterator.LineIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator::LineIterator namespace:cv classpath:LineIterator classname:LineIterator name:LineIterator
register (constructor) new in cv::LineIterator

--- Incoming ---
[   u'cv.LineIterator.operator *',
    u'uchar*',
    ['/NW'],
    [],
    u'returns pointer to the current pixel\n']
parseName: cv.LineIterator.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator::operator * namespace:cv classpath:LineIterator classname:LineIterator name:operator *
ignore (method) operator * in cv::LineIterator

--- Incoming ---
[   u'cv.LineIterator.operator ++',
    u'LineIterator&',
    ['/NW'],
    [],
    u'prefix increment operator (++it). shifts iterator to the next pixel\n']
parseName: cv.LineIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
[   u'cv.LineIterator.operator ++',
    u'LineIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'postfix increment operator (it++). shifts iterator to the next pixel\n']
parseName: cv.LineIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator::operator ++ namespace:cv classpath:LineIterator classname:LineIterator name:operator ++
ignore (method) operator ++ in cv::LineIterator

--- Incoming ---
[   u'cv.LineIterator.pos',
    u'Point',
    ['/NW', '/C'],
    [],
    u'returns coordinates of the current pixel\n']
parseName: cv.LineIterator.pos with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::LineIterator::pos namespace:cv classpath:LineIterator classname:LineIterator name:pos
register (method) pos in cv::LineIterator

--- Incoming ---
[   u'cv.ellipse2Poly',
    u'void',
    ['/NW'],
    [   [u'Point', u'center', '', []],
        [u'Size', u'axes', '', []],
        [u'int', u'angle', '', []],
        [u'int', u'arcStart', '', []],
        [u'int', u'arcEnd', '', []],
        [u'int', u'delta', '', []],
        [u'vector<Point>&', u'pts', '', []]],
    u'converts elliptic arc to a polygonal curve\n']
parseName: cv.ellipse2Poly with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ellipse2Poly namespace:cv classpath: classname: name:ellipse2Poly
register (function) ellipse2Poly

--- Incoming ---
[u'const cv.FONT_HERSHEY_SIMPLEX', u'0', [], []]
parseName: const cv.FONT_HERSHEY_SIMPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SIMPLEX

--- Incoming ---
[u'const cv.FONT_HERSHEY_PLAIN', u'1', [], []]
parseName: const cv.FONT_HERSHEY_PLAIN with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_PLAIN namespace:cv classpath: classname: name:FONT_HERSHEY_PLAIN

--- Incoming ---
[u'const cv.FONT_HERSHEY_DUPLEX', u'2', [], []]
parseName: const cv.FONT_HERSHEY_DUPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_DUPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_DUPLEX

--- Incoming ---
[u'const cv.FONT_HERSHEY_COMPLEX', u'3', [], []]
parseName: const cv.FONT_HERSHEY_COMPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX

--- Incoming ---
[u'const cv.FONT_HERSHEY_TRIPLEX', u'4', [], []]
parseName: const cv.FONT_HERSHEY_TRIPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_TRIPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_TRIPLEX

--- Incoming ---
[u'const cv.FONT_HERSHEY_COMPLEX_SMALL', u'5', [], []]
parseName: const cv.FONT_HERSHEY_COMPLEX_SMALL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_COMPLEX_SMALL namespace:cv classpath: classname: name:FONT_HERSHEY_COMPLEX_SMALL

--- Incoming ---
[u'const cv.FONT_HERSHEY_SCRIPT_SIMPLEX', u'6', [], []]
parseName: const cv.FONT_HERSHEY_SCRIPT_SIMPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_SCRIPT_SIMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_SIMPLEX

--- Incoming ---
[u'const cv.FONT_HERSHEY_SCRIPT_COMPLEX', u'7', [], []]
parseName: const cv.FONT_HERSHEY_SCRIPT_COMPLEX with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_HERSHEY_SCRIPT_COMPLEX namespace:cv classpath: classname: name:FONT_HERSHEY_SCRIPT_COMPLEX

--- Incoming ---
[u'const cv.FONT_ITALIC', u'16', [], []]
parseName: const cv.FONT_ITALIC with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FONT_ITALIC namespace:cv classpath: classname: name:FONT_ITALIC

--- Incoming ---
[   u'cv.putText',
    u'void',
    ['/NW'],
    [   [u'Mat&', u'img', '', []],
        [u'const string&', u'text', '', []],
        [u'Point', u'org', '', []],
        [u'int', u'fontFace', '', []],
        [u'double', u'fontScale', '', []],
        [u'Scalar', u'color', '', []],
        [u'int', u'thickness', u'1', []],
        [u'int', u'lineType', u'8', []],
        [u'bool', u'bottomLeftOrigin', u'false', []]],
    u'renders text string in the image\n']
parseName: cv.putText with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::putText namespace:cv classpath: classname: name:putText
register (function) putText

--- Incoming ---
[   u'cv.getTextSize',
    u'Size',
    ['/NW'],
    [   [u'const string&', u'text', '', []],
        [u'int', u'fontFace', '', []],
        [u'double', u'fontScale', '', []],
        [u'int', u'thickness', '', []],
        [u'int*', u'baseLine', '', []]],
    u'returns bounding box of the text string\n']
parseName: cv.getTextSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getTextSize namespace:cv classpath: classname: name:getTextSize
register (function) getTextSize

--- Incoming ---
[u'class cv.MatConstIterator', '', [], [], '']
parseName: class cv.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator namespace:cv classpath: classname: name:MatConstIterator
register class cv::MatConstIterator ([u'class cv.MatConstIterator', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [],
    u'default constructor\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [[u'const Mat*', u'_m', '', []]],
    u'constructor that sets the iterator to the beginning of the matrix\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [   [u'const Mat*', u'_m', '', []],
        [u'int', u'_row', '', []],
        [u'int', u'_col', u'0', []]],
    u'constructor that sets the iterator to the specified element of the matrix\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [[u'const Mat*', u'_m', '', []], [u'Point', u'_pt', '', []]],
    u'constructor that sets the iterator to the specified element of the matrix\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [[u'const Mat*', u'_m', '', []], [u'const int*', u'_idx', '', []]],
    u'constructor that sets the iterator to the specified element of the matrix\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.MatConstIterator',
    u'',
    ['/NW'],
    [[u'const MatConstIterator&', u'it', '', []]],
    u'copy constructor\n']
parseName: cv.MatConstIterator.MatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::MatConstIterator namespace:cv classpath:MatConstIterator classname:MatConstIterator name:MatConstIterator
register (constructor) new in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator =',
    u'MatConstIterator&',
    ['/NW'],
    [[u'const MatConstIterator&', u'it', '', []]],
    u'copy operator\n']
parseName: cv.MatConstIterator.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator = namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator =
ignore (method) operator = in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator *',
    u'uchar*',
    ['/NW', '/C'],
    [],
    u'returns the current matrix element\n']
parseName: cv.MatConstIterator.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator * namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator *
ignore (method) operator * in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator []',
    u'uchar*',
    ['/NW', '/C'],
    [[u'ptrdiff_t', u'i', '', []]],
    u'returns the i-th matrix element, relative to the current\n']
parseName: cv.MatConstIterator.operator [] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator [] namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator []
Registering an unknown type: ptrdiff_t
ignore (method) operator [] in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator +=',
    u'MatConstIterator&',
    ['/NW'],
    [[u'ptrdiff_t', u'ofs', '', []]],
    u'shifts the iterator forward by the specified number of elements\n']
parseName: cv.MatConstIterator.operator += with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator += namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator +=
ignore (method) operator += in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator -=',
    u'MatConstIterator&',
    ['/NW'],
    [[u'ptrdiff_t', u'ofs', '', []]],
    u'shifts the iterator backward by the specified number of elements\n']
parseName: cv.MatConstIterator.operator -= with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator -= namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator -=
ignore (method) operator -= in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator --',
    u'MatConstIterator&',
    ['/NW'],
    [],
    u'decrements the iterator\n']
parseName: cv.MatConstIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator -- namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator --
ignore (method) operator -- in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator --',
    u'MatConstIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'decrements the iterator\n']
parseName: cv.MatConstIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator -- namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator --
ignore (method) operator -- in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator ++',
    u'MatConstIterator&',
    ['/NW'],
    [],
    u'increments the iterator\n']
parseName: cv.MatConstIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator ++ namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator ++
ignore (method) operator ++ in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.operator ++',
    u'MatConstIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'increments the iterator\n']
parseName: cv.MatConstIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::operator ++ namespace:cv classpath:MatConstIterator classname:MatConstIterator name:operator ++
ignore (method) operator ++ in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.pos',
    u'Point',
    ['/NW', '/C'],
    [],
    u'returns the current iterator position\n']
parseName: cv.MatConstIterator.pos with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::pos namespace:cv classpath:MatConstIterator classname:MatConstIterator name:pos
register (method) pos in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.pos',
    u'void',
    ['/NW', '/C'],
    [[u'int*', u'_idx', '', []]],
    u'returns the current iterator position\n']
parseName: cv.MatConstIterator.pos with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::pos namespace:cv classpath:MatConstIterator classname:MatConstIterator name:pos
register (method) pos in cv::MatConstIterator

--- Incoming ---
[u'cv.MatConstIterator.lpos', u'ptrdiff_t', ['/NW', '/C'], [], '']
parseName: cv.MatConstIterator.lpos with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::lpos namespace:cv classpath:MatConstIterator classname:MatConstIterator name:lpos
register (method) lpos in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.seek',
    u'void',
    ['/NW'],
    [[u'ptrdiff_t', u'ofs', '', []], [u'bool', u'relative', u'false', []]],
    '']
parseName: cv.MatConstIterator.seek with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::seek namespace:cv classpath:MatConstIterator classname:MatConstIterator name:seek
register (method) seek in cv::MatConstIterator

--- Incoming ---
[   u'cv.MatConstIterator.seek',
    u'void',
    ['/NW'],
    [[u'const int*', u'_idx', '', []], [u'bool', u'relative', u'false', []]],
    '']
parseName: cv.MatConstIterator.seek with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::MatConstIterator::seek namespace:cv classpath:MatConstIterator classname:MatConstIterator name:seek
register (method) seek in cv::MatConstIterator

--- Incoming ---
[   u'class cv.NAryMatIterator',
    '',
    [],
    [],
    u'n-Dimensional Dense Matrix Iterator Class.\n\nThe class cv::NAryMatIterator is used for iterating over one or more n-dimensional dense arrays (cv::Mat\'s).\n\nThe iterator is completely different from cv::Mat_ and cv::SparseMat_ iterators.\nIt iterates through the slices (or planes), not the elements, where "slice" is a continuous part of the arrays.\n\nHere is the example on how the iterator can be used to normalize 3D histogram:\n\n\\code\nvoid normalizeColorHist(Mat& hist)\n{\n#if 1\n// intialize iterator (the style is different from STL).\n// after initialization the iterator will contain\n// the number of slices or planes\n// the iterator will go through\nMat* arrays[] = { &hist, 0 };\nMat planes[1];\nNAryMatIterator it(arrays, planes);\ndouble s = 0;\n// iterate through the matrix. on each iteration\n// it.planes[i] (of type Mat) will be set to the current plane of\n// i-th n-dim matrix passed to the iterator constructor.\nfor(int p = 0; p < it.nplanes; p++, ++it)\ns += sum(it.planes[0])[0];\nit = NAryMatIterator(hist);\ns = 1./s;\nfor(int p = 0; p < it.nplanes; p++, ++it)\nit.planes[0] *= s;\n#elif 1\n// this is a shorter implementation of the above\n// using built-in operations on Mat\ndouble s = sum(hist)[0];\nhist.convertTo(hist, hist.type(), 1./s, 0);\n#else\n// and this is even shorter one\n// (assuming that the histogram elements are non-negative)\nnormalize(hist, hist, 1, 0, NORM_L1);\n#endif\n}\n\\endcode\n\nYou can iterate through several matrices simultaneously as long as they have the same geometry\n(dimensionality and all the dimension sizes are the same), which is useful for binary\nand n-ary operations on such matrices. Just pass those matrices to cv::MatNDIterator.\nThen, during the iteration it.planes[0], it.planes[1], ... will\nbe the slices of the corresponding matrices\n']
parseName: class cv.NAryMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator namespace:cv classpath: classname: name:NAryMatIterator
register class cv::NAryMatIterator ([u'class cv.NAryMatIterator', '', [], [], u'n-Dimensional Dense Matrix Iterator Class.\n\nThe class cv::NAryMatIterator is used for iterating over one or more n-dimensional dense arrays (cv::Mat\'s).\n\nThe iterator is completely different from cv::Mat_ and cv::SparseMat_ iterators.\nIt iterates through the slices (or planes), not the elements, where "slice" is a continuous part of the arrays.\n\nHere is the example on how the iterator can be used to normalize 3D histogram:\n\n\\code\nvoid normalizeColorHist(Mat& hist)\n{\n#if 1\n// intialize iterator (the style is different from STL).\n// after initialization the iterator will contain\n// the number of slices or planes\n// the iterator will go through\nMat* arrays[] = { &hist, 0 };\nMat planes[1];\nNAryMatIterator it(arrays, planes);\ndouble s = 0;\n// iterate through the matrix. on each iteration\n// it.planes[i] (of type Mat) will be set to the current plane of\n// i-th n-dim matrix passed to the iterator constructor.\nfor(int p = 0; p < it.nplanes; p++, ++it)\ns += sum(it.planes[0])[0];\nit = NAryMatIterator(hist);\ns = 1./s;\nfor(int p = 0; p < it.nplanes; p++, ++it)\nit.planes[0] *= s;\n#elif 1\n// this is a shorter implementation of the above\n// using built-in operations on Mat\ndouble s = sum(hist)[0];\nhist.convertTo(hist, hist.type(), 1./s, 0);\n#else\n// and this is even shorter one\n// (assuming that the histogram elements are non-negative)\nnormalize(hist, hist, 1, 0, NORM_L1);\n#endif\n}\n\\endcode\n\nYou can iterate through several matrices simultaneously as long as they have the same geometry\n(dimensionality and all the dimension sizes are the same), which is useful for binary\nand n-ary operations on such matrices. Just pass those matrices to cv::MatNDIterator.\nThen, during the iteration it.planes[0], it.planes[1], ... will\nbe the slices of the corresponding matrices\n'])

--- Incoming ---
[   u'cv.NAryMatIterator.NAryMatIterator',
    u'',
    ['/NW'],
    [],
    u'the default constructor\n']
parseName: cv.NAryMatIterator.NAryMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::NAryMatIterator namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:NAryMatIterator
register (constructor) new in cv::NAryMatIterator

--- Incoming ---
[   u'cv.NAryMatIterator.NAryMatIterator',
    u'',
    ['/NW'],
    [   [u'const Mat**', u'arrays', '', []],
        [u'uchar**', u'ptrs', '', []],
        [u'int', u'narrays', u'-1', []]],
    u'the full constructor taking arbitrary number of n-dim matrices\n']
parseName: cv.NAryMatIterator.NAryMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::NAryMatIterator namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:NAryMatIterator
register (constructor) new in cv::NAryMatIterator

--- Incoming ---
[   u'cv.NAryMatIterator.NAryMatIterator',
    u'',
    ['/NW'],
    [   [u'const Mat**', u'arrays', '', []],
        [u'Mat*', u'planes', '', []],
        [u'int', u'narrays', u'-1', []]],
    u'the full constructor taking arbitrary number of n-dim matrices\n']
parseName: cv.NAryMatIterator.NAryMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::NAryMatIterator namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:NAryMatIterator
register (constructor) new in cv::NAryMatIterator

--- Incoming ---
[   u'cv.NAryMatIterator.init',
    u'void',
    ['/NW'],
    [   [u'const Mat**', u'arrays', '', []],
        [u'Mat*', u'planes', '', []],
        [u'uchar**', u'ptrs', '', []],
        [u'int', u'narrays', u'-1', []]],
    u'the separate iterator initialization method\n']
parseName: cv.NAryMatIterator.init with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::init namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:init
register (method) init in cv::NAryMatIterator

--- Incoming ---
[   u'cv.NAryMatIterator.operator ++',
    u'NAryMatIterator&',
    ['/NW'],
    [],
    u'proceeds to the next plane of every iterated matrix\n']
parseName: cv.NAryMatIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::operator ++ namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:operator ++
ignore (method) operator ++ in cv::NAryMatIterator

--- Incoming ---
[   u'cv.NAryMatIterator.operator ++',
    u'NAryMatIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'proceeds to the next plane of every iterated matrix (postfix increment operator)\n']
parseName: cv.NAryMatIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::NAryMatIterator::operator ++ namespace:cv classpath:NAryMatIterator classname:NAryMatIterator name:operator ++
ignore (method) operator ++ in cv::NAryMatIterator

--- Incoming ---
[   u'cv.getConvertElem',
    u'ConvertData',
    ['/NW'],
    [[u'int', u'fromType', '', []], [u'int', u'toType', '', []]],
    u'returns the function for converting pixels from one data type to another\n']
parseName: cv.getConvertElem with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getConvertElem namespace:cv classpath: classname: name:getConvertElem
Registering an unknown type: ConvertData
register (function) getConvertElem

--- Incoming ---
[   u'cv.getConvertScaleElem',
    u'ConvertScaleData',
    ['/NW'],
    [[u'int', u'fromType', '', []], [u'int', u'toType', '', []]],
    u'returns the function for converting pixels from one data type to another with the optional scaling\n']
parseName: cv.getConvertScaleElem with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::getConvertScaleElem namespace:cv classpath: classname: name:getConvertScaleElem
Registering an unknown type: ConvertScaleData
register (function) getConvertScaleElem

--- Incoming ---
[   u'class cv.SparseMat',
    '',
    [],
    [],
    u'Sparse matrix class.\n\nThe class represents multi-dimensional sparse numerical arrays. Such a sparse array can store elements\nof any type that cv::Mat is able to store. "Sparse" means that only non-zero elements\nare stored (though, as a result of some operations on a sparse matrix, some of its stored elements\ncan actually become 0. It\'s user responsibility to detect such elements and delete them using cv::SparseMat::erase().\nThe non-zero elements are stored in a hash table that grows when it\'s filled enough,\nso that the search time remains O(1) in average. Elements can be accessed using the following methods:\n\n<ol>\n<li>Query operations: cv::SparseMat::ptr() and the higher-level cv::SparseMat::ref(),\ncv::SparseMat::value() and cv::SparseMat::find, for example:\n\\code\nconst int dims = 5;\nint size[] = {10, 10, 10, 10, 10};\nSparseMat sparse_mat(dims, size, CV_32F);\nfor(int i = 0; i < 1000; i++)\n{\nint idx[dims];\nfor(int k = 0; k < dims; k++)\nidx[k] = rand()%sparse_mat.size(k);\nsparse_mat.ref<float>(idx) += 1.f;\n}\n\\endcode\n\n<li>Sparse matrix iterators. Like cv::Mat iterators and unlike cv::Mat iterators, the sparse matrix iterators are STL-style,\nthat is, the iteration is done as following:\n\\code\n// prints elements of a sparse floating-point matrix and the sum of elements.\nSparseMatConstIterator_<float>\nit = sparse_mat.begin<float>(),\nit_end = sparse_mat.end<float>();\ndouble s = 0;\nint dims = sparse_mat.dims();\nfor(; it != it_end; ++it)\n{\n// print element indices and the element value\nconst Node* n = it.node();\nprintf("(")\nfor(int i = 0; i < dims; i++)\nprintf("%3d%c", n->idx[i], i < dims-1 ? \',\' : \')\');\nprintf(": %f\\n", *it);\ns += *it;\n}\nprintf("Element sum is %g\\n", s);\n\\endcode\nIf you run this loop, you will notice that elements are enumerated\nin no any logical order (lexicographical etc.),\nthey come in the same order as they stored in the hash table, i.e. semi-randomly.\n\nYou may collect pointers to the nodes and sort them to get the proper ordering.\nNote, however, that pointers to the nodes may become invalid when you add more\nelements to the matrix; this is because of possible buffer reallocation.\n\n<li>A combination of the above 2 methods when you need to process 2 or more sparse\nmatrices simultaneously, e.g. this is how you can compute unnormalized\ncross-correlation of the 2 floating-point sparse matrices:\n\\code\ndouble crossCorr(const SparseMat& a, const SparseMat& b)\n{\nconst SparseMat *_a = &a, *_b = &b;\n// if b contains less elements than a,\n// it\'s faster to iterate through b\nif(_a->nzcount() > _b->nzcount())\nstd::swap(_a, _b);\nSparseMatConstIterator_<float> it = _a->begin<float>(),\nit_end = _a->end<float>();\ndouble ccorr = 0;\nfor(; it != it_end; ++it)\n{\n// take the next element from the first matrix\nfloat avalue = *it;\nconst Node* anode = it.node();\n// and try to find element with the same index in the second matrix.\n// since the hash value depends only on the element index,\n// we reuse hashvalue stored in the node\nfloat bvalue = _b->value<float>(anode->idx,&anode->hashval);\nccorr += avalue*bvalue;\n}\nreturn ccorr;\n}\n\\endcode\n</ol>\n']
parseName: class cv.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat namespace:cv classpath: classname: name:SparseMat
register class cv::SparseMat ([u'class cv.SparseMat', '', [], [], u'Sparse matrix class.\n\nThe class represents multi-dimensional sparse numerical arrays. Such a sparse array can store elements\nof any type that cv::Mat is able to store. "Sparse" means that only non-zero elements\nare stored (though, as a result of some operations on a sparse matrix, some of its stored elements\ncan actually become 0. It\'s user responsibility to detect such elements and delete them using cv::SparseMat::erase().\nThe non-zero elements are stored in a hash table that grows when it\'s filled enough,\nso that the search time remains O(1) in average. Elements can be accessed using the following methods:\n\n<ol>\n<li>Query operations: cv::SparseMat::ptr() and the higher-level cv::SparseMat::ref(),\ncv::SparseMat::value() and cv::SparseMat::find, for example:\n\\code\nconst int dims = 5;\nint size[] = {10, 10, 10, 10, 10};\nSparseMat sparse_mat(dims, size, CV_32F);\nfor(int i = 0; i < 1000; i++)\n{\nint idx[dims];\nfor(int k = 0; k < dims; k++)\nidx[k] = rand()%sparse_mat.size(k);\nsparse_mat.ref<float>(idx) += 1.f;\n}\n\\endcode\n\n<li>Sparse matrix iterators. Like cv::Mat iterators and unlike cv::Mat iterators, the sparse matrix iterators are STL-style,\nthat is, the iteration is done as following:\n\\code\n// prints elements of a sparse floating-point matrix and the sum of elements.\nSparseMatConstIterator_<float>\nit = sparse_mat.begin<float>(),\nit_end = sparse_mat.end<float>();\ndouble s = 0;\nint dims = sparse_mat.dims();\nfor(; it != it_end; ++it)\n{\n// print element indices and the element value\nconst Node* n = it.node();\nprintf("(")\nfor(int i = 0; i < dims; i++)\nprintf("%3d%c", n->idx[i], i < dims-1 ? \',\' : \')\');\nprintf(": %f\\n", *it);\ns += *it;\n}\nprintf("Element sum is %g\\n", s);\n\\endcode\nIf you run this loop, you will notice that elements are enumerated\nin no any logical order (lexicographical etc.),\nthey come in the same order as they stored in the hash table, i.e. semi-randomly.\n\nYou may collect pointers to the nodes and sort them to get the proper ordering.\nNote, however, that pointers to the nodes may become invalid when you add more\nelements to the matrix; this is because of possible buffer reallocation.\n\n<li>A combination of the above 2 methods when you need to process 2 or more sparse\nmatrices simultaneously, e.g. this is how you can compute unnormalized\ncross-correlation of the 2 floating-point sparse matrices:\n\\code\ndouble crossCorr(const SparseMat& a, const SparseMat& b)\n{\nconst SparseMat *_a = &a, *_b = &b;\n// if b contains less elements than a,\n// it\'s faster to iterate through b\nif(_a->nzcount() > _b->nzcount())\nstd::swap(_a, _b);\nSparseMatConstIterator_<float> it = _a->begin<float>(),\nit_end = _a->end<float>();\ndouble ccorr = 0;\nfor(; it != it_end; ++it)\n{\n// take the next element from the first matrix\nfloat avalue = *it;\nconst Node* anode = it.node();\n// and try to find element with the same index in the second matrix.\n// since the hash value depends only on the element index,\n// we reuse hashvalue stored in the node\nfloat bvalue = _b->value<float>(anode->idx,&anode->hashval);\nccorr += avalue*bvalue;\n}\nreturn ccorr;\n}\n\\endcode\n</ol>\n']) [ignored]

--- Incoming ---
[u'struct cv.SparseMat.Hdr', '', [], [], u'the sparse matrix header\n']
parseName: struct cv.SparseMat.Hdr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::Hdr namespace:cv classpath:SparseMat classname:SparseMat name:Hdr
register class cv::SparseMat::Hdr ([u'struct cv.SparseMat.Hdr', '', [], [], u'the sparse matrix header\n']) [ignored]

--- Incoming ---
[   u'cv.SparseMat.Hdr.Hdr',
    u'',
    ['/NW'],
    [   [u'int', u'_dims', '', []],
        [u'const int*', u'_sizes', '', []],
        [u'int', u'_type', '', []]],
    '']
parseName: cv.SparseMat.Hdr.Hdr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::Hdr::Hdr namespace:cv classpath:SparseMat::Hdr classname:Hdr name:Hdr
register (constructor) new in cv::SparseMat::Hdr

--- Incoming ---
[u'cv.SparseMat.Hdr.clear', u'void', ['/NW'], [], '']
parseName: cv.SparseMat.Hdr.clear with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::Hdr::clear namespace:cv classpath:SparseMat::Hdr classname:Hdr name:clear
register (method) clear in cv::SparseMat::Hdr

--- Incoming ---
[   u'struct cv.SparseMat.Node',
    '',
    [],
    [],
    u'sparse matrix node - element of a hash table\n']
parseName: struct cv.SparseMat.Node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::Node namespace:cv classpath:SparseMat classname:SparseMat name:Node
register class cv::SparseMat::Node ([u'struct cv.SparseMat.Node', '', [], [], u'sparse matrix node - element of a hash table\n']) [ignored]

--- Incoming ---
[u'cv.SparseMat.SparseMat', u'', ['/NW'], [], u'default constructor\n']
parseName: cv.SparseMat.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:SparseMat
register (constructor) new in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.SparseMat',
    u'',
    ['/NW'],
    [   [u'int', u'dims', '', []],
        [u'const int*', u'_sizes', '', []],
        [u'int', u'_type', '', []]],
    u'creates matrix of the specified size and type\n']
parseName: cv.SparseMat.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:SparseMat
register (constructor) new in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.SparseMat',
    u'',
    ['/NW'],
    [[u'const SparseMat&', u'm', '', []]],
    u'copy constructor\n']
parseName: cv.SparseMat.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:SparseMat
register (constructor) new in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.SparseMat',
    u'',
    ['/NW', '/E'],
    [[u'const Mat&', u'm', '', []]],
    u'\\param m the input matrix\n']
parseName: cv.SparseMat.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:SparseMat
register (constructor) new in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.SparseMat',
    u'',
    ['/NW'],
    [[u'const CvSparseMat*', u'm', '', []]],
    u'converts old-style sparse matrix to the new-style. All the data is copied\n']
parseName: cv.SparseMat.SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:SparseMat
register (constructor) new in cv::SparseMat

--- Incoming ---
[u'cv.SparseMat.~SparseMat', u'', ['/NW'], [], u'the destructor\n']
parseName: cv.SparseMat.~SparseMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::~SparseMat namespace:cv classpath:SparseMat classname:SparseMat name:~SparseMat
ignore destructor (method) ~SparseMat in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.operator =',
    u'SparseMat&',
    ['/NW'],
    [[u'const SparseMat&', u'm', '', []]],
    u'assignment operator. This is O(1) operation, i.e. no data is copied\n']
parseName: cv.SparseMat.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::operator = namespace:cv classpath:SparseMat classname:SparseMat name:operator =
ignore (method) operator = in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.operator =',
    u'SparseMat&',
    ['/NW'],
    [[u'const Mat&', u'm', '', []]],
    u'equivalent to the corresponding constructor\n']
parseName: cv.SparseMat.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::operator = namespace:cv classpath:SparseMat classname:SparseMat name:operator =
ignore (method) operator = in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.clone',
    u'SparseMat',
    ['/NW', '/C'],
    [],
    u'creates full copy of the matrix\n']
parseName: cv.SparseMat.clone with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::clone namespace:cv classpath:SparseMat classname:SparseMat name:clone
register (method) clone in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.copyTo',
    u'void',
    ['/NW', '/C'],
    [[u'SparseMat&', u'm', '', []]],
    u'copies all the data to the destination matrix. All the previous content of m is erased\n']
parseName: cv.SparseMat.copyTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::copyTo namespace:cv classpath:SparseMat classname:SparseMat name:copyTo
register (method) copyTo in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.copyTo',
    u'void',
    ['/NW', '/C'],
    [[u'Mat&', u'm', '', []]],
    u'converts sparse matrix to dense matrix.\n']
parseName: cv.SparseMat.copyTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::copyTo namespace:cv classpath:SparseMat classname:SparseMat name:copyTo
register (method) copyTo in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.convertTo',
    u'void',
    ['/NW', '/C'],
    [   [u'SparseMat&', u'm', '', []],
        [u'int', u'rtype', '', []],
        [u'double', u'alpha', u'1', []]],
    u'multiplies all the matrix elements by the specified scale factor alpha and converts the results to the specified data type\n']
parseName: cv.SparseMat.convertTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::convertTo namespace:cv classpath:SparseMat classname:SparseMat name:convertTo
register (method) convertTo in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.convertTo',
    u'void',
    ['/NW', '/C'],
    [   [u'Mat&', u'm', '', []],
        [u'int', u'rtype', '', []],
        [u'double', u'alpha', u'1', []],
        [u'double', u'beta', u'0', []]],
    u'\\param m Destination matrix\n\\param rtype The output matrix data type. When it is =-1, the output array will have the same data type as (*this)\n\\param alpha The scale factor\n\\param beta The optional delta added to the scaled values before the conversion\n']
parseName: cv.SparseMat.convertTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::convertTo namespace:cv classpath:SparseMat classname:SparseMat name:convertTo
register (method) convertTo in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.assignTo',
    u'void',
    ['/NW', '/C'],
    [[u'SparseMat&', u'm', '', []], [u'int', u'type', u'-1', []]],
    '']
parseName: cv.SparseMat.assignTo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::assignTo namespace:cv classpath:SparseMat classname:SparseMat name:assignTo
register (method) assignTo in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.create',
    u'void',
    ['/NW'],
    [   [u'int', u'dims', '', []],
        [u'const int*', u'_sizes', '', []],
        [u'int', u'_type', '', []]],
    u'If the matrix already had the proper size and type,\nit is simply cleared with clear(), otherwise,\nthe old matrix is released (using release()) and the new one is allocated.\n']
parseName: cv.SparseMat.create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::create namespace:cv classpath:SparseMat classname:SparseMat name:create
register (method) create in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.clear',
    u'void',
    ['/NW'],
    [],
    u'sets all the sparse matrix elements to 0, which means clearing the hash table.\n']
parseName: cv.SparseMat.clear with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::clear namespace:cv classpath:SparseMat classname:SparseMat name:clear
register (method) clear in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.addref',
    u'void',
    ['/NW'],
    [],
    u'manually increments the reference counter to the header.\n']
parseName: cv.SparseMat.addref with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::addref namespace:cv classpath:SparseMat classname:SparseMat name:addref
register (method) addref in cv::SparseMat

--- Incoming ---
[u'cv.SparseMat.release', u'void', ['/NW'], [], '']
parseName: cv.SparseMat.release with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::release namespace:cv classpath:SparseMat classname:SparseMat name:release
register (method) release in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.operator CvSparseMat*',
    u'',
    ['/NW', '/C'],
    [],
    u'converts sparse matrix to the old-style representation; all the elements are copied.\n']
parseName: cv.SparseMat.operator CvSparseMat* with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::operator CvSparseMat* namespace:cv classpath:SparseMat classname:SparseMat name:operator CvSparseMat*
ignore (method) operator CvSparseMat* in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.elemSize',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns the size of each element in bytes (not including the overhead - the space occupied by SparseMat::Node elements)\n']
parseName: cv.SparseMat.elemSize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::elemSize namespace:cv classpath:SparseMat classname:SparseMat name:elemSize
register (method) elemSize in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.elemSize1',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns elemSize()/channels()\n']
parseName: cv.SparseMat.elemSize1 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::elemSize1 namespace:cv classpath:SparseMat classname:SparseMat name:elemSize1
register (method) elemSize1 in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.type',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns type of sparse matrix elements\n']
parseName: cv.SparseMat.type with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::type namespace:cv classpath:SparseMat classname:SparseMat name:type
register (method) type in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.depth',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns the depth of sparse matrix elements\n']
parseName: cv.SparseMat.depth with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::depth namespace:cv classpath:SparseMat classname:SparseMat name:depth
register (method) depth in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.channels',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns the number of channels\n']
parseName: cv.SparseMat.channels with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::channels namespace:cv classpath:SparseMat classname:SparseMat name:channels
register (method) channels in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.size',
    u'const int*',
    ['/NW', '/C'],
    [],
    u'returns the array of sizes, or NULL if the matrix is not allocated\n']
parseName: cv.SparseMat.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::size namespace:cv classpath:SparseMat classname:SparseMat name:size
register (method) size in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.size',
    u'int',
    ['/NW', '/C'],
    [[u'int', u'i', '', []]],
    u'returns the size of i-th matrix dimension (or 0)\n']
parseName: cv.SparseMat.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::size namespace:cv classpath:SparseMat classname:SparseMat name:size
register (method) size in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.dims',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns the matrix dimensionality\n']
parseName: cv.SparseMat.dims with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::dims namespace:cv classpath:SparseMat classname:SparseMat name:dims
register (method) dims in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.nzcount',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns the number of non-zero elements (=the number of hash table nodes)\n']
parseName: cv.SparseMat.nzcount with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::nzcount namespace:cv classpath:SparseMat classname:SparseMat name:nzcount
register (method) nzcount in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.hash',
    u'size_t',
    ['/NW', '/C'],
    [[u'int', u'i0', '', []]],
    u'computes the element hash value (1D case)\n']
parseName: cv.SparseMat.hash with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::hash namespace:cv classpath:SparseMat classname:SparseMat name:hash
register (method) hash in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.hash',
    u'size_t',
    ['/NW', '/C'],
    [[u'int', u'i0', '', []], [u'int', u'i1', '', []]],
    u'computes the element hash value (2D case)\n']
parseName: cv.SparseMat.hash with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::hash namespace:cv classpath:SparseMat classname:SparseMat name:hash
register (method) hash in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.hash',
    u'size_t',
    ['/NW', '/C'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'int', u'i2', '', []]],
    u'computes the element hash value (3D case)\n']
parseName: cv.SparseMat.hash with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::hash namespace:cv classpath:SparseMat classname:SparseMat name:hash
register (method) hash in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.hash',
    u'size_t',
    ['/NW', '/C'],
    [[u'const int*', u'idx', '', []]],
    u'computes the element hash value (nD case)\n']
parseName: cv.SparseMat.hash with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::hash namespace:cv classpath:SparseMat classname:SparseMat name:hash
register (method) hash in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.ptr',
    u'uchar*',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'bool', u'createMissing', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u"specialized variants for 1D, 2D, 3D cases and the generic_type one for n-D case.\n\nreturn pointer to the matrix element.\n<ul>\n<li>if the element is there (it's non-zero), the pointer to it is returned\n<li>if it's not there and createMissing=false, NULL pointer is returned\n<li>if it's not there and createMissing=true, then the new element\nis created and initialized with 0. Pointer to it is returned\n<li>if the optional hashval pointer is not NULL, the element hash value is\nnot computed, but *hashval is taken instead.\n</ul>\nreturns pointer to the specified element (1D case)\n"]
parseName: cv.SparseMat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::ptr namespace:cv classpath:SparseMat classname:SparseMat name:ptr
register (method) ptr in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.ptr',
    u'uchar*',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'bool', u'createMissing', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u'returns pointer to the specified element (2D case)\n']
parseName: cv.SparseMat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::ptr namespace:cv classpath:SparseMat classname:SparseMat name:ptr
register (method) ptr in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.ptr',
    u'uchar*',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'int', u'i2', '', []],
        [u'bool', u'createMissing', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u'returns pointer to the specified element (3D case)\n']
parseName: cv.SparseMat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::ptr namespace:cv classpath:SparseMat classname:SparseMat name:ptr
register (method) ptr in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.ptr',
    u'uchar*',
    ['/NW'],
    [   [u'const int*', u'idx', '', []],
        [u'bool', u'createMissing', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u'returns pointer to the specified element (nD case)\n']
parseName: cv.SparseMat.ptr with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::ptr namespace:cv classpath:SparseMat classname:SparseMat name:ptr
register (method) ptr in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.erase',
    u'void',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u'erases the specified element (2D case)\n']
parseName: cv.SparseMat.erase with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::erase namespace:cv classpath:SparseMat classname:SparseMat name:erase
register (method) erase in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.erase',
    u'void',
    ['/NW'],
    [   [u'int', u'i0', '', []],
        [u'int', u'i1', '', []],
        [u'int', u'i2', '', []],
        [u'size_t*', u'hashval', u'0', []]],
    u'erases the specified element (3D case)\n']
parseName: cv.SparseMat.erase with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::erase namespace:cv classpath:SparseMat classname:SparseMat name:erase
register (method) erase in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.erase',
    u'void',
    ['/NW'],
    [[u'const int*', u'idx', '', []], [u'size_t*', u'hashval', u'0', []]],
    u'erases the specified element (nD case)\n']
parseName: cv.SparseMat.erase with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::erase namespace:cv classpath:SparseMat classname:SparseMat name:erase
register (method) erase in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.begin',
    u'SparseMatIterator',
    ['/NW'],
    [],
    u'return the sparse matrix iterator pointing to the first sparse matrix element\nreturns the sparse matrix iterator at the matrix beginning\n']
parseName: cv.SparseMat.begin with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::begin namespace:cv classpath:SparseMat classname:SparseMat name:begin
Registering an unknown type: SparseMatIterator
register (method) begin in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.begin',
    u'SparseMatConstIterator',
    ['/NW', '/C'],
    [],
    u'returns the read-only sparse matrix iterator at the matrix beginning\n']
parseName: cv.SparseMat.begin with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::begin namespace:cv classpath:SparseMat classname:SparseMat name:begin
Registering an unknown type: SparseMatConstIterator
register (method) begin in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.end',
    u'SparseMatIterator',
    ['/NW'],
    [],
    u'return the sparse matrix iterator pointing to the element following the last sparse matrix element\nreturns the sparse matrix iterator at the matrix end\n']
parseName: cv.SparseMat.end with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::end namespace:cv classpath:SparseMat classname:SparseMat name:end
register (method) end in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.end',
    u'SparseMatConstIterator',
    ['/NW', '/C'],
    [],
    u'returns the read-only sparse matrix iterator at the matrix end\n']
parseName: cv.SparseMat.end with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::end namespace:cv classpath:SparseMat classname:SparseMat name:end
register (method) end in cv::SparseMat

--- Incoming ---
[u'cv.SparseMat.node', u'Node*', ['/NW'], [[u'size_t', u'nidx', '', []]], '']
parseName: cv.SparseMat.node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::node namespace:cv classpath:SparseMat classname:SparseMat name:node
register (method) node in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.node',
    u'const Node*',
    ['/NW', '/C'],
    [[u'size_t', u'nidx', '', []]],
    '']
parseName: cv.SparseMat.node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::node namespace:cv classpath:SparseMat classname:SparseMat name:node
register (method) node in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.newNode',
    u'uchar*',
    ['/NW'],
    [[u'const int*', u'idx', '', []], [u'size_t', u'hashval', '', []]],
    '']
parseName: cv.SparseMat.newNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::newNode namespace:cv classpath:SparseMat classname:SparseMat name:newNode
register (method) newNode in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.removeNode',
    u'void',
    ['/NW'],
    [   [u'size_t', u'hidx', '', []],
        [u'size_t', u'nidx', '', []],
        [u'size_t', u'previdx', '', []]],
    '']
parseName: cv.SparseMat.removeNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::removeNode namespace:cv classpath:SparseMat classname:SparseMat name:removeNode
register (method) removeNode in cv::SparseMat

--- Incoming ---
[   u'cv.SparseMat.resizeHashTab',
    u'void',
    ['/NW'],
    [[u'size_t', u'newsize', '', []]],
    '']
parseName: cv.SparseMat.resizeHashTab with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::resizeHashTab namespace:cv classpath:SparseMat classname:SparseMat name:resizeHashTab
register (method) resizeHashTab in cv::SparseMat

--- Incoming ---
[u'const cv.SparseMat.MAGIC_VAL', u'0x42FD0000', [], []]
parseName: const cv.SparseMat.MAGIC_VAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::MAGIC_VAL namespace:cv classpath:SparseMat classname:SparseMat name:MAGIC_VAL

--- Incoming ---
[u'const cv.SparseMat.MAX_DIM', u'CV_MAX_DIM', [], []]
parseName: const cv.SparseMat.MAX_DIM with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::MAX_DIM namespace:cv classpath:SparseMat classname:SparseMat name:MAX_DIM

--- Incoming ---
[u'const cv.SparseMat.HASH_SCALE', u'0x5bd1e995', [], []]
parseName: const cv.SparseMat.HASH_SCALE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::HASH_SCALE namespace:cv classpath:SparseMat classname:SparseMat name:HASH_SCALE

--- Incoming ---
[u'const cv.SparseMat.HASH_BIT', u'0x80000000', [], []]
parseName: const cv.SparseMat.HASH_BIT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMat::HASH_BIT namespace:cv classpath:SparseMat classname:SparseMat name:HASH_BIT

--- Incoming ---
[   u'cv.minMaxLoc',
    u'void',
    ['/NW'],
    [   [u'const SparseMat&', u'a', '', []],
        [u'double*', u'minVal', '', []],
        [u'double*', u'maxVal', '', []],
        [u'int*', u'minIdx', u'0', []],
        [u'int*', u'maxIdx', u'0', []]],
    u'finds global minimum and maximum sparse array elements and returns their values and their locations\n']
parseName: cv.minMaxLoc with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::minMaxLoc namespace:cv classpath: classname: name:minMaxLoc
register (function) minMaxLoc

--- Incoming ---
[   u'cv.norm',
    u'double',
    ['/NW'],
    [[u'const SparseMat&', u'src', '', []], [u'int', u'normType', '', []]],
    u'computes norm of a sparse matrix\n']
parseName: cv.norm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::norm namespace:cv classpath: classname: name:norm
register (function) norm

--- Incoming ---
[   u'cv.normalize',
    u'void',
    ['/NW'],
    [   [u'const SparseMat&', u'src', '', []],
        [u'SparseMat&', u'dst', '', []],
        [u'double', u'alpha', '', []],
        [u'int', u'normType', '', []]],
    u'scales and shifts array elements so that either the specified norm (alpha) or the minimum (alpha) and maximum (beta) array values get the specified values\n']
parseName: cv.normalize with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::normalize namespace:cv classpath: classname: name:normalize
register (function) normalize

--- Incoming ---
[   u'class cv.SparseMatConstIterator',
    '',
    [],
    [],
    u'Read-Only Sparse Matrix Iterator.\nHere is how to use the iterator to compute the sum of floating-point sparse matrix elements:\n\n\\code\nSparseMatConstIterator it = m.begin(), it_end = m.end();\ndouble s = 0;\nCV_Assert( m.type() == CV_32F );\nfor( ; it != it_end; ++it )\ns += it.value<float>();\n\\endcode\n']
parseName: class cv.SparseMatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator namespace:cv classpath: classname: name:SparseMatConstIterator
register class cv::SparseMatConstIterator ([u'class cv.SparseMatConstIterator', '', [], [], u'Read-Only Sparse Matrix Iterator.\nHere is how to use the iterator to compute the sum of floating-point sparse matrix elements:\n\n\\code\nSparseMatConstIterator it = m.begin(), it_end = m.end();\ndouble s = 0;\nCV_Assert( m.type() == CV_32F );\nfor( ; it != it_end; ++it )\ns += it.value<float>();\n\\endcode\n']) [ignored]

--- Incoming ---
[   u'cv.SparseMatConstIterator.SparseMatConstIterator',
    u'',
    ['/NW'],
    [],
    u'the default constructor\n']
parseName: cv.SparseMatConstIterator.SparseMatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::SparseMatConstIterator namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:SparseMatConstIterator
register (constructor) new in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.SparseMatConstIterator',
    u'',
    ['/NW'],
    [[u'const SparseMat*', u'_m', '', []]],
    u'the full constructor setting the iterator to the first sparse matrix element\n']
parseName: cv.SparseMatConstIterator.SparseMatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::SparseMatConstIterator namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:SparseMatConstIterator
register (constructor) new in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.SparseMatConstIterator',
    u'',
    ['/NW'],
    [[u'const SparseMatConstIterator&', u'it', '', []]],
    u'the copy constructor\n']
parseName: cv.SparseMatConstIterator.SparseMatConstIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::SparseMatConstIterator namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:SparseMatConstIterator
register (constructor) new in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.operator =',
    u'SparseMatConstIterator&',
    ['/NW'],
    [[u'const SparseMatConstIterator&', u'it', '', []]],
    u'the assignment operator\n']
parseName: cv.SparseMatConstIterator.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::operator = namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:operator =
ignore (method) operator = in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.node',
    u'const SparseMat::Node*',
    ['/NW', '/C'],
    [],
    u'returns the current node of the sparse matrix. it.node->idx is the current element index\n']
parseName: cv.SparseMatConstIterator.node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::node namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:node
register (method) node in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.operator --',
    u'SparseMatConstIterator&',
    ['/NW'],
    [],
    u'moves iterator to the previous element\n']
parseName: cv.SparseMatConstIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::operator -- namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:operator --
ignore (method) operator -- in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.operator --',
    u'SparseMatConstIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'moves iterator to the previous element\n']
parseName: cv.SparseMatConstIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::operator -- namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:operator --
ignore (method) operator -- in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.operator ++',
    u'SparseMatConstIterator&',
    ['/NW'],
    [],
    u'moves iterator to the next element\n']
parseName: cv.SparseMatConstIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::operator ++ namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:operator ++
ignore (method) operator ++ in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.operator ++',
    u'SparseMatConstIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'moves iterator to the next element\n']
parseName: cv.SparseMatConstIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::operator ++ namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:operator ++
ignore (method) operator ++ in cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatConstIterator.seekEnd',
    u'void',
    ['/NW'],
    [],
    u'moves iterator to the element after the last element\n']
parseName: cv.SparseMatConstIterator.seekEnd with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatConstIterator::seekEnd namespace:cv classpath:SparseMatConstIterator classname:SparseMatConstIterator name:seekEnd
register (method) seekEnd in cv::SparseMatConstIterator

--- Incoming ---
[   u'class cv.SparseMatIterator',
    u': cv::SparseMatConstIterator',
    [],
    [],
    u'Read-write Sparse Matrix Iterator\n\nThe class is similar to cv::SparseMatConstIterator,\nbut can be used for in-place modification of the matrix elements.\n']
parseName: class cv.SparseMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator namespace:cv classpath: classname: name:SparseMatIterator
register class cv::SparseMatIterator ([u'class cv.SparseMatIterator', u': cv::SparseMatConstIterator', [], [], u'Read-write Sparse Matrix Iterator\n\nThe class is similar to cv::SparseMatConstIterator,\nbut can be used for in-place modification of the matrix elements.\n']) [ignored] impl:cv::SparseMatConstIterator

--- Incoming ---
[   u'cv.SparseMatIterator.SparseMatIterator',
    u'',
    ['/NW'],
    [],
    u'the default constructor\n']
parseName: cv.SparseMatIterator.SparseMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::SparseMatIterator namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:SparseMatIterator
register (constructor) new in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.SparseMatIterator',
    u'',
    ['/NW'],
    [[u'SparseMat*', u'_m', '', []]],
    u'the full constructor setting the iterator to the first sparse matrix element\n']
parseName: cv.SparseMatIterator.SparseMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::SparseMatIterator namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:SparseMatIterator
register (constructor) new in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.SparseMatIterator',
    u'',
    ['/NW'],
    [[u'SparseMat*', u'_m', '', []], [u'const int*', u'idx', '', []]],
    u'the full constructor setting the iterator to the specified sparse matrix element\n']
parseName: cv.SparseMatIterator.SparseMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::SparseMatIterator namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:SparseMatIterator
register (constructor) new in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.SparseMatIterator',
    u'',
    ['/NW'],
    [[u'const SparseMatIterator&', u'it', '', []]],
    u'the copy constructor\n']
parseName: cv.SparseMatIterator.SparseMatIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::SparseMatIterator namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:SparseMatIterator
register (constructor) new in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.operator =',
    u'SparseMatIterator&',
    ['/NW'],
    [[u'const SparseMatIterator&', u'it', '', []]],
    u'the assignment operator\n']
parseName: cv.SparseMatIterator.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::operator = namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:operator =
ignore (method) operator = in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.node',
    u'SparseMat::Node*',
    ['/NW', '/C'],
    [],
    u'returns pointer to the current sparse matrix node. it.node->idx is the index of the current element (do not modify it!)\n']
parseName: cv.SparseMatIterator.node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::node namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:node
register (method) node in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.operator ++',
    u'SparseMatIterator&',
    ['/NW'],
    [],
    u'moves iterator to the next element\n']
parseName: cv.SparseMatIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::operator ++ namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:operator ++
ignore (method) operator ++ in cv::SparseMatIterator

--- Incoming ---
[   u'cv.SparseMatIterator.operator ++',
    u'SparseMatIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'moves iterator to the next element\n']
parseName: cv.SparseMatIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::SparseMatIterator::operator ++ namespace:cv classpath:SparseMatIterator classname:SparseMatIterator name:operator ++
ignore (method) operator ++ in cv::SparseMatIterator

--- Incoming ---
[   u'class cv.KDTree',
    '',
    [],
    [   [u'Mat', u'points', '', []],
        [u'vector_int', u'labels', '', []],
        [u'int', u'maxDepth', '', []],
        [u'int', u'normType', '', ['/RW']]],
    u'Fast Nearest Neighbor Search Class.\n\nThe class implements D. Lowe BBF (Best-Bin-First) algorithm for the last\napproximate (or accurate) nearest neighbor search in multi-dimensional spaces.\n\nFirst, a set of vectors is passed to KDTree::KDTree() constructor\nor KDTree::build() method, where it is reordered.\n\nThen arbitrary vectors can be passed to KDTree::findNearest() methods, which\nfind the K nearest neighbors among the vectors from the initial set.\nThe user can balance between the speed and accuracy of the search by varying Emax\nparameter, which is the number of leaves that the algorithm checks.\nThe larger parameter values yield more accurate results at the expense of lower processing speed.\n\n\\code\nKDTree T(points, false);\nconst int K = 3, Emax = INT_MAX;\nint idx[K];\nfloat dist[K];\nT.findNearest(query_vec, K, Emax, idx, 0, dist);\nCV_Assert(dist[0] <= dist[1] && dist[1] <= dist[2]);\n\\endcode\n']
parseName: class cv.KDTree with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree namespace:cv classpath: classname: name:KDTree
register class cv::KDTree ([u'class cv.KDTree', '', [], [[u'Mat', u'points', '', []], [u'vector_int', u'labels', '', []], [u'int', u'maxDepth', '', []], [u'int', u'normType', '', ['/RW']]], u'Fast Nearest Neighbor Search Class.\n\nThe class implements D. Lowe BBF (Best-Bin-First) algorithm for the last\napproximate (or accurate) nearest neighbor search in multi-dimensional spaces.\n\nFirst, a set of vectors is passed to KDTree::KDTree() constructor\nor KDTree::build() method, where it is reordered.\n\nThen arbitrary vectors can be passed to KDTree::findNearest() methods, which\nfind the K nearest neighbors among the vectors from the initial set.\nThe user can balance between the speed and accuracy of the search by varying Emax\nparameter, which is the number of leaves that the algorithm checks.\nThe larger parameter values yield more accurate results at the expense of lower processing speed.\n\n\\code\nKDTree T(points, false);\nconst int K = 3, Emax = INT_MAX;\nint idx[K];\nfloat dist[K];\nT.findNearest(query_vec, K, Emax, idx, 0, dist);\nCV_Assert(dist[0] <= dist[1] && dist[1] <= dist[2]);\n\\endcode\n']) [ignored]

--- Incoming ---
[u'struct cv.KDTree.Node', '', [], [], u'The node of the search tree.\n']
parseName: struct cv.KDTree.Node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::Node namespace:cv classpath:KDTree classname:KDTree name:Node
register class cv::KDTree::Node ([u'struct cv.KDTree.Node', '', [], [], u'The node of the search tree.\n']) [ignored]

--- Incoming ---
[u'cv.KDTree.Node.Node', u'', ['/NW'], [], '']
parseName: cv.KDTree.Node.Node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::Node::Node namespace:cv classpath:KDTree::Node classname:Node name:Node
register (constructor) new in cv::SparseMat::Node

--- Incoming ---
[   u'cv.KDTree.Node.Node',
    u'',
    ['/NW'],
    [   [u'int', u'_idx', '', []],
        [u'int', u'_left', '', []],
        [u'int', u'_right', '', []],
        [u'float', u'_boundary', '', []]],
    '']
parseName: cv.KDTree.Node.Node with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::Node::Node namespace:cv classpath:KDTree::Node classname:Node name:Node
register (constructor) new in cv::SparseMat::Node

--- Incoming ---
[u'cv.KDTree.KDTree', u'', ['/NW'], [], u'the default constructor\n']
parseName: cv.KDTree.KDTree with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::KDTree namespace:cv classpath:KDTree classname:KDTree name:KDTree
register (constructor) new in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.KDTree',
    u'',
    ['/NW'],
    [   [u'InputArray', u'points', '', []],
        [u'bool', u'copyAndReorderPoints', u'false', []]],
    u'the full constructor that builds the search tree\n']
parseName: cv.KDTree.KDTree with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::KDTree namespace:cv classpath:KDTree classname:KDTree name:KDTree
register (constructor) new in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.KDTree',
    u'',
    ['/NW'],
    [   [u'InputArray', u'points', '', []],
        [u'InputArray', u'_labels', '', []],
        [u'bool', u'copyAndReorderPoints', u'false', []]],
    u'the full constructor that builds the search tree\n']
parseName: cv.KDTree.KDTree with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::KDTree namespace:cv classpath:KDTree classname:KDTree name:KDTree
register (constructor) new in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.build',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'points', '', []],
        [u'bool', u'copyAndReorderPoints', u'false', []]],
    u'builds the search tree\n']
parseName: cv.KDTree.build with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::build namespace:cv classpath:KDTree classname:KDTree name:build
register (method) build in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.build',
    u'void',
    ['/NW'],
    [   [u'InputArray', u'points', '', []],
        [u'InputArray', u'labels', '', []],
        [u'bool', u'copyAndReorderPoints', u'false', []]],
    u'builds the search tree\n']
parseName: cv.KDTree.build with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::build namespace:cv classpath:KDTree classname:KDTree name:build
register (method) build in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.findNearest',
    u'int',
    ['/NW', '/C'],
    [   [u'InputArray', u'vec', '', []],
        [u'int', u'K', '', []],
        [u'int', u'Emax', '', []],
        [u'OutputArray', u'neighborsIdx', '', []],
        [u'OutputArray', u'neighbors', u'noArray()', []],
        [u'OutputArray', u'dist', u'noArray()', []],
        [u'OutputArray', u'labels', u'noArray()', []]],
    u'finds the K nearest neighbors of "vec" while looking at Emax (at most) leaves\n']
parseName: cv.KDTree.findNearest with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::findNearest namespace:cv classpath:KDTree classname:KDTree name:findNearest
register (method) findNearest in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.findOrthoRange',
    u'void',
    ['/NW', '/C'],
    [   [u'InputArray', u'minBounds', '', []],
        [u'InputArray', u'maxBounds', '', []],
        [u'OutputArray', u'neighborsIdx', '', []],
        [u'OutputArray', u'neighbors', u'noArray()', []],
        [u'OutputArray', u'labels', u'noArray()', []]],
    u'finds all the points from the initial set that belong to the specified box\n']
parseName: cv.KDTree.findOrthoRange with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::findOrthoRange namespace:cv classpath:KDTree classname:KDTree name:findOrthoRange
register (method) findOrthoRange in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.getPoints',
    u'void',
    ['/NW', '/C'],
    [   [u'InputArray', u'idx', '', []],
        [u'OutputArray', u'pts', '', []],
        [u'OutputArray', u'labels', u'noArray()', []]],
    u'returns vectors with the specified indices\n']
parseName: cv.KDTree.getPoints with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::getPoints namespace:cv classpath:KDTree classname:KDTree name:getPoints
register (method) getPoints in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.getPoint',
    u'const float*',
    ['/NW', '/C'],
    [[u'int', u'ptidx', '', []], [u'int*', u'label', u'0', []]],
    u'return a vector with the specified index\n']
parseName: cv.KDTree.getPoint with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::getPoint namespace:cv classpath:KDTree classname:KDTree name:getPoint
register (method) getPoint in cv::KDTree

--- Incoming ---
[   u'cv.KDTree.dims',
    u'int',
    ['/NW', '/C'],
    [],
    u'returns the search space dimensionality\n']
parseName: cv.KDTree.dims with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::KDTree::dims namespace:cv classpath:KDTree classname:KDTree name:dims
register (method) dims in cv::KDTree

--- Incoming ---
[   u'class cv.FileStorage',
    '',
    [],
    [],
    u'XML/YAML File Storage Class.\n\nThe class describes an object associated with XML or YAML file.\nIt can be used to store data to such a file or read and decode the data.\n\nThe storage is organized as a tree of nested sequences (or lists) and mappings.\nSequence is a heterogenious array, which elements are accessed by indices or sequentially using an iterator.\nMapping is analogue of std::map or C structure, which elements are accessed by names.\nThe most top level structure is a mapping.\nLeaves of the file storage tree are integers, floating-point numbers and text strings.\n\nFor example, the following code:\n\n\\code\n// open file storage for writing. Type of the file is determined from the extension\nFileStorage fs("test.yml", FileStorage::WRITE);\nfs << "test_int" << 5 << "test_real" << 3.1 << "test_string" << "ABCDEFGH";\nfs << "test_mat" << Mat::eye(3,3,CV_32F);\n\nfs << "test_list" << "[" << 0.0000000000001 << 2 << CV_PI << -3435345 << "2-502 2-029 3egegeg" <<\n"{:" << "month" << 12 << "day" << 31 << "year" << 1969 << "}" << "]";\nfs << "test_map" << "{" << "x" << 1 << "y" << 2 << "width" << 100 << "height" << 200 << "lbp" << "[:";\n\nconst uchar arr[] = {0, 1, 1, 0, 1, 1, 0, 1};\nfs.writeRaw("u", arr, (int)(sizeof(arr)/sizeof(arr[0])));\n\nfs << "]" << "}";\n\\endcode\n\nwill produce the following file:\n\n\\verbatim\n%YAML:1.0\ntest_int: 5\ntest_real: 3.1000000000000001e+00\ntest_string: ABCDEFGH\ntest_mat: !!opencv-matrix\nrows: 3\ncols: 3\ndt: f\ndata: [ 1., 0., 0., 0., 1., 0., 0., 0., 1. ]\ntest_list:\n- 1.0000000000000000e-13\n- 2\n- 3.1415926535897931e+00\n- -3435345\n- "2-502 2-029 3egegeg"\n- { month:12, day:31, year:1969 }\ntest_map:\nx: 1\ny: 2\nwidth: 100\nheight: 200\nlbp: [ 0, 1, 1, 0, 1, 1, 0, 1 ]\n\\endverbatim\n\nand to read the file above, the following code can be used:\n\n\\code\n// open file storage for reading.\n// Type of the file is determined from the content, not the extension\nFileStorage fs("test.yml", FileStorage::READ);\nint test_int = (int)fs["test_int"];\ndouble test_real = (double)fs["test_real"];\nstring test_string = (string)fs["test_string"];\n\nMat M;\nfs["test_mat"] >> M;\n\nFileNode tl = fs["test_list"];\nCV_Assert(tl.type() == FileNode::SEQ && tl.size() == 6);\ndouble tl0 = (double)tl[0];\nint tl1 = (int)tl[1];\ndouble tl2 = (double)tl[2];\nint tl3 = (int)tl[3];\nstring tl4 = (string)tl[4];\nCV_Assert(tl[5].type() == FileNode::MAP && tl[5].size() == 3);\n\nint month = (int)tl[5]["month"];\nint day = (int)tl[5]["day"];\nint year = (int)tl[5]["year"];\n\nFileNode tm = fs["test_map"];\n\nint x = (int)tm["x"];\nint y = (int)tm["y"];\nint width = (int)tm["width"];\nint height = (int)tm["height"];\n\nint lbp_val = 0;\nFileNodeIterator it = tm["lbp"].begin();\n\nfor(int k = 0; k < 8; k++, ++it)\nlbp_val |= ((int)*it) << k;\n\\endcode\n']
parseName: class cv.FileStorage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage namespace:cv classpath: classname: name:FileStorage
register class cv::FileStorage ([u'class cv.FileStorage', '', [], [], u'XML/YAML File Storage Class.\n\nThe class describes an object associated with XML or YAML file.\nIt can be used to store data to such a file or read and decode the data.\n\nThe storage is organized as a tree of nested sequences (or lists) and mappings.\nSequence is a heterogenious array, which elements are accessed by indices or sequentially using an iterator.\nMapping is analogue of std::map or C structure, which elements are accessed by names.\nThe most top level structure is a mapping.\nLeaves of the file storage tree are integers, floating-point numbers and text strings.\n\nFor example, the following code:\n\n\\code\n// open file storage for writing. Type of the file is determined from the extension\nFileStorage fs("test.yml", FileStorage::WRITE);\nfs << "test_int" << 5 << "test_real" << 3.1 << "test_string" << "ABCDEFGH";\nfs << "test_mat" << Mat::eye(3,3,CV_32F);\n\nfs << "test_list" << "[" << 0.0000000000001 << 2 << CV_PI << -3435345 << "2-502 2-029 3egegeg" <<\n"{:" << "month" << 12 << "day" << 31 << "year" << 1969 << "}" << "]";\nfs << "test_map" << "{" << "x" << 1 << "y" << 2 << "width" << 100 << "height" << 200 << "lbp" << "[:";\n\nconst uchar arr[] = {0, 1, 1, 0, 1, 1, 0, 1};\nfs.writeRaw("u", arr, (int)(sizeof(arr)/sizeof(arr[0])));\n\nfs << "]" << "}";\n\\endcode\n\nwill produce the following file:\n\n\\verbatim\n%YAML:1.0\ntest_int: 5\ntest_real: 3.1000000000000001e+00\ntest_string: ABCDEFGH\ntest_mat: !!opencv-matrix\nrows: 3\ncols: 3\ndt: f\ndata: [ 1., 0., 0., 0., 1., 0., 0., 0., 1. ]\ntest_list:\n- 1.0000000000000000e-13\n- 2\n- 3.1415926535897931e+00\n- -3435345\n- "2-502 2-029 3egegeg"\n- { month:12, day:31, year:1969 }\ntest_map:\nx: 1\ny: 2\nwidth: 100\nheight: 200\nlbp: [ 0, 1, 1, 0, 1, 1, 0, 1 ]\n\\endverbatim\n\nand to read the file above, the following code can be used:\n\n\\code\n// open file storage for reading.\n// Type of the file is determined from the content, not the extension\nFileStorage fs("test.yml", FileStorage::READ);\nint test_int = (int)fs["test_int"];\ndouble test_real = (double)fs["test_real"];\nstring test_string = (string)fs["test_string"];\n\nMat M;\nfs["test_mat"] >> M;\n\nFileNode tl = fs["test_list"];\nCV_Assert(tl.type() == FileNode::SEQ && tl.size() == 6);\ndouble tl0 = (double)tl[0];\nint tl1 = (int)tl[1];\ndouble tl2 = (double)tl[2];\nint tl3 = (int)tl[3];\nstring tl4 = (string)tl[4];\nCV_Assert(tl[5].type() == FileNode::MAP && tl[5].size() == 3);\n\nint month = (int)tl[5]["month"];\nint day = (int)tl[5]["day"];\nint year = (int)tl[5]["year"];\n\nFileNode tm = fs["test_map"];\n\nint x = (int)tm["x"];\nint y = (int)tm["y"];\nint width = (int)tm["width"];\nint height = (int)tm["height"];\n\nint lbp_val = 0;\nFileNodeIterator it = tm["lbp"].begin();\n\nfor(int k = 0; k < 8; k++, ++it)\nlbp_val |= ((int)*it) << k;\n\\endcode\n']) [ignored]

--- Incoming ---
[u'const cv.FileStorage.READ', u'0', [], []]
parseName: const cv.FileStorage.READ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::READ namespace:cv classpath:FileStorage classname:FileStorage name:READ

--- Incoming ---
[u'const cv.FileStorage.WRITE', u'1', [], []]
parseName: const cv.FileStorage.WRITE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::WRITE namespace:cv classpath:FileStorage classname:FileStorage name:WRITE

--- Incoming ---
[u'const cv.FileStorage.APPEND', u'2', [], []]
parseName: const cv.FileStorage.APPEND with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::APPEND namespace:cv classpath:FileStorage classname:FileStorage name:APPEND

--- Incoming ---
[u'const cv.FileStorage.MEMORY', u'4', [], []]
parseName: const cv.FileStorage.MEMORY with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::MEMORY namespace:cv classpath:FileStorage classname:FileStorage name:MEMORY

--- Incoming ---
[u'const cv.FileStorage.FORMAT_MASK', u'(7<<3)', [], []]
parseName: const cv.FileStorage.FORMAT_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FORMAT_MASK namespace:cv classpath:FileStorage classname:FileStorage name:FORMAT_MASK

--- Incoming ---
[u'const cv.FileStorage.FORMAT_AUTO', u'0', [], []]
parseName: const cv.FileStorage.FORMAT_AUTO with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FORMAT_AUTO namespace:cv classpath:FileStorage classname:FileStorage name:FORMAT_AUTO

--- Incoming ---
[u'const cv.FileStorage.FORMAT_XML', u'(1<<3)', [], []]
parseName: const cv.FileStorage.FORMAT_XML with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FORMAT_XML namespace:cv classpath:FileStorage classname:FileStorage name:FORMAT_XML

--- Incoming ---
[u'const cv.FileStorage.FORMAT_YAML', u'(2<<3)', [], []]
parseName: const cv.FileStorage.FORMAT_YAML with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FORMAT_YAML namespace:cv classpath:FileStorage classname:FileStorage name:FORMAT_YAML

--- Incoming ---
[u'const cv.FileStorage.UNDEFINED', u'0', [], []]
parseName: const cv.FileStorage.UNDEFINED with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::UNDEFINED namespace:cv classpath:FileStorage classname:FileStorage name:UNDEFINED

--- Incoming ---
[u'const cv.FileStorage.VALUE_EXPECTED', u'1', [], []]
parseName: const cv.FileStorage.VALUE_EXPECTED with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::VALUE_EXPECTED namespace:cv classpath:FileStorage classname:FileStorage name:VALUE_EXPECTED

--- Incoming ---
[u'const cv.FileStorage.NAME_EXPECTED', u'2', [], []]
parseName: const cv.FileStorage.NAME_EXPECTED with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::NAME_EXPECTED namespace:cv classpath:FileStorage classname:FileStorage name:NAME_EXPECTED

--- Incoming ---
[u'const cv.FileStorage.INSIDE_MAP', u'4', [], []]
parseName: const cv.FileStorage.INSIDE_MAP with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::INSIDE_MAP namespace:cv classpath:FileStorage classname:FileStorage name:INSIDE_MAP

--- Incoming ---
[u'cv.FileStorage.FileStorage', u'', ['/NW'], [], u'the default constructor\n']
parseName: cv.FileStorage.FileStorage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FileStorage namespace:cv classpath:FileStorage classname:FileStorage name:FileStorage
register (constructor) new in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.FileStorage',
    u'',
    ['/NW'],
    [   [u'const string&', u'source', '', []],
        [u'int', u'flags', '', []],
        [u'const string&', u'encoding', u'string()', []]],
    u'the full constructor that opens file storage for reading or writing\n']
parseName: cv.FileStorage.FileStorage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FileStorage namespace:cv classpath:FileStorage classname:FileStorage name:FileStorage
register (constructor) new in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.FileStorage',
    u'',
    ['/NW'],
    [[u'CvFileStorage*', u'fs', '', []]],
    u'the constructor that takes pointer to the C FileStorage structure\n']
parseName: cv.FileStorage.FileStorage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::FileStorage namespace:cv classpath:FileStorage classname:FileStorage name:FileStorage
Registering an unknown type: CvFileStorage
register (constructor) new in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.~FileStorage',
    u'',
    ['/NW'],
    [],
    u'the destructor. calls release()\n']
parseName: cv.FileStorage.~FileStorage with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::~FileStorage namespace:cv classpath:FileStorage classname:FileStorage name:~FileStorage
ignore destructor (method) ~FileStorage in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.open',
    u'bool',
    ['/NW'],
    [   [u'const string&', u'filename', '', []],
        [u'int', u'flags', '', []],
        [u'const string&', u'encoding', u'string()', []]],
    u'opens file storage for reading or writing. The previous storage is closed with release()\n']
parseName: cv.FileStorage.open with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::open namespace:cv classpath:FileStorage classname:FileStorage name:open
register (method) open in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.isOpened',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the object is associated with currently opened file.\n']
parseName: cv.FileStorage.isOpened with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::isOpened namespace:cv classpath:FileStorage classname:FileStorage name:isOpened
register (method) isOpened in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.release',
    u'void',
    ['/NW'],
    [],
    u'closes the file and releases all the memory buffers\n']
parseName: cv.FileStorage.release with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::release namespace:cv classpath:FileStorage classname:FileStorage name:release
register (method) release in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.releaseAndGetString',
    u'string',
    ['/NW'],
    [],
    u'closes the file, releases all the memory buffers and returns the text string\n']
parseName: cv.FileStorage.releaseAndGetString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::releaseAndGetString namespace:cv classpath:FileStorage classname:FileStorage name:releaseAndGetString
register (method) releaseAndGetString in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.getFirstTopLevelNode',
    u'FileNode',
    ['/NW', '/C'],
    [],
    u'returns the first element of the top-level mapping\n']
parseName: cv.FileStorage.getFirstTopLevelNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::getFirstTopLevelNode namespace:cv classpath:FileStorage classname:FileStorage name:getFirstTopLevelNode
Registering an unknown type: FileNode
register (method) getFirstTopLevelNode in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.root',
    u'FileNode',
    ['/NW', '/C'],
    [[u'int', u'streamidx', u'0', []]],
    u'returns the top-level mapping. YAML supports multiple streams\n']
parseName: cv.FileStorage.root with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::root namespace:cv classpath:FileStorage classname:FileStorage name:root
register (method) root in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.operator[]',
    u'FileNode',
    ['/NW', '/C'],
    [[u'const string&', u'nodename', '', []]],
    u'returns the specified element of the top-level mapping\n']
parseName: cv.FileStorage.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::operator[] namespace:cv classpath:FileStorage classname:FileStorage name:operator[]
ignore (method) operator[] in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.operator[]',
    u'FileNode',
    ['/NW', '/C'],
    [[u'const char*', u'nodename', '', []]],
    u'returns the specified element of the top-level mapping\n']
parseName: cv.FileStorage.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::operator[] namespace:cv classpath:FileStorage classname:FileStorage name:operator[]
ignore (method) operator[] in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.operator *',
    u'CvFileStorage*',
    ['/NW'],
    [],
    u'returns pointer to the underlying C FileStorage structure\n']
parseName: cv.FileStorage.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::operator * namespace:cv classpath:FileStorage classname:FileStorage name:operator *
ignore (method) operator * in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.operator *',
    u'const CvFileStorage*',
    ['/NW', '/C'],
    [],
    u'returns pointer to the underlying C FileStorage structure\n']
parseName: cv.FileStorage.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::operator * namespace:cv classpath:FileStorage classname:FileStorage name:operator *
ignore (method) operator * in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.writeRaw',
    u'void',
    ['/NW'],
    [   [u'const string&', u'fmt', '', []],
        [u'const uchar*', u'vec', '', []],
        [u'size_t', u'len', '', []]],
    u'writes one or more numbers of the specified format to the currently written structure\n']
parseName: cv.FileStorage.writeRaw with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::writeRaw namespace:cv classpath:FileStorage classname:FileStorage name:writeRaw
register (method) writeRaw in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.writeObj',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'const void*', u'obj', '', []]],
    u'writes the registered C structure (CvMat, CvMatND, CvSeq). See cvWrite()\n']
parseName: cv.FileStorage.writeObj with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::writeObj namespace:cv classpath:FileStorage classname:FileStorage name:writeObj
register (method) writeObj in cv::FileStorage

--- Incoming ---
[   u'cv.FileStorage.getDefaultObjectName',
    u'string',
    ['/NW', '/S'],
    [[u'const string&', u'filename', '', []]],
    u'returns the normalized object name for the specified file name\n']
parseName: cv.FileStorage.getDefaultObjectName with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileStorage::getDefaultObjectName namespace:cv classpath:FileStorage classname:FileStorage name:getDefaultObjectName
register (method) getDefaultObjectName in cv::FileStorage

--- Incoming ---
[   u'class cv.FileNode',
    '',
    ['/Simple'],
    [],
    u'File Storage Node class\n\nThe node is used to store each and every element of the file storage opened for reading -\nfrom the primitive objects, such as numbers and text strings, to the complex nodes:\nsequences, mappings and the registered objects.\n\nNote that file nodes are only used for navigating file storages opened for reading.\nWhen a file storage is opened for writing, no data is stored in memory after it is written.\n']
parseName: class cv.FileNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode namespace:cv classpath: classname: name:FileNode
register class cv::FileNode ([u'class cv.FileNode', '', ['/Simple'], [], u'File Storage Node class\n\nThe node is used to store each and every element of the file storage opened for reading -\nfrom the primitive objects, such as numbers and text strings, to the complex nodes:\nsequences, mappings and the registered objects.\n\nNote that file nodes are only used for navigating file storages opened for reading.\nWhen a file storage is opened for writing, no data is stored in memory after it is written.\n']) [ignored]

--- Incoming ---
[u'const cv.FileNode.NONE', u'0', [], []]
parseName: const cv.FileNode.NONE with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::NONE namespace:cv classpath:FileNode classname:FileNode name:NONE

--- Incoming ---
[u'const cv.FileNode.INT', u'1', [], []]
parseName: const cv.FileNode.INT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::INT namespace:cv classpath:FileNode classname:FileNode name:INT

--- Incoming ---
[u'const cv.FileNode.REAL', u'2', [], []]
parseName: const cv.FileNode.REAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::REAL namespace:cv classpath:FileNode classname:FileNode name:REAL

--- Incoming ---
[u'const cv.FileNode.FLOAT', u'REAL', [], []]
parseName: const cv.FileNode.FLOAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::FLOAT namespace:cv classpath:FileNode classname:FileNode name:FLOAT

--- Incoming ---
[u'const cv.FileNode.STR', u'3', [], []]
parseName: const cv.FileNode.STR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::STR namespace:cv classpath:FileNode classname:FileNode name:STR

--- Incoming ---
[u'const cv.FileNode.STRING', u'STR', [], []]
parseName: const cv.FileNode.STRING with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::STRING namespace:cv classpath:FileNode classname:FileNode name:STRING

--- Incoming ---
[u'const cv.FileNode.REF', u'4', [], []]
parseName: const cv.FileNode.REF with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::REF namespace:cv classpath:FileNode classname:FileNode name:REF

--- Incoming ---
[u'const cv.FileNode.SEQ', u'5', [], []]
parseName: const cv.FileNode.SEQ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::SEQ namespace:cv classpath:FileNode classname:FileNode name:SEQ

--- Incoming ---
[u'const cv.FileNode.MAP', u'6', [], []]
parseName: const cv.FileNode.MAP with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::MAP namespace:cv classpath:FileNode classname:FileNode name:MAP

--- Incoming ---
[u'const cv.FileNode.TYPE_MASK', u'7', [], []]
parseName: const cv.FileNode.TYPE_MASK with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::TYPE_MASK namespace:cv classpath:FileNode classname:FileNode name:TYPE_MASK

--- Incoming ---
[u'const cv.FileNode.FLOW', u'8', [], []]
parseName: const cv.FileNode.FLOW with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::FLOW namespace:cv classpath:FileNode classname:FileNode name:FLOW

--- Incoming ---
[u'const cv.FileNode.USER', u'16', [], []]
parseName: const cv.FileNode.USER with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::USER namespace:cv classpath:FileNode classname:FileNode name:USER

--- Incoming ---
[u'const cv.FileNode.EMPTY', u'32', [], []]
parseName: const cv.FileNode.EMPTY with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::EMPTY namespace:cv classpath:FileNode classname:FileNode name:EMPTY

--- Incoming ---
[u'const cv.FileNode.NAMED', u'64', [], []]
parseName: const cv.FileNode.NAMED with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::NAMED namespace:cv classpath:FileNode classname:FileNode name:NAMED

--- Incoming ---
[u'cv.FileNode.FileNode', u'', ['/NW'], [], u'the default constructor\n']
parseName: cv.FileNode.FileNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::FileNode namespace:cv classpath:FileNode classname:FileNode name:FileNode
register (constructor) new in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.FileNode',
    u'',
    ['/NW'],
    [   [u'const CvFileStorage*', u'fs', '', []],
        [u'const CvFileNode*', u'node', '', []]],
    u'the full constructor wrapping CvFileNode structure.\n']
parseName: cv.FileNode.FileNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::FileNode namespace:cv classpath:FileNode classname:FileNode name:FileNode
Registering an unknown type: CvFileStorage
register (constructor) new in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.FileNode',
    u'',
    ['/NW'],
    [[u'const FileNode&', u'node', '', []]],
    u'the copy constructor\n']
parseName: cv.FileNode.FileNode with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::FileNode namespace:cv classpath:FileNode classname:FileNode name:FileNode
register (constructor) new in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator[]',
    u'FileNode',
    ['/NW', '/C'],
    [[u'const string&', u'nodename', '', []]],
    u'returns element of a mapping node\n']
parseName: cv.FileNode.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator[] namespace:cv classpath:FileNode classname:FileNode name:operator[]
ignore (method) operator[] in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator[]',
    u'FileNode',
    ['/NW', '/C'],
    [[u'const char*', u'nodename', '', []]],
    u'returns element of a mapping node\n']
parseName: cv.FileNode.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator[] namespace:cv classpath:FileNode classname:FileNode name:operator[]
ignore (method) operator[] in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator[]',
    u'FileNode',
    ['/NW', '/C'],
    [[u'int', u'i', '', []]],
    u'returns element of a sequence node\n']
parseName: cv.FileNode.operator[] with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator[] namespace:cv classpath:FileNode classname:FileNode name:operator[]
ignore (method) operator[] in cv::FileNode (simple)

--- Incoming ---
[u'cv.FileNode.type', u'int', ['/NW', '/C'], [], u'returns type of the node\n']
parseName: cv.FileNode.type with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::type namespace:cv classpath:FileNode classname:FileNode name:type
register (method) type in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.empty',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is empty\n']
parseName: cv.FileNode.empty with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::empty namespace:cv classpath:FileNode classname:FileNode name:empty
register (method) empty in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isNone',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is a "none" object\n']
parseName: cv.FileNode.isNone with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isNone namespace:cv classpath:FileNode classname:FileNode name:isNone
register (method) isNone in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isSeq',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is a sequence\n']
parseName: cv.FileNode.isSeq with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isSeq namespace:cv classpath:FileNode classname:FileNode name:isSeq
register (method) isSeq in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isMap',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is a mapping\n']
parseName: cv.FileNode.isMap with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isMap namespace:cv classpath:FileNode classname:FileNode name:isMap
register (method) isMap in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isInt',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is an integer\n']
parseName: cv.FileNode.isInt with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isInt namespace:cv classpath:FileNode classname:FileNode name:isInt
register (method) isInt in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isReal',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is a floating-point number\n']
parseName: cv.FileNode.isReal with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isReal namespace:cv classpath:FileNode classname:FileNode name:isReal
register (method) isReal in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isString',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node is a text string\n']
parseName: cv.FileNode.isString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isString namespace:cv classpath:FileNode classname:FileNode name:isString
register (method) isString in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.isNamed',
    u'bool',
    ['/NW', '/C'],
    [],
    u'returns true if the node has a name\n']
parseName: cv.FileNode.isNamed with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::isNamed namespace:cv classpath:FileNode classname:FileNode name:isNamed
register (method) isNamed in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.name',
    u'string',
    ['/NW', '/C'],
    [],
    u'returns the node name or an empty string if the node is nameless\n']
parseName: cv.FileNode.name with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::name namespace:cv classpath:FileNode classname:FileNode name:name
register (method) name in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.size',
    u'size_t',
    ['/NW', '/C'],
    [],
    u'returns the number of elements in the node, if it is a sequence or mapping, or 1 otherwise.\n']
parseName: cv.FileNode.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::size namespace:cv classpath:FileNode classname:FileNode name:size
register (method) size in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator int',
    u'',
    ['/NW', '/C'],
    [],
    u'returns the node content as an integer. If the node stores floating-point number, it is rounded.\n']
parseName: cv.FileNode.operator int with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator int namespace:cv classpath:FileNode classname:FileNode name:operator int
ignore (method) operator int in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator float',
    u'',
    ['/NW', '/C'],
    [],
    u'returns the node content as float\n']
parseName: cv.FileNode.operator float with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator float namespace:cv classpath:FileNode classname:FileNode name:operator float
ignore (method) operator float in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator double',
    u'',
    ['/NW', '/C'],
    [],
    u'returns the node content as double\n']
parseName: cv.FileNode.operator double with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator double namespace:cv classpath:FileNode classname:FileNode name:operator double
ignore (method) operator double in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator string',
    u'',
    ['/NW', '/C'],
    [],
    u'returns the node content as text string\n']
parseName: cv.FileNode.operator string with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator string namespace:cv classpath:FileNode classname:FileNode name:operator string
ignore (method) operator string in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator *',
    u'CvFileNode*',
    ['/NW'],
    [],
    u'returns pointer to the underlying file node\n']
parseName: cv.FileNode.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator * namespace:cv classpath:FileNode classname:FileNode name:operator *
ignore (method) operator * in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.operator *',
    u'const CvFileNode*',
    ['/NW', '/C'],
    [],
    u'returns pointer to the underlying file node\n']
parseName: cv.FileNode.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::operator * namespace:cv classpath:FileNode classname:FileNode name:operator *
ignore (method) operator * in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.begin',
    u'FileNodeIterator',
    ['/NW', '/C'],
    [],
    u'returns iterator pointing to the first node element\n']
parseName: cv.FileNode.begin with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::begin namespace:cv classpath:FileNode classname:FileNode name:begin
Registering an unknown type: FileNodeIterator
register (method) begin in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.end',
    u'FileNodeIterator',
    ['/NW', '/C'],
    [],
    u'returns iterator pointing to the element following the last node element\n']
parseName: cv.FileNode.end with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::end namespace:cv classpath:FileNode classname:FileNode name:end
register (method) end in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.readRaw',
    u'void',
    ['/NW', '/C'],
    [   [u'const string&', u'fmt', '', []],
        [u'uchar*', u'vec', '', []],
        [u'size_t', u'len', '', []]],
    u'reads node elements to the buffer with the specified format\n']
parseName: cv.FileNode.readRaw with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::readRaw namespace:cv classpath:FileNode classname:FileNode name:readRaw
register (method) readRaw in cv::FileNode (simple)

--- Incoming ---
[   u'cv.FileNode.readObj',
    u'void*',
    ['/NW', '/C'],
    [],
    u'reads the registered object and returns pointer to it\n']
parseName: cv.FileNode.readObj with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNode::readObj namespace:cv classpath:FileNode classname:FileNode name:readObj
register (method) readObj in cv::FileNode (simple)

--- Incoming ---
[   u'class cv.FileNodeIterator',
    '',
    [],
    [],
    u'File Node Iterator\n\nThe class is used for iterating sequences (usually) and mappings.\n']
parseName: class cv.FileNodeIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator namespace:cv classpath: classname: name:FileNodeIterator
register class cv::FileNodeIterator ([u'class cv.FileNodeIterator', '', [], [], u'File Node Iterator\n\nThe class is used for iterating sequences (usually) and mappings.\n']) [ignored]

--- Incoming ---
[   u'cv.FileNodeIterator.FileNodeIterator',
    u'',
    ['/NW'],
    [],
    u'the default constructor\n']
parseName: cv.FileNodeIterator.FileNodeIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::FileNodeIterator namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:FileNodeIterator
register (constructor) new in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.FileNodeIterator',
    u'',
    ['/NW'],
    [   [u'const CvFileStorage*', u'fs', '', []],
        [u'const CvFileNode*', u'node', '', []],
        [u'size_t', u'ofs', u'0', []]],
    u'the full constructor set to the ofs-th element of the node\n']
parseName: cv.FileNodeIterator.FileNodeIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::FileNodeIterator namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:FileNodeIterator
register (constructor) new in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.FileNodeIterator',
    u'',
    ['/NW'],
    [[u'const FileNodeIterator&', u'it', '', []]],
    u'the copy constructor\n']
parseName: cv.FileNodeIterator.FileNodeIterator with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::FileNodeIterator namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:FileNodeIterator
register (constructor) new in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator *',
    u'FileNode',
    ['/NW', '/C'],
    [],
    u'returns the currently observed element\n']
parseName: cv.FileNodeIterator.operator * with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator * namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator *
ignore (method) operator * in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator ->',
    u'FileNode',
    ['/NW', '/C'],
    [],
    u'accesses the currently observed element methods\n']
parseName: cv.FileNodeIterator.operator -> with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator -> namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator ->
ignore (method) operator -> in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator ++',
    u'FileNodeIterator&',
    ['/NW'],
    [],
    u'moves iterator to the next node\n']
parseName: cv.FileNodeIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator ++ namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator ++
ignore (method) operator ++ in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator ++',
    u'FileNodeIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'moves iterator to the next node\n']
parseName: cv.FileNodeIterator.operator ++ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator ++ namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator ++
ignore (method) operator ++ in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator --',
    u'FileNodeIterator&',
    ['/NW'],
    [],
    u'moves iterator to the previous node\n']
parseName: cv.FileNodeIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator -- namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator --
ignore (method) operator -- in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator --',
    u'FileNodeIterator',
    ['/NW'],
    [[u'int', '', '', []]],
    u'moves iterator to the previous node\n']
parseName: cv.FileNodeIterator.operator -- with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator -- namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator --
ignore (method) operator -- in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator +=',
    u'FileNodeIterator&',
    ['/NW'],
    [[u'int', u'ofs', '', []]],
    u'moves iterator forward by the specified offset (possibly negative)\n']
parseName: cv.FileNodeIterator.operator += with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator += namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator +=
ignore (method) operator += in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.operator -=',
    u'FileNodeIterator&',
    ['/NW'],
    [[u'int', u'ofs', '', []]],
    u'moves iterator backward by the specified offset (possibly negative)\n']
parseName: cv.FileNodeIterator.operator -= with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::operator -= namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:operator -=
ignore (method) operator -= in cv::FileNodeIterator

--- Incoming ---
[   u'cv.FileNodeIterator.readRaw',
    u'FileNodeIterator&',
    ['/NW'],
    [   [u'const string&', u'fmt', '', []],
        [u'uchar*', u'vec', '', []],
        [u'size_t', u'maxCount', u'(size_t)INT_MAX', []]],
    u'reads the next maxCount elements (or less, if the sequence/mapping last element occurs earlier) to the buffer with the specified format\n']
parseName: cv.FileNodeIterator.readRaw with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::FileNodeIterator::readRaw namespace:cv classpath:FileNodeIterator classname:FileNodeIterator name:readRaw
register (method) readRaw in cv::FileNodeIterator

--- Incoming ---
[   u'class cv.Algorithm',
    '',
    [],
    [],
    u'Base class for high-level OpenCV algorithms\n']
parseName: class cv.Algorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm namespace:cv classpath: classname: name:Algorithm
register class cv::Algorithm ([u'class cv.Algorithm', '', [], [], u'Base class for high-level OpenCV algorithms\n'])

--- Incoming ---
['cv.Algorithm', u'', ['/NW'], [], '']
parseName: cv.Algorithm.Algorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::Algorithm namespace:cv classpath:Algorithm classname:Algorithm name:Algorithm
register (constructor) new in cv::Algorithm

--- Incoming ---
[u'cv.Algorithm.~Algorithm', u'', ['/NW'], [], '']
parseName: cv.Algorithm.~Algorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::~Algorithm namespace:cv classpath:Algorithm classname:Algorithm name:~Algorithm
ignore destructor (method) ~Algorithm in cv::Algorithm

--- Incoming ---
[u'cv.Algorithm.name', u'string', ['/NW', '/C'], [], '']
parseName: cv.Algorithm.name with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::name namespace:cv classpath:Algorithm classname:Algorithm name:name
register (method) name in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getInt',
    u'int',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getInt with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getInt namespace:cv classpath:Algorithm classname:Algorithm name:getInt
register (method) getInt in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getDouble',
    u'double',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getDouble with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getDouble namespace:cv classpath:Algorithm classname:Algorithm name:getDouble
register (method) getDouble in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getBool',
    u'bool',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getBool with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getBool namespace:cv classpath:Algorithm classname:Algorithm name:getBool
register (method) getBool in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getString',
    u'string',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getString namespace:cv classpath:Algorithm classname:Algorithm name:getString
register (method) getString in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getMat',
    u'Mat',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getMat namespace:cv classpath:Algorithm classname:Algorithm name:getMat
register (method) getMat in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getMatVector',
    u'vector<Mat>',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getMatVector with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getMatVector namespace:cv classpath:Algorithm classname:Algorithm name:getMatVector
register (method) getMatVector in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getAlgorithm',
    u'Ptr<Algorithm>',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.getAlgorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getAlgorithm namespace:cv classpath:Algorithm classname:Algorithm name:getAlgorithm
register (method) getAlgorithm in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'int', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'double', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'bool', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const string&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'const Mat&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const vector<Mat>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const Ptr<Algorithm>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setInt',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'int', u'value', '', []]],
    '']
parseName: cv.Algorithm.setInt with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setInt namespace:cv classpath:Algorithm classname:Algorithm name:setInt
register (method) setInt in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setDouble',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'double', u'value', '', []]],
    '']
parseName: cv.Algorithm.setDouble with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setDouble namespace:cv classpath:Algorithm classname:Algorithm name:setDouble
register (method) setDouble in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setBool',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'bool', u'value', '', []]],
    '']
parseName: cv.Algorithm.setBool with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setBool namespace:cv classpath:Algorithm classname:Algorithm name:setBool
register (method) setBool in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setString',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const string&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setString namespace:cv classpath:Algorithm classname:Algorithm name:setString
register (method) setString in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setMat',
    u'void',
    ['/NW'],
    [[u'const string&', u'name', '', []], [u'const Mat&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setMat namespace:cv classpath:Algorithm classname:Algorithm name:setMat
register (method) setMat in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setMatVector',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const vector<Mat>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setMatVector with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setMatVector namespace:cv classpath:Algorithm classname:Algorithm name:setMatVector
register (method) setMatVector in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setAlgorithm',
    u'void',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'const Ptr<Algorithm>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setAlgorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setAlgorithm namespace:cv classpath:Algorithm classname:Algorithm name:setAlgorithm
register (method) setAlgorithm in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'int', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'double', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'bool', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'const string&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'const Mat&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [   [u'const char*', u'name', '', []],
        [u'const vector<Mat>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.set',
    u'void',
    ['/NW'],
    [   [u'const char*', u'name', '', []],
        [u'const Ptr<Algorithm>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::set namespace:cv classpath:Algorithm classname:Algorithm name:set
register (method) set in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setInt',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'int', u'value', '', []]],
    '']
parseName: cv.Algorithm.setInt with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setInt namespace:cv classpath:Algorithm classname:Algorithm name:setInt
register (method) setInt in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setDouble',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'double', u'value', '', []]],
    '']
parseName: cv.Algorithm.setDouble with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setDouble namespace:cv classpath:Algorithm classname:Algorithm name:setDouble
register (method) setDouble in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setBool',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'bool', u'value', '', []]],
    '']
parseName: cv.Algorithm.setBool with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setBool namespace:cv classpath:Algorithm classname:Algorithm name:setBool
register (method) setBool in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setString',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'const string&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setString namespace:cv classpath:Algorithm classname:Algorithm name:setString
register (method) setString in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setMat',
    u'void',
    ['/NW'],
    [[u'const char*', u'name', '', []], [u'const Mat&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setMat with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setMat namespace:cv classpath:Algorithm classname:Algorithm name:setMat
register (method) setMat in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setMatVector',
    u'void',
    ['/NW'],
    [   [u'const char*', u'name', '', []],
        [u'const vector<Mat>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setMatVector with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setMatVector namespace:cv classpath:Algorithm classname:Algorithm name:setMatVector
register (method) setMatVector in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.setAlgorithm',
    u'void',
    ['/NW'],
    [   [u'const char*', u'name', '', []],
        [u'const Ptr<Algorithm>&', u'value', '', []]],
    '']
parseName: cv.Algorithm.setAlgorithm with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::setAlgorithm namespace:cv classpath:Algorithm classname:Algorithm name:setAlgorithm
register (method) setAlgorithm in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.paramHelp',
    u'string',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.paramHelp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::paramHelp namespace:cv classpath:Algorithm classname:Algorithm name:paramHelp
register (method) paramHelp in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.paramType',
    u'int',
    ['/NW', '/C'],
    [[u'const char*', u'name', '', []]],
    '']
parseName: cv.Algorithm.paramType with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::paramType namespace:cv classpath:Algorithm classname:Algorithm name:paramType
register (method) paramType in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.paramType',
    u'int',
    ['/NW', '/C'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm.paramType with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::paramType namespace:cv classpath:Algorithm classname:Algorithm name:paramType
register (method) paramType in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getParams',
    u'void',
    ['/NW', '/C'],
    [[u'vector<string>&', u'names', '', []]],
    '']
parseName: cv.Algorithm.getParams with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getParams namespace:cv classpath:Algorithm classname:Algorithm name:getParams
register (method) getParams in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.write',
    u'void',
    ['/NW', '/C'],
    [[u'FileStorage&', u'fs', '', []]],
    '']
parseName: cv.Algorithm.write with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::write namespace:cv classpath:Algorithm classname:Algorithm name:write
register (method) write in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.read',
    u'void',
    ['/NW'],
    [[u'const FileNode&', u'fn', '', []]],
    '']
parseName: cv.Algorithm.read with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::read namespace:cv classpath:Algorithm classname:Algorithm name:read
register (method) read in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm.getList',
    u'void',
    ['/NW', '/S'],
    [[u'vector<string>&', u'algorithms', '', []]],
    '']
parseName: cv.Algorithm.getList with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::getList namespace:cv classpath:Algorithm classname:Algorithm name:getList
register (method) getList in cv::Algorithm

--- Incoming ---
[   u'cv.Algorithm._create',
    u'Ptr<Algorithm>',
    ['/NW', '/S'],
    [[u'const string&', u'name', '', []]],
    '']
parseName: cv.Algorithm._create with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::_create namespace:cv classpath:Algorithm classname:Algorithm name:_create
register (method) _create in cv::Algorithm

--- Incoming ---
[u'cv.Algorithm.info', u'AlgorithmInfo*', ['/NW', '/C'], [], '']
parseName: cv.Algorithm.info with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Algorithm::info namespace:cv classpath:Algorithm classname:Algorithm name:info
Registering an unknown type: AlgorithmInfo
register (method) info in cv::Algorithm

--- Incoming ---
[u'class cv.AlgorithmInfo', '', [], [], '']
parseName: class cv.AlgorithmInfo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo namespace:cv classpath: classname: name:AlgorithmInfo
register class cv::AlgorithmInfo ([u'class cv.AlgorithmInfo', '', [], [], '']) [ignored]

--- Incoming ---
[   u'cv.AlgorithmInfo.AlgorithmInfo',
    u'',
    ['/NW'],
    [   [u'const string&', u'name', '', []],
        [u'Algorithm::Constructor', u'create', '', []]],
    '']
parseName: cv.AlgorithmInfo.AlgorithmInfo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::AlgorithmInfo namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:AlgorithmInfo
Registering an unknown type: Algorithm::Constructor
register (constructor) new in cv::AlgorithmInfo

--- Incoming ---
[u'cv.AlgorithmInfo.~AlgorithmInfo', u'', ['/NW'], [], '']
parseName: cv.AlgorithmInfo.~AlgorithmInfo with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::~AlgorithmInfo namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:~AlgorithmInfo
ignore destructor (method) ~AlgorithmInfo in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.get',
    u'void',
    ['/NW', '/C'],
    [   [u'const Algorithm*', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'int', u'argType', '', []],
        [u'void*', u'value', '', []]],
    '']
parseName: cv.AlgorithmInfo.get with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::get namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:get
register (method) get in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam_',
    u'void',
    ['/NW'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'int', u'argType', '', []],
        [u'void*', u'value', '', []],
        [u'bool', u'readOnly', '', []],
        [u'Algorithm::Getter', u'getter', '', []],
        [u'Algorithm::Setter', u'setter', '', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam_ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam_ namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam_
Registering an unknown type: Algorithm::Getter
Registering an unknown type: Algorithm::Setter
register (method) addParam_ in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.paramHelp',
    u'string',
    ['/NW', '/C'],
    [[u'const char*', u'name', '', []]],
    '']
parseName: cv.AlgorithmInfo.paramHelp with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::paramHelp namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:paramHelp
register (method) paramHelp in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.paramType',
    u'int',
    ['/NW', '/C'],
    [[u'const char*', u'name', '', []]],
    '']
parseName: cv.AlgorithmInfo.paramType with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::paramType namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:paramType
register (method) paramType in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.getParams',
    u'void',
    ['/NW', '/C'],
    [[u'vector<string>&', u'names', '', []]],
    '']
parseName: cv.AlgorithmInfo.getParams with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::getParams namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:getParams
register (method) getParams in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.write',
    u'void',
    ['/NW', '/C'],
    [[u'const Algorithm*', u'algo', '', []], [u'FileStorage&', u'fs', '', []]],
    '']
parseName: cv.AlgorithmInfo.write with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::write namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:write
register (method) write in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.read',
    u'void',
    ['/NW', '/C'],
    [[u'Algorithm*', u'algo', '', []], [u'const FileNode&', u'fn', '', []]],
    '']
parseName: cv.AlgorithmInfo.read with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::read namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:read
register (method) read in cv::AlgorithmInfo

--- Incoming ---
[u'cv.AlgorithmInfo.name', u'string', ['/NW', '/C'], [], '']
parseName: cv.AlgorithmInfo.name with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::name namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:name
register (method) name in cv::AlgorithmInfo

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'int&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'int (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(int)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: int (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(int)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'short&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'int (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(int)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'bool&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'int (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(int)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'double&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'double (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(double)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: double (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(double)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'string&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'string (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(const string&)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: string (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(string&)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'Mat&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'Mat (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(const Mat&)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: Mat (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(Mat&)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'vector<Mat>&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'vector<Mat> (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(const vector<Mat>&)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: Mat> (Algorithm::*getter)(
Registering an unknown type: void (Algorithm::*setter)(vector<Mat>&)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'Ptr<Algorithm>&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'Ptr<Algorithm> (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(const Ptr<Algorithm>&)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: Algorithm> (Algorithm::*getter)(
Registering an unknown type: void (Algorithm::*setter)(Ptr<Algorithm>&)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'float&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'float (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(float)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: float (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(float)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'unsigned int&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'unsigned int (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(unsigned int)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: unsigned int
Registering an unknown type: unsigned int (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(unsigned int)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'uint64&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'uint64 (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(uint64)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: uint64
Registering an unknown type: uint64 (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(uint64)

--- Incoming ---
[   u'cv.AlgorithmInfo.addParam',
    u'void',
    ['/NW', '/A'],
    [   [u'Algorithm&', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'uchar&', u'value', '', []],
        [u'bool', u'readOnly', u'false', []],
        [u'uchar (Algorithm::*getter)()', u'', u'0', []],
        [u'void (Algorithm::*setter)(uchar)', u'', u'0', []],
        [u'const string&', u'help', u'string()', []]],
    '']
parseName: cv.AlgorithmInfo.addParam with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::addParam namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:addParam
Registering an unknown type: uchar (Algorithm::*getter)()
Registering an unknown type: void (Algorithm::*setter)(uchar)

--- Incoming ---
[   u'cv.AlgorithmInfo.set',
    u'void',
    ['/NW', '/C', '/H'],
    [   [u'Algorithm*', u'algo', '', []],
        [u'const char*', u'name', '', []],
        [u'int', u'argType', '', []],
        [u'const void*', u'value', '', []],
        [u'bool', u'force', u'false', []]],
    '']
parseName: cv.AlgorithmInfo.set with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AlgorithmInfo::set namespace:cv classpath:AlgorithmInfo classname:AlgorithmInfo name:set

--- Incoming ---
[u'struct cv.Param', '', [], [], '']
parseName: struct cv.Param with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param namespace:cv classpath: classname: name:Param
register class cv::Param ([u'struct cv.Param', '', [], [], '']) [ignored]

--- Incoming ---
[u'const cv.Param.INT', u'0', [], []]
parseName: const cv.Param.INT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::INT namespace:cv classpath:Param classname:Param name:INT

--- Incoming ---
[u'const cv.Param.BOOLEAN', u'1', [], []]
parseName: const cv.Param.BOOLEAN with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::BOOLEAN namespace:cv classpath:Param classname:Param name:BOOLEAN

--- Incoming ---
[u'const cv.Param.REAL', u'2', [], []]
parseName: const cv.Param.REAL with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::REAL namespace:cv classpath:Param classname:Param name:REAL

--- Incoming ---
[u'const cv.Param.STRING', u'3', [], []]
parseName: const cv.Param.STRING with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::STRING namespace:cv classpath:Param classname:Param name:STRING

--- Incoming ---
[u'const cv.Param.MAT', u'4', [], []]
parseName: const cv.Param.MAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::MAT namespace:cv classpath:Param classname:Param name:MAT

--- Incoming ---
[u'const cv.Param.MAT_VECTOR', u'5', [], []]
parseName: const cv.Param.MAT_VECTOR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::MAT_VECTOR namespace:cv classpath:Param classname:Param name:MAT_VECTOR

--- Incoming ---
[u'const cv.Param.ALGORITHM', u'6', [], []]
parseName: const cv.Param.ALGORITHM with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::ALGORITHM namespace:cv classpath:Param classname:Param name:ALGORITHM

--- Incoming ---
[u'const cv.Param.FLOAT', u'7', [], []]
parseName: const cv.Param.FLOAT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::FLOAT namespace:cv classpath:Param classname:Param name:FLOAT

--- Incoming ---
[u'const cv.Param.UNSIGNED_INT', u'8', [], []]
parseName: const cv.Param.UNSIGNED_INT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::UNSIGNED_INT namespace:cv classpath:Param classname:Param name:UNSIGNED_INT

--- Incoming ---
[u'const cv.Param.UINT64', u'9', [], []]
parseName: const cv.Param.UINT64 with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::UINT64 namespace:cv classpath:Param classname:Param name:UINT64

--- Incoming ---
[u'const cv.Param.SHORT', u'10', [], []]
parseName: const cv.Param.SHORT with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::SHORT namespace:cv classpath:Param classname:Param name:SHORT

--- Incoming ---
[u'const cv.Param.UCHAR', u'11', [], []]
parseName: const cv.Param.UCHAR with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::UCHAR namespace:cv classpath:Param classname:Param name:UCHAR

--- Incoming ---
[u'cv.Param.Param', u'', ['/NW'], [], '']
parseName: cv.Param.Param with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::Param namespace:cv classpath:Param classname:Param name:Param
register (constructor) new in cv::Param

--- Incoming ---
[   u'cv.Param.Param',
    u'',
    ['/NW'],
    [   [u'int', u'_type', '', []],
        [u'bool', u'_readonly', '', []],
        [u'int', u'_offset', '', []],
        [u'Algorithm::Getter', u'_getter', u'0', []],
        [u'Algorithm::Setter', u'_setter', u'0', []],
        [u'const string&', u'_help', u'string()', []]],
    '']
parseName: cv.Param.Param with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Param::Param namespace:cv classpath:Param classname:Param name:Param
register (constructor) new in cv::Param

--- Incoming ---
[   u'class cv.CommandLineParser',
    '',
    [],
    [],
    u'"\\nThe CommandLineParser class is designed for command line arguments parsing\\n"\n"Keys map: \\n"\n"Before you start to work with CommandLineParser you have to create a map for keys.\\n"\n"    It will look like this\\n"\n"    const char* keys =\\n"\n"    {\\n"\n"        {    s|  string|  123asd |string parameter}\\n"\n"        {    d|  digit |  100    |digit parameter }\\n"\n"        {    c|noCamera|false    |without camera  }\\n"\n"        {    1|        |some text|help            }\\n"\n"        {    2|        |333      |another help    }\\n"\n"    };\\n"\n"Usage syntax: \\n"\n"    \\"{\\" - start of parameter string.\\n"\n"    \\"}\\" - end of parameter string\\n"\n"    \\"|\\" - separator between short name, full name, default value and help\\n"\n"Supported syntax: \\n"\n"    --key1=arg1  <If a key with \'--\' must has an argument\\n"\n"                  you have to assign it through \'=\' sign.> \\n"\n"<If the key with \'--\' doesn\'t have any argument, it means that it is a bool key>\\n"\n"    -key2=arg2   <If a key with \'-\' must has an argument \\n"\n"                  you have to assign it through \'=\' sign.> \\n"\n"If the key with \'-\' doesn\'t have any argument, it means that it is a bool key\\n"\n"    key3                 <This key can\'t has any parameter> \\n"\n"Usage: \\n"\n"      Imagine that the input parameters are next:\\n"\n"                -s=string_value --digit=250 --noCamera lena.jpg 10000\\n"\n"    CommandLineParser parser(argc, argv, keys) - create a parser object\\n"\n"    parser.get<string>(\\"s\\" or \\"string\\") will return you first parameter value\\n"\n"    parser.get<string>(\\"s\\", false or \\"string\\", false) will return you first parameter value\\n"\n"                                                                without spaces in end and begin\\n"\n"    parser.get<int>(\\"d\\" or \\"digit\\") will return you second parameter value.\\n"\n"                    It also works with \'unsigned int\', \'double\', and \'float\' types>\\n"\n"    parser.get<bool>(\\"c\\" or \\"noCamera\\") will return you true .\\n"\n"                                If you enter this key in commandline>\\n"\n"                                It return you false otherwise.\\n"\n"    parser.get<string>(\\"1\\") will return you the first argument without parameter (lena.jpg) \\n"\n"    parser.get<int>(\\"2\\") will return you the second argument without parameter (10000)\\n"\n"                          It also works with \'unsigned int\', \'double\', and \'float\' types \\n"\n']
parseName: class cv.CommandLineParser with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CommandLineParser namespace:cv classpath: classname: name:CommandLineParser
register class cv::CommandLineParser ([u'class cv.CommandLineParser', '', [], [], u'"\\nThe CommandLineParser class is designed for command line arguments parsing\\n"\n"Keys map: \\n"\n"Before you start to work with CommandLineParser you have to create a map for keys.\\n"\n"    It will look like this\\n"\n"    const char* keys =\\n"\n"    {\\n"\n"        {    s|  string|  123asd |string parameter}\\n"\n"        {    d|  digit |  100    |digit parameter }\\n"\n"        {    c|noCamera|false    |without camera  }\\n"\n"        {    1|        |some text|help            }\\n"\n"        {    2|        |333      |another help    }\\n"\n"    };\\n"\n"Usage syntax: \\n"\n"    \\"{\\" - start of parameter string.\\n"\n"    \\"}\\" - end of parameter string\\n"\n"    \\"|\\" - separator between short name, full name, default value and help\\n"\n"Supported syntax: \\n"\n"    --key1=arg1  <If a key with \'--\' must has an argument\\n"\n"                  you have to assign it through \'=\' sign.> \\n"\n"<If the key with \'--\' doesn\'t have any argument, it means that it is a bool key>\\n"\n"    -key2=arg2   <If a key with \'-\' must has an argument \\n"\n"                  you have to assign it through \'=\' sign.> \\n"\n"If the key with \'-\' doesn\'t have any argument, it means that it is a bool key\\n"\n"    key3                 <This key can\'t has any parameter> \\n"\n"Usage: \\n"\n"      Imagine that the input parameters are next:\\n"\n"                -s=string_value --digit=250 --noCamera lena.jpg 10000\\n"\n"    CommandLineParser parser(argc, argv, keys) - create a parser object\\n"\n"    parser.get<string>(\\"s\\" or \\"string\\") will return you first parameter value\\n"\n"    parser.get<string>(\\"s\\", false or \\"string\\", false) will return you first parameter value\\n"\n"                                                                without spaces in end and begin\\n"\n"    parser.get<int>(\\"d\\" or \\"digit\\") will return you second parameter value.\\n"\n"                    It also works with \'unsigned int\', \'double\', and \'float\' types>\\n"\n"    parser.get<bool>(\\"c\\" or \\"noCamera\\") will return you true .\\n"\n"                                If you enter this key in commandline>\\n"\n"                                It return you false otherwise.\\n"\n"    parser.get<string>(\\"1\\") will return you the first argument without parameter (lena.jpg) \\n"\n"    parser.get<int>(\\"2\\") will return you the second argument without parameter (10000)\\n"\n"                          It also works with \'unsigned int\', \'double\', and \'float\' types \\n"\n']) [ignored]

--- Incoming ---
[   u'cv.CommandLineParser.CommandLineParser',
    u'',
    ['/NW'],
    [   [u'int', u'argc', '', []],
        [u'const char* const[]', u'argv', '', []],
        [u'const char*', u'key_map', '', []]],
    u'the default constructor\n']
parseName: cv.CommandLineParser.CommandLineParser with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CommandLineParser::CommandLineParser namespace:cv classpath:CommandLineParser classname:CommandLineParser name:CommandLineParser
Registering an unknown type: char* const[]
register (constructor) new in cv::CommandLineParser

--- Incoming ---
[   u'cv.CommandLineParser.printParams',
    u'void',
    ['/NW'],
    [],
    u'print short name, full name, current value and help for all params\n']
parseName: cv.CommandLineParser.printParams with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CommandLineParser::printParams namespace:cv classpath:CommandLineParser classname:CommandLineParser name:printParams
register (method) printParams in cv::CommandLineParser

--- Incoming ---
[   u'cv.CommandLineParser.getString',
    u'std::string',
    ['/NW', '/H'],
    [[u'const std::string&', u'name', '', []]],
    '']
parseName: cv.CommandLineParser.getString with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CommandLineParser::getString namespace:cv classpath:CommandLineParser classname:CommandLineParser name:getString
Registering an unknown type: std::string
Registering an unknown type: std::string

--- Incoming ---
[   u'cv.CommandLineParser.has',
    u'bool',
    ['/NW', '/H'],
    [[u'const std::string&', u'keys', '', []]],
    '']
parseName: cv.CommandLineParser.has with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::CommandLineParser::has namespace:cv classpath:CommandLineParser classname:CommandLineParser name:has

--- Incoming ---
[u'class cv.ParallelLoopBody', '', [], [], '']
parseName: class cv.ParallelLoopBody with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ParallelLoopBody namespace:cv classpath: classname: name:ParallelLoopBody
register class cv::ParallelLoopBody ([u'class cv.ParallelLoopBody', '', [], [], ''])

--- Incoming ---
[u'cv.ParallelLoopBody.~ParallelLoopBody', u'', ['/NW'], [], '']
parseName: cv.ParallelLoopBody.~ParallelLoopBody with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ParallelLoopBody::~ParallelLoopBody namespace:cv classpath:ParallelLoopBody classname:ParallelLoopBody name:~ParallelLoopBody
ignore destructor (method) ~ParallelLoopBody in cv::ParallelLoopBody

--- Incoming ---
[   u'cv.ParallelLoopBody.operator ()',
    u'void',
    ['/NW', '/A', '/C'],
    [[u'const Range&', u'range', '', []]],
    '']
parseName: cv.ParallelLoopBody.operator () with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::ParallelLoopBody::operator () namespace:cv classpath:ParallelLoopBody classname:ParallelLoopBody name:operator ()
ignore (method) operator () in cv::ParallelLoopBody

--- Incoming ---
[   u'cv.parallel_for_',
    u'void',
    ['/NW'],
    [   [u'const Range&', u'range', '', []],
        [u'const ParallelLoopBody&', u'body', '', []],
        [u'double', u'nstripes', u'-1.', []]],
    '']
parseName: cv.parallel_for_ with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::parallel_for_ namespace:cv classpath: classname: name:parallel_for_
register (function) parallel_for_

--- Incoming ---
[u'class cv.Mutex', '', [], [], '']
parseName: class cv.Mutex with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex namespace:cv classpath: classname: name:Mutex
register class cv::Mutex ([u'class cv.Mutex', '', [], [], '']) [ignored]

--- Incoming ---
[u'cv.Mutex.Mutex', u'', ['/NW'], [], '']
parseName: cv.Mutex.Mutex with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::Mutex namespace:cv classpath:Mutex classname:Mutex name:Mutex
register (constructor) new in cv::Mutex

--- Incoming ---
[u'cv.Mutex.~Mutex', u'', ['/NW'], [], '']
parseName: cv.Mutex.~Mutex with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::~Mutex namespace:cv classpath:Mutex classname:Mutex name:~Mutex
ignore destructor (method) ~Mutex in cv::Mutex

--- Incoming ---
[u'cv.Mutex.Mutex', u'', ['/NW'], [[u'const Mutex&', u'm', '', []]], '']
parseName: cv.Mutex.Mutex with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::Mutex namespace:cv classpath:Mutex classname:Mutex name:Mutex
register (constructor) new in cv::Mutex

--- Incoming ---
[   u'cv.Mutex.operator =',
    u'Mutex&',
    ['/NW'],
    [[u'const Mutex&', u'm', '', []]],
    '']
parseName: cv.Mutex.operator = with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::operator = namespace:cv classpath:Mutex classname:Mutex name:operator =
ignore (method) operator = in cv::Mutex

--- Incoming ---
[u'cv.Mutex.lock', u'void', ['/NW'], [], '']
parseName: cv.Mutex.lock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::lock namespace:cv classpath:Mutex classname:Mutex name:lock
register (method) lock in cv::Mutex

--- Incoming ---
[u'cv.Mutex.trylock', u'bool', ['/NW'], [], '']
parseName: cv.Mutex.trylock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::trylock namespace:cv classpath:Mutex classname:Mutex name:trylock
register (method) trylock in cv::Mutex

--- Incoming ---
[u'cv.Mutex.unlock', u'void', ['/NW'], [], '']
parseName: cv.Mutex.unlock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mutex::unlock namespace:cv classpath:Mutex classname:Mutex name:unlock
register (method) unlock in cv::Mutex

--- Incoming ---
[u'class cv.AutoLock', '', [], [], '']
parseName: class cv.AutoLock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AutoLock namespace:cv classpath: classname: name:AutoLock
register class cv::AutoLock ([u'class cv.AutoLock', '', [], [], ''])

--- Incoming ---
[u'cv.AutoLock.AutoLock', u'', ['/NW'], [[u'Mutex&', u'm', '', []]], '']
parseName: cv.AutoLock.AutoLock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AutoLock::AutoLock namespace:cv classpath:AutoLock classname:AutoLock name:AutoLock
register (constructor) new in cv::AutoLock

--- Incoming ---
[u'cv.AutoLock.~AutoLock', u'', ['/NW'], [], '']
parseName: cv.AutoLock.~AutoLock with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::AutoLock::~AutoLock namespace:cv classpath:AutoLock classname:AutoLock name:~AutoLock
ignore destructor (method) ~AutoLock in cv::AutoLock

--- Incoming ---
[u'class cv.TLSDataContainer', '', [], [], '']
parseName: class cv.TLSDataContainer with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer namespace:cv classpath: classname: name:TLSDataContainer
register class cv::TLSDataContainer ([u'class cv.TLSDataContainer', '', [], [], '']) [ignored]

--- Incoming ---
[u'cv.TLSDataContainer.TLSDataContainer', u'', ['/NW', '/H'], [], '']
parseName: cv.TLSDataContainer.TLSDataContainer with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer::TLSDataContainer namespace:cv classpath:TLSDataContainer classname:TLSDataContainer name:TLSDataContainer

--- Incoming ---
[u'cv.TLSDataContainer.~TLSDataContainer', u'', ['/NW', '/H'], [], '']
parseName: cv.TLSDataContainer.~TLSDataContainer with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer::~TLSDataContainer namespace:cv classpath:TLSDataContainer classname:TLSDataContainer name:~TLSDataContainer
ignore destructor (method) ~TLSDataContainer in cv::TLSDataContainer

--- Incoming ---
[   u'cv.TLSDataContainer.createDataInstance',
    u'void*',
    ['/NW', '/A', '/C'],
    [],
    '']
parseName: cv.TLSDataContainer.createDataInstance with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer::createDataInstance namespace:cv classpath:TLSDataContainer classname:TLSDataContainer name:createDataInstance

--- Incoming ---
[   u'cv.TLSDataContainer.deleteDataInstance',
    u'void',
    ['/NW', '/A', '/C'],
    [[u'void*', u'data', '', []]],
    '']
parseName: cv.TLSDataContainer.deleteDataInstance with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer::deleteDataInstance namespace:cv classpath:TLSDataContainer classname:TLSDataContainer name:deleteDataInstance

--- Incoming ---
[u'cv.TLSDataContainer.getData', u'void*', ['/NW', '/C'], [], '']
parseName: cv.TLSDataContainer.getData with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::TLSDataContainer::getData namespace:cv classpath:TLSDataContainer classname:TLSDataContainer name:getData
register (method) getData in cv::TLSDataContainer

--- Manual ---
['cv.Mat.size', 'Size', ['/C'], []]
parseName: cv.Mat.size with ['', u'cv::gpu', 'cv', u'cv::ogl'] -> fullname:cv::Mat::size namespace:cv classpath:Mat classname:Mat name:size
register (method) size in cv::Mat


===== Generating... =====
Generating func cvAttrList (function)
  ignored: return type class CvAttrList (boxed) is ignored
Generating func cvCeil (function)
Generating func cvFloor (function)
Generating func cvIplDepth (function)
Generating func cvIsInf (function)
Generating func cvIsNaN (function)
Generating func cvMat (function)
  ignored: return type class CvMat (boxed) is ignored
Generating func cvPoint2D32f (function)
  ignored: return type class CvPoint2D32f (boxed) is ignored
Generating func cvPoint2D64f (function)
  ignored: return type class CvPoint2D64f (boxed) is ignored
Generating func cvPoint3D32f (function)
  ignored: return type class CvPoint3D32f (boxed) is ignored
Generating func cvPoint3D64f (function)
  ignored: return type class CvPoint3D64f (boxed) is ignored
Generating func cvPointFrom32f (function)
  ignored: return type class CvPoint (boxed) is ignored
Generating func cvPointTo32f (function)
  ignored: return type class CvPoint2D32f (boxed) is ignored
Generating func cvPoint (function)
  ignored: return type class CvPoint (boxed) is ignored
Generating func cvRNG (function)
Generating func cvROIToRect (function)
  ignored: return type class CvRect (boxed) is ignored
Generating func cvRandInt (function)
  ignored: return type class Unknown[unsigned] is ignored
Generating func cvRandReal (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cvRealScalar (function)
  ignored: return type class CvScalar (boxed) is ignored
Generating func cvRectToROI (function)
  ignored: return type class IplROI (boxed) is ignored
Generating func cvRect (function)
  ignored: return type class CvRect (boxed) is ignored
Generating func cvRound (function)
Generating func cvScalarAll (function)
  ignored: return type class CvScalar (boxed) is ignored
Generating func cvScalar (function)
  ignored: return type class CvScalar (boxed) is ignored
Generating func cvSize2D32f (function)
  ignored: return type class CvSize2D32f (boxed) is ignored
Generating func cvSize (function)
  ignored: return type class CvSize (boxed) is ignored
Generating func cvSlice (function)
  ignored: return type class CvSlice (boxed) is ignored
Generating func cvTermCriteria (function)
  ignored: return type class CvTermCriteria (boxed) is ignored
Generating func cv::LUT (function)
Generating func cv::Mahalanobis (function)
Generating func cv::Mahalonobis (function)
Generating func cv::PCABackProject (function)
Generating func cv::PCAComputeVar (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::PCACompute (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::PCAProject (function)
Generating func cv::SVBackSubst (function)
Generating func cv::SVDecomp (function)
Generating func cv::absdiff (function)
Generating func cv::addWeighted (function)
Generating func cv::add (function)
Generating func cv::alignSize (function)
Generating func cv::arrowedLine (function)
Generating func cv::batchDistance (function)
Generating func cv::bitwise_and (function)
Generating func cv::bitwise_not (function)
Generating func cv::bitwise_or (function)
Generating func cv::bitwise_xor (function)
Generating func cv::calcCovarMatrix (function)
  ignored: ignored by renamed table
Generating func cv::calcCovarMatrix (function)
Generating func cv::cartToPolar (function)
Generating func cv::checkHardwareSupport (function)
Generating func cv::checkRange (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::circle (function)
Generating func cv::clipLine (function)
Generating func cv::clipLine (function)
Generating func cv::compare (function)
Generating func cv::completeSymm (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::convertScaleAbs (function)
Generating func cv::countNonZero (function)
Generating func cv::cubeRoot (function)
Generating func cv::cvarrToMat (function)
  ignored: can not map type Unknown[CvArr] yet
Generating func cv::dct (function)
Generating func cv::determinant (function)
Generating func cv::dft (function)
Generating func cv::divide (function)
Generating func cv::divide (function)
Generating func cv::drawMarker (function)
Generating func cv::eigen (function)
Generating func cv::eigen (function)
Generating func cv::eigen (function)
Generating func cv::ellipse2Poly (function)
Generating func cv::ellipse (function)
Generating func cv::ellipse (function)
Generating func cv::error (function)
  ignored: can not map type cv::Exception (boxed) yet
Generating func cv::exp (function)
Generating func cv::exp (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::extractChannel (function)
Generating func cv::extractImageCOI (function)
  ignored: can not map type Unknown[CvArr] yet
Generating func cv::fastAtan2 (function)
Generating func cv::fastAtan2 (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::fastFree (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::fastMalloc (function)
  ignored: return type class RawPtr[Primitive(void)] is ignored
Generating func cv::fillConvexPoly (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::fillConvexPoly (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::fillPoly (function)
  ignored: can not map type RawPtr[Point (struct)] yet
Generating func cv::fillPoly (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::findNonZero (function)
Generating func cv::flip (function)
Generating func cv::format (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::fromUtf16 (function)
  ignored: can not map type Unknown[WString] yet
Generating func cv::gemm (function)
Generating func cv::getBuildInformation (function)
Generating func cv::getCPUTickCount (function)
Generating func cv::getConvertElem (function)
  ignored: return type class Unknown[ConvertData] is ignored
Generating func cv::getConvertFunc (function)
  ignored: return type class Unknown[BinaryFunc] is ignored
Generating func cv::getConvertScaleElem (function)
  ignored: return type class Unknown[ConvertScaleData] is ignored
Generating func cv::getConvertScaleFunc (function)
  ignored: return type class Unknown[BinaryFunc] is ignored
Generating func cv::getCopyMaskFunc (function)
  ignored: return type class Unknown[BinaryFunc] is ignored
Generating func cv::getElemSize (function)
Generating func cv::getNumThreads (function)
Generating func cv::getNumberOfCPUs (function)
Generating func cv::getOptimalDFTSize (function)
Generating func cv::getTextSize (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::getThreadNum (function)
Generating func cv::getTickCount (function)
Generating func cv::getTickFrequency (function)
Generating func cv::glob (function)
  ignored: can not map type Unknown[String] yet
Generating func cv::hconcat (function)
Generating func cv::hconcat (function)
  ignored: ignored by renamed table
Generating func cv::hconcat (function)
  ignored: can not map type Unknown[InputArrayOfArrays] yet
Generating func cv::idct (function)
Generating func cv::idft (function)
Generating func cv::inRange (function)
Generating func cv::insertChannel (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::insertImageCOI (function)
  ignored: can not map type Unknown[CvArr] yet
Generating func cv::invert (function)
Generating func cv::kmeans (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::line (function)
Generating func cv::log (function)
Generating func cv::log (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::magnitude (function)
Generating func cv::magnitude (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::max (function)
Generating func cv::max (function)
Generating func cv::max (function)
Generating func cv::meanStdDev (function)
Generating func cv::mean (function)
Generating func cv::merge (function)
  ignored: ignored by renamed table
Generating func cv::merge (function)
Generating func cv::merge (function)
  ignored: can not map type Unknown[InputArrayOfArrays] yet
Generating func cv::minMaxIdx (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::minMaxLoc (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::minMaxLoc (function)
  ignored: can not map type cv::SparseMat (boxed) yet
Generating func cv::min (function)
Generating func cv::min (function)
Generating func cv::min (function)
Generating func cv::mixChannels (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::mixChannels (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::mixChannels (function)
  ignored: can not map type Unknown[InputArrayOfArrays] yet
Generating func cv::mulSpectrums (function)
Generating func cv::mulTransposed (function)
Generating func cv::multiply (function)
Generating func cv::noArray (function)
  ignored: manual ignore from list
Generating func cv::norm (function)
Generating func cv::norm (function)
Generating func cv::norm (function)
  ignored: can not map type cv::SparseMat (boxed) yet
Generating func cv::normalize (function)
Generating func cv::normalize (function)
  ignored: can not map type cv::SparseMat (boxed) yet
Generating func cv::parallel_for_ (function)
Generating func cv::patchNaNs (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::perspectiveTransform (function)
Generating func cv::phase (function)
Generating func cv::polarToCart (function)
Generating func cv::polylines (function)
  ignored: can not map type RawPtr[Point (struct)] yet
Generating func cv::polylines (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::pow (function)
Generating func cv::putText (function)
Generating func cv::randShuffle (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::randShuffle_ (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::randn (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::randu (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::rectangle (function)
Generating func cv::rectangle (function)
Generating func cv::redirectError (function)
  ignored: return type class Unknown[ErrorCallback] is ignored
Generating func cv::reduce (function)
Generating func cv::repeat (function)
Generating func cv::repeat (function)
Generating func cv::scalarToRawData (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::scaleAdd (function)
Generating func cv::setBreakOnError (function)
Generating func cv::setIdentity (function)
  ignored: can not map type Unknown[InputOutputArray] yet
Generating func cv::setNumThreads (function)
Generating func cv::setRNGSeed (function)
Generating func cv::setUseOptimized (function)
Generating func cv::solveCubic (function)
Generating func cv::solvePoly (function)
Generating func cv::solve (function)
Generating func cv::sortIdx (function)
Generating func cv::sort (function)
Generating func cv::split (function)
  ignored: can not map type Unknown[OutputArrayOfArrays] yet
Generating func cv::split (function)
Generating func cv::split (function)
Generating func cv::sqrt (function)
Generating func cv::subtract (function)
Generating func cv::sum (function)
Generating func cv::swap (function)
Generating func cv::tempfile (function)
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::theRNG (function)
  ignored: return type class cv::RNG (boxed) is ignored
Generating func cv::toUtf16 (function)
  ignored: return type class Unknown[WString] is ignored
Generating func cv::trace (function)
Generating func cv::transform (function)
Generating func cv::transpose (function)
Generating func cv::useOptimized (function)
Generating func cv::vconcat (function)
Generating func cv::vconcat (function)
  ignored: ignored by renamed table
Generating func cv::vconcat (function)
  ignored: can not map type Unknown[InputArrayOfArrays] yet
Generating func cvmGet (function)
  ignored: can not map type CvMat (boxed) yet
Generating func cvmSet (function)
  ignored: can not map type CvMat (boxed) yet
Generating impl for trait cv::Algorithm
Generating func cv::Algorithm::Algorithm (constructor) cv::Algorithm . new
  ignored: skip constructor of abstract class
Generating func cv::Algorithm::name (method) cv::Algorithm . name
Generating func cv::Algorithm::getInt (method) cv::Algorithm . getInt
Generating func cv::Algorithm::getDouble (method) cv::Algorithm . getDouble
Generating func cv::Algorithm::getBool (method) cv::Algorithm . getBool
Generating func cv::Algorithm::getString (method) cv::Algorithm . getString
Generating func cv::Algorithm::getMat (method) cv::Algorithm . getMat
Generating func cv::Algorithm::getMatVector (method) cv::Algorithm . getMatVector
Generating func cv::Algorithm::getAlgorithm (method) cv::Algorithm . getAlgorithm
  ignored: return type class SmartPtr[cv::Algorithm (boxed)] is ignored
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: can not map type SmartPtr[cv::Algorithm (boxed)] yet
Generating func cv::Algorithm::setInt (method) cv::Algorithm . setInt
  ignored: ignored by renamed table
Generating func cv::Algorithm::setDouble (method) cv::Algorithm . setDouble
  ignored: ignored by renamed table
Generating func cv::Algorithm::setBool (method) cv::Algorithm . setBool
  ignored: ignored by renamed table
Generating func cv::Algorithm::setString (method) cv::Algorithm . setString
  ignored: ignored by renamed table
Generating func cv::Algorithm::setMat (method) cv::Algorithm . setMat
  ignored: ignored by renamed table
Generating func cv::Algorithm::setMatVector (method) cv::Algorithm . setMatVector
  ignored: ignored by renamed table
Generating func cv::Algorithm::setAlgorithm (method) cv::Algorithm . setAlgorithm
  ignored: can not map type SmartPtr[cv::Algorithm (boxed)] yet
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::set (method) cv::Algorithm . set
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setInt (method) cv::Algorithm . setInt
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setDouble (method) cv::Algorithm . setDouble
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setBool (method) cv::Algorithm . setBool
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setString (method) cv::Algorithm . setString
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setMat (method) cv::Algorithm . setMat
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setMatVector (method) cv::Algorithm . setMatVector
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::setAlgorithm (method) cv::Algorithm . setAlgorithm
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::paramHelp (method) cv::Algorithm . paramHelp
Generating func cv::Algorithm::paramType (method) cv::Algorithm . paramType
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Algorithm::paramType (method) cv::Algorithm . paramType
Generating func cv::Algorithm::getParams (method) cv::Algorithm . getParams
Generating func cv::Algorithm::write (method) cv::Algorithm . write
  ignored: can not map type cv::FileStorage (boxed) yet
Generating func cv::Algorithm::read (method) cv::Algorithm . read
  ignored: can not map type cv::FileNode (simple) yet
Generating func cv::Algorithm::getList (method) cv::Algorithm . getList
Generating func cv::Algorithm::_create (method) cv::Algorithm . _create
  ignored: return type class SmartPtr[cv::Algorithm (boxed)] is ignored
Generating func cv::Algorithm::info (method) cv::Algorithm . info
  ignored: return type class RawPtr[Unknown[AlgorithmInfo]] is ignored
Generating box for struct cv::AutoLock
Generating box for cv::AutoLock
Generating impl for struct cv::AutoLock
Generating func cv::AutoLock::AutoLock (constructor) cv::AutoLock . new
  ignored: can not map type cv::Mutex (boxed) yet
Generating box for struct cv::LineIterator
Generating box for cv::LineIterator
Generating impl for struct cv::LineIterator
Generating func cv::LineIterator::LineIterator (constructor) cv::LineIterator . new
Generating func cv::LineIterator::pos (method) cv::LineIterator . pos
Generating box for struct cv::Mat
Generating box for cv::Mat
Generating impl for struct cv::Mat
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: can not map type CvMat (boxed) yet
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: can not map type CvMatND (boxed) yet
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: can not map type IplImage (boxed) yet
Generating func cv::Mat::Mat (constructor) cv::Mat . new
  ignored: can not map type Unknown[gpu::GpuMat] yet
Generating func cv::Mat::row (method) cv::Mat . row
Generating func cv::Mat::col (method) cv::Mat . col
Generating func cv::Mat::rowRange (method) cv::Mat . rowRange
Generating func cv::Mat::rowRange (method) cv::Mat . rowRange
Generating func cv::Mat::colRange (method) cv::Mat . colRange
Generating func cv::Mat::colRange (method) cv::Mat . colRange
Generating func cv::Mat::diag (method) cv::Mat . diag
Generating func cv::Mat::diag (method) cv::Mat . diag
Generating func cv::Mat::clone (method) cv::Mat . clone
Generating func cv::Mat::copyTo (method) cv::Mat . copyTo
Generating func cv::Mat::copyTo (method) cv::Mat . copyTo
Generating func cv::Mat::convertTo (method) cv::Mat . convertTo
Generating func cv::Mat::assignTo (method) cv::Mat . assignTo
Generating func cv::Mat::setTo (method) cv::Mat . setTo
Generating func cv::Mat::reshape (method) cv::Mat . reshape
Generating func cv::Mat::reshape (method) cv::Mat . reshape
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::t (method) cv::Mat . t
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::inv (method) cv::Mat . inv
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::mul (method) cv::Mat . mul
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::cross (method) cv::Mat . cross
Generating func cv::Mat::dot (method) cv::Mat . dot
Generating func cv::Mat::zeros (method) cv::Mat . zeros
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::zeros (method) cv::Mat . zeros
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::zeros (method) cv::Mat . zeros
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::ones (method) cv::Mat . ones
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::ones (method) cv::Mat . ones
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::ones (method) cv::Mat . ones
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::eye (method) cv::Mat . eye
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::eye (method) cv::Mat . eye
  ignored: return type class Unknown[MatExpr] is ignored
Generating func cv::Mat::create (method) cv::Mat . create
  ignored: ignored by renamed table
Generating func cv::Mat::create (method) cv::Mat . create
  ignored: ignored by renamed table
Generating func cv::Mat::create (method) cv::Mat . create
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::addref (method) cv::Mat . addref
Generating func cv::Mat::release (method) cv::Mat . release
Generating func cv::Mat::deallocate (method) cv::Mat . deallocate
Generating func cv::Mat::copySize (method) cv::Mat . copySize
Generating func cv::Mat::reserve (method) cv::Mat . reserve
Generating func cv::Mat::resize (method) cv::Mat . resize
Generating func cv::Mat::resize (method) cv::Mat . resize
Generating func cv::Mat::push_back_ (method) cv::Mat . push_back_
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::push_back (method) cv::Mat . push_back
Generating func cv::Mat::pop_back (method) cv::Mat . pop_back
Generating func cv::Mat::locateROI (method) cv::Mat . locateROI
Generating func cv::Mat::adjustROI (method) cv::Mat . adjustROI
Generating func cv::Mat::isContinuous (method) cv::Mat . isContinuous
Generating func cv::Mat::isSubmatrix (method) cv::Mat . isSubmatrix
Generating func cv::Mat::elemSize (method) cv::Mat . elemSize
Generating func cv::Mat::elemSize1 (method) cv::Mat . elemSize1
Generating func cv::Mat::type (method) cv::Mat . type
Generating func cv::Mat::depth (method) cv::Mat . depth
Generating func cv::Mat::channels (method) cv::Mat . channels
Generating func cv::Mat::step1 (method) cv::Mat . step1
Generating func cv::Mat::empty (method) cv::Mat . empty
Generating func cv::Mat::total (method) cv::Mat . total
Generating func cv::Mat::checkVector (method) cv::Mat . checkVector
Generating func cv::Mat::ptr (method) cv::Mat . ptr
Generating func cv::Mat::ptr (method) cv::Mat . ptr
  ignored: manual ignore from filter
Generating func cv::Mat::ptr (method) cv::Mat . ptr
Generating func cv::Mat::ptr (method) cv::Mat . ptr
  ignored: manual ignore from filter
Generating func cv::Mat::ptr (method) cv::Mat . ptr
Generating func cv::Mat::ptr (method) cv::Mat . ptr
  ignored: manual ignore from filter
Generating func cv::Mat::ptr (method) cv::Mat . ptr
  ignored: returning primitive by pointer is not supported (FIXME ?)
Generating func cv::Mat::ptr (method) cv::Mat . ptr
  ignored: manual ignore from filter
Generating func cv::Mat::size (method) cv::Mat . size
Generating box for struct cv::Matx_AddOp
Generating box for cv::Matx_AddOp
Generating impl for struct cv::Matx_AddOp
Generating box for struct cv::Matx_MatMulOp
Generating box for cv::Matx_MatMulOp
Generating impl for struct cv::Matx_MatMulOp
Generating box for struct cv::Matx_MulOp
Generating box for cv::Matx_MulOp
Generating impl for struct cv::Matx_MulOp
Generating box for struct cv::Matx_ScaleOp
Generating box for cv::Matx_ScaleOp
Generating impl for struct cv::Matx_ScaleOp
Generating box for struct cv::Matx_SubOp
Generating box for cv::Matx_SubOp
Generating impl for struct cv::Matx_SubOp
Generating box for struct cv::Matx_TOp
Generating box for cv::Matx_TOp
Generating impl for struct cv::Matx_TOp
Generating box for struct cv::NAryMatIterator
Generating box for cv::NAryMatIterator
Generating impl for struct cv::NAryMatIterator
Generating func cv::NAryMatIterator::NAryMatIterator (constructor) cv::NAryMatIterator . new
Generating func cv::NAryMatIterator::NAryMatIterator (constructor) cv::NAryMatIterator . new
  ignored: can not map type RawPtr[cv::Mat (boxed)] yet
Generating func cv::NAryMatIterator::NAryMatIterator (constructor) cv::NAryMatIterator . new
  ignored: can not map type RawPtr[cv::Mat (boxed)] yet
Generating func cv::NAryMatIterator::init (method) cv::NAryMatIterator . init
  ignored: can not map type RawPtr[cv::Mat (boxed)] yet
Generating box for struct cv::PCA
Generating box for cv::PCA
Generating impl for struct cv::PCA
Generating func cv::PCA::PCA (constructor) cv::PCA . new
Generating func cv::PCA::PCA (constructor) cv::PCA . new
Generating func cv::PCA::PCA (constructor) cv::PCA . new
Generating func cv::PCA::computeVar (method) cv::PCA . computeVar
Generating func cv::PCA::project (method) cv::PCA . project
Generating func cv::PCA::project (method) cv::PCA . project
Generating func cv::PCA::backProject (method) cv::PCA . backProject
Generating func cv::PCA::backProject (method) cv::PCA . backProject
Generating impl for trait cv::ParallelLoopBody
Generating box for struct cv::Range
Generating box for cv::Range
Generating impl for struct cv::Range
Generating func cv::Range::Range (constructor) cv::Range . new
Generating func cv::Range::Range (constructor) cv::Range . new
Generating func cv::Range::Range (constructor) cv::Range . new
  ignored: can not map type CvSlice (boxed) yet
Generating func cv::Range::size (method) cv::Range . size
Generating func cv::Range::empty (method) cv::Range . empty
Generating func cv::Range::all (method) cv::Range . all
Generating box for struct cv::RotatedRect
Generating box for cv::RotatedRect
Generating impl for struct cv::RotatedRect
Generating func cv::RotatedRect::RotatedRect (constructor) cv::RotatedRect . new
Generating func cv::RotatedRect::RotatedRect (constructor) cv::RotatedRect . new
Generating func cv::RotatedRect::RotatedRect (constructor) cv::RotatedRect . new
  ignored: can not map type CvBox2D (boxed) yet
Generating func cv::RotatedRect::points (method) cv::RotatedRect . points
  ignored: can not map type Unknown[Point2f[]] yet
Generating func cv::RotatedRect::boundingRect (method) cv::RotatedRect . boundingRect
Generating box for struct cv::TermCriteria
Generating box for cv::TermCriteria
Generating impl for struct cv::TermCriteria
Generating func cv::TermCriteria::TermCriteria (constructor) cv::TermCriteria . new
Generating func cv::TermCriteria::TermCriteria (constructor) cv::TermCriteria . new
Generating func cv::TermCriteria::TermCriteria (constructor) cv::TermCriteria . new
  ignored: can not map type CvTermCriteria (boxed) yet
